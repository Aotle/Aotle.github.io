{"meta":{"title":"Aotle","subtitle":"","description":"","author":"John Doe","url":"https://aotle.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-06-21T05:10:01.101Z","updated":"2020-06-21T05:10:01.101Z","comments":true,"path":"404.html","permalink":"https://aotle.github.io/404.html","excerpt":"","text":"404 哎呀，您访问的页面走丢了呢 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-06-21T05:07:24.743Z","updated":"2020-06-21T05:07:24.743Z","comments":true,"path":"mylist/index.html","permalink":"https://aotle.github.io/mylist/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-13T02:54:24.471Z","updated":"2020-08-13T02:54:24.471Z","comments":true,"path":"about/index.html","permalink":"https://aotle.github.io/about/index.html","excerpt":"","text":"旧事大梦一场，不知苦饴。你是北归的飞鸟，在如洗的岁月里居有一方天地。我是南去的良鱼，在深遂的烟海底从此不知归期。听闻路尽之后，便可各自忘记。各有日落与晨曦，各有青山与白衣。可后来我才知道，路尽没有你，日落青山却是你。"},{"title":"所有分类","date":"2020-06-21T05:03:31.662Z","updated":"2020-06-21T05:03:31.662Z","comments":true,"path":"categories/index.html","permalink":"https://aotle.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-21T05:06:16.504Z","updated":"2020-06-21T05:06:16.504Z","comments":true,"path":"tags/index.html","permalink":"https://aotle.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP快速入门","slug":"PHP快速入门","date":"2020-09-07T09:33:31.000Z","updated":"2020-09-07T11:20:58.134Z","comments":true,"path":"2020/09/07/PHP快速入门/","link":"","permalink":"https://aotle.github.io/2020/09/07/PHP%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"这是一篇PHP快速入门的总结","text":"这是一篇PHP快速入门的总结 hello，world1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;?phpecho &quot;Hello World!&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; PHP 脚本可放置于文档中的任何位置 PHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾，文件后缀名.php 语句以分号结尾 ; 注释：# 单行注释，// 单行注释，/* 多行注释 */ 变量名对大小写敏感：$color 和 $Color 是不同的变量 用户定义的函数、类和关键字（例如 if、else、echo 等等）都对大小写不敏感：Echo &quot;Ok&quot; 和 echo &quot;Ok&quot; 是一样的效果 输出内容到网页上用 echo var_dump()：会返回变量的数据类型和值，调试的时候很有用: var_dump(“text”): string(4) &quot;text&quot;; print_r：Prints human-readable information about a variable PHP变量规则： 变量以 $ 符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _） 变量名称对大小写敏感（$y 与 $Y 是两个不同的变量） 创建变量 创建变量的时候不指定变量的类型 变量没有类型 PHP 自动的根据变量的值转换为正确的数据类型 变量会在首次赋值时被创建 123&lt;?php$x &#x3D; 10; &#x2F;&#x2F; 这样就创建好了一个变量?&gt; 创建常量 使用define()函数创建常量 它使用三个参数 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量是否对大小写敏感，默认是false（大小写敏感） 1234&lt;?phpdefine(\"TIME_ZONE\", \"Beijin\");echo TIME_ZONE; // Beijin?&gt; 变量的作用域 global：函数之外声明的变量拥有 global 作用域，只能在函数以外进行访问 local ：函数内部声明的变量拥有 local 作用域，只能在函数内部进行访问 static：变量在函数执行完后不会被删除，就像 C 语言中用 static $GLOBALS[index] 的数组中存储了所有的全局变量，下标为变量名 1234567891011121314151617181920212223242526272829303132&lt;?php$x = 10; // 全局变量$y = 20; // 全局变量function foo() &#123; // 函数定义 global $x; // 函数内访问全局变量需要在全局变量前加 global 关键字 $z = 30; // 局部变量 // 输出：[x: 10, y: , z: 30]，函数内不能访问全局变量 echo \"[x: $x, y: $y, z: $z]&lt;br&gt;\"; // 用 GLOBAL 数组访问全局变量 echo \"x: &#123;$GLOBALS['x']&#125; &lt;br&gt;\";&#125;foo(); // 执行函数// 输出：[x: 10, y: 20, z: ]，函数外不能访问局部变量echo \"[x: $x, y: $y, z: $z]&lt;br&gt;\"; /////////////////////////////////////////////////////////////////////////function bar() &#123; static $x = 0; echo \"static: $x &lt;br&gt;\"; $x++;&#125;bar(); // static: 0 bar(); // static: 1bar(); // static: 2?&gt; 运算符+ - * / %&gt; &lt; &gt;= &lt;= != == === || &amp;&amp;前置++ 后置++ 前置-- 后置--. .= 用于字符串连接 比较特别的是 ==(值相同就认为相等) ===(值相同，并且类型也要相同) 12345678910111213141516171819202122&lt;?php$x = 10;$y = \"10\";var_dump($x); // int(10)echo \"&lt;br&gt;\";var_dump($y); // string(2) \"10\"echo \"&lt;br&gt;\";echo $x == $y; // 1echo \"&lt;br&gt;\";echo $x === $y; // false 输出是空字符串echo \"&lt;br&gt;\";echo ($x === $y) == false; // 1echo \"&lt;br&gt;\";echo ($x === $y) === false; // 1echo \"&lt;br&gt;\";echo $x . \" apples\"; // 10 apples?&gt; 数字与字符串比较数字与字符串比较时, 先尝试将字符串转换为数字, 再比较, 一个不能转换为数字的字符串, 转换结果为0, 故, 与 0 比较总返回 true 123456789101112131415&lt;?php// String to integer// 返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。// 如果字符串第一个是‘-'，则从第二个开始算起echo (int)(\"a11\"); // 0echo \"&lt;br&gt;\";echo (int)(\"11a\"); // 11echo \"&lt;br&gt;\";echo intval(\"a11\"); // 0echo \"&lt;br&gt;\";echo intval(\"11a\"); // 0echo \"&lt;br&gt;\";echo intval(\"11\", 2); // 3// 这个函数后面的参数代表需要转化的数是几进制?&gt; 控制语句if else for foreach while do while switch case 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?php///////////////////////////////////////////////////////////////////////////////// if else///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;If else&lt;br&gt;\";$score = 70;if ($score &lt; 60) &#123; echo \"小于 60 &lt;br&gt;\";&#125; else if ($score &lt; 80) &#123; echo \"大于等于 60，小于 80 &lt;br&gt;\";&#125; else &#123; echo \"大于 80 &lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// for: 输出 1 到 10///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;For&lt;br&gt;\";for ($i = 1; $i &lt;= 10; $i++) &#123; echo \"$i&lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// foreach: 输出数组中的所有元素///////////////////////////////////////////////////////////////////////////////// foreach 循环只适用于数组，并用于遍历数组中的每个键/值对。echo \"&lt;br&gt;&lt;br&gt;Foreach&lt;br&gt;\";$colors = array(\"Red\", \"Green\", \"Blue\", \"White\", \"Black\");foreach ($colors as $color) &#123; echo \"$color &lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// while: 输出 1 到 10///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;While&lt;br&gt;\";$i = 0;while ($i++ &lt; 10) &#123; echo \"$i&lt;br&gt;\";&#125;///////////////////////////////////////////////////////////////////////////////// do while: 输出 1 到 10///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;Do while&lt;br&gt;\";$i = 1;do &#123; echo \"$i&lt;br&gt;\";&#125; while (++$i &lt;= 10);///////////////////////////////////////////////////////////////////////////////// switch: 可以使用字符串，数字等///////////////////////////////////////////////////////////////////////////////echo \"&lt;br&gt;&lt;br&gt;Switch&lt;br&gt;\";$condition = \"A\";switch ($condition) &#123;case 1: echo \"Is 1 &lt;br&gt;\"; break;case \"a\":case \"A\": echo \"Is A &lt;br&gt;\"; break;case \"B\": echo \"Is B &lt;br&gt;\"; break;default: echo \"Default &lt;br&gt;\";&#125;?&gt; 函数PHP 内置了 1000 多个函数，功能很强大，例如要计算一个字符串的 MD5 并转换为大写 strtoupper(md5(&quot;Tidy Code&quot;)) 得到 ADCF1E98EBD0FD99E1227346B70BD9E2。 函数创建和 JavaScript 很像，都是以关键字 function 开头，然后是函数名和参数列表，参数支持默认值，函数的定义和调用顺序没有要求，可以递归调用。 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpecho fibonacc(10) . \"&lt;br&gt;\"; // 函数调用，输出：55/** * 函数定义: 递归实现斐波那契数列 */function fibonacc($n) &#123; // 变量 $n 的作用域 是 local. if ($n == 1 || $n == 2) &#123; // 递归结束条件 return 1; &#125; return fibonacc($n - 1) + fibonacc($n - 2); // 递归&#125;// 输出：1, 1, 2, 3, 5, 8, 13, 21, 34, 55,for ($i = 1; $i &lt;= 10; $i++) &#123; echo fibonacc($i) . \", \";&#125;echo \"&lt;br&gt;\";/** * 默认参数只能在参数列表最后面，可以有多个默认参数 */function foo($name, $email = \"xxxx@gmail.com\", $mobile = \"xxxxxxxxxxx\") &#123; echo \"Name is: $name, EMail is: $email, Mobile is: $mobile &lt;br&gt;\";&#125;// 输出：Name is: Alice, EMail is: alice@salmon.com, Mobile is: 12345678901foo(\"Alice\", \"alice@salmon.com\", \"12345678901\");// 输出：Name is: Alice, EMail is: alice@salmon.com, Mobile is: xxxxxxxxxxxfoo(\"Alice\", \"alice@salmon.com\");// 输出：Name is: Alice, EMail is: xxxx@gmail.com, Mobile is: xxxxxxxxxxxfoo(\"Alice\");?&gt; 数组PHP 里的数组实际上是一个字典 Dictionary，也可以叫 Map，就是用 key/value 的形式存储。没有给出 key 的时候 key 默认就是用下标 0，1，2 等。 数组用 array() 来创建，数组的长度用 count() 来计算。 同一个 array 对象推荐单纯的作为数组使用，或者是 Map 使用。不要既有数组的用法，同时也有 Map 的用法。 作为普通数组使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php$colors = array(\"Red\", \"Green\", \"Blue\"); // 定义数组///////////////////////////////////////////////////////////////////////////////// 使用下标直接访问数组元素///////////////////////////////////////////////////////////////////////////////$colors[0] = \"Yellow\"; // 给数组赋元素值echo \"$colors[0], $colors[1], $colors[2] &lt;br&gt;\"; // 用下标访问数组的元素echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 使用 for 循环遍历数组///////////////////////////////////////////////////////////////////////////////$len = count($colors);for ($i = 0; $i &lt; $len; $i++) &#123; echo $colors[$i]; echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 使用 foreach 循环遍历数组///////////////////////////////////////////////////////////////////////////////foreach ($colors as $color) &#123; echo $color; echo \"&lt;br&gt;\";&#125;?&gt;///////////////////////////////////////////////////////////////////////////////// 使用数组排序sort() // 以升序对数组排序rsort() // 以降序对数组排序asort() // 根据值，以升序对关联数组进行排序ksort() // 根据键，以升序对关联数组进行排序arsort() // 根据值，以降序对关联数组进行排序krsort() // 根据键，以降序对关联数组进行排序//////////////////////////////////////////////////////////////////////////////&lt;?php$numbers = array(1, 3, 5, 9, 5, 8, 4);$len = count($numbers);echo join(\", \", $numbers) . \"&lt;br&gt;\"; // 输出数组元素// 选择排序: 升序for ($i = 0; $i &lt; $len - 1; $i++) &#123; $k = $i; for ($j = $i; $j &lt; $len; $j++) &#123; if ($numbers[$j] &lt; $numbers[$k]) &#123; $k = $j; &#125; &#125; $temp = $numbers[$k]; $numbers[$k] = $numbers[$i]; $numbers[$i] = $temp;&#125;echo join(\", \", $numbers) . \"&lt;br&gt;\";?&gt; 作为 Map 使用123456789101112131415161718192021222324252627282930&lt;?php$ages = array(\"Alice\"=&gt;\"20\", \"Bob\"=&gt;\"25\", \"Josh\"=&gt;\"30\"); // 创建 Map// 另外一种声明方法$age['Peter']=\"35\";$age['Ben']=\"37\";$age['Joe']=\"43\";///////////////////////////////////////////////////////////////////////////////// 使用 key 访问 value，就像 Java 的 Map： map.getValue(key)///////////////////////////////////////////////////////////////////////////////echo $ages[\"Alice\"];echo \"&lt;br&gt;\";echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 输出所有的 key 和 value.///////////////////////////////////////////////////////////////////////////////foreach($ages as $key=&gt;$value) &#123; echo \"Key: $key, Value: $value\"; echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";///////////////////////////////////////////////////////////////////////////////// 输出所有的 value///////////////////////////////////////////////////////////////////////////////foreach($ages as $value) &#123; echo \"Value: $value\"; echo \"&lt;br&gt;\";&#125;?&gt; 作为数组和 Map 混用，下标和 key 理解起来就比较混乱123456789101112131415161718192021222324&lt;?php$colors = array(\"Red\", \"Green\", \"Blue\"); // 下标是 0，1，2，实际应该理解为 key。$colors[5] = \"Yellow\";$colors[6] = \"Purple\";$colors[\"pink\"] = \"Pink\"; // 第 5 个元素，但是不能用 $colors[5] 访问(是 Yellow)$len = count($colors);for ($i = 0; $i &lt; $len; ++$i) &#123; echo $i . \" \" . $colors[$i]; // 下标 3，4 没有元素，所以输出 到 3，4 时会报错 echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";foreach ($colors as $color) &#123; echo $color; echo \"&lt;br&gt;\";&#125;echo \"-------------------------------------------&lt;br&gt;\";echo $colors[5]; // 数字为 key 时可以不用引号echo \"&lt;br&gt;\";echo $colors[\"5\"];?&gt; 处理 GET 和 POST 请求使用 $_GET[&quot;fieldName&quot;] 取得 get 请求的数据使用 $_POST[&quot;fieldName&quot;] 取得 post 请求的数据 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;form action&#x3D;&quot;form.php&quot; method&#x3D;&quot;GET&quot;&gt; &lt;!-- 换成 POST --&gt; Name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt; Mail: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot;&gt; &lt;&#x2F;form&gt; &lt;hr&gt;&lt;?php$name &#x3D; $_GET[&quot;name&quot;]; &#x2F;&#x2F; 换成 $_POST$mail &#x3D; $_GET[&quot;mail&quot;];echo &quot;Name is: $name, Mail is: $mail&quot;;?&gt;&lt;hr&gt;&lt;?php$name &#x3D; &quot;&quot;;$mail &#x3D; &quot;&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] &#x3D;&#x3D; &quot;GET&quot;) &#123; &#x2F;&#x2F; GET or POST $name &#x3D; $_GET[&quot;name&quot;]; $mail &#x3D; $_GET[&quot;mail&quot;];&#125; else &#123; $name &#x3D; $_POST[&quot;name&quot;]; $mail &#x3D; $_POST[&quot;mail&quot;];&#125;echo &quot;Request method: &#123;$_SERVER[&quot;REQUEST_METHOD&quot;]&#125;&lt;br&gt;&quot;;echo &quot;Name is: $name, Mail is: $mail&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Cookie设置 cookie: setcookie(name, value, expire, path, domain)取得 cookie: $_COOKIE[name]删除 cookie: setcookie(name, “”, time()-3600) 设置 cookie 过期就可以了测试 cookie: isset($_COOKIE[name]) 设置 cookie 的页面12345678910111213&lt;?phpsetcookie(&quot;user&quot;, &quot;Bob&quot;, time() + 3600); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 访问 cookie 的页面123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;?phpecho $_COOKIE[&quot;user&quot;];echo &quot;&lt;br&gt;&quot;;if (isset($_COOKIE[&quot;mail&quot;])) &#123; echo $_COOKIE[&quot;mail&quot;];&#125;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Session使用 session 前必须启动 session: session_start()设置 session: $_SESSION[name]=value取得 session: $_SESSION[name]删除 session: unset($_SESSION[name])，session_destroy()测试 session: isset($\\ _SESSION[name]) 设置 session 的页面1234567891011121314&lt;?phpsession_start(); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie$_SESSION[&#39;number&#39;]&#x3D;1;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 访问 session 的页面12345678910111213141516&lt;?phpsession_start(); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;?phpecho $_SESSION[&quot;number&quot;];?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Include / Require 文件 通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件（在服务器执行它之前）。include 和 require 语句是相同的，除了错误处理方面： require 会生成致命错误（E_COMPILE_ERROR）并停止脚本 include 只生成警告（E_WARNING），并且脚本会继续 因此，如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。这有助于提高应用程序的安全性和完整性，在某个关键文件意外丢失的情况下。包含文件省去了大量的工作。这意味着您可以为所有页面创建标准页头、页脚或者菜单文件。然后，在页头需要更新时，您只需更新这个页头包含文件即可。 include &#39;filename&#39;;require &#39;filename&#39;;include_once(&quot;fileName&quot;);require_once(&quot;fileName&quot;); 括号可要可不要 类的定义推荐用 require_once 1234&lt;!-- footer.php --&gt;&lt;?phpecho \"&lt;p&gt;Copyright © 2006-\" . date(\"Y\") . \" W3School.com.cn&lt;/p&gt;\";?&gt; 12345678910&lt;!-- hello.php --&gt;&lt;html&gt;&lt;body&gt; &lt;?php include 'header1.php';?&gt;&lt;/body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;Section 1&lt;/p&gt; &lt;p&gt;Section 2&lt;/p&gt; &lt;?php require 'footer.php';?&gt;&lt;/body&gt; &lt;p&gt;End&lt;/p&gt;&lt;/html&gt; PHP 的面向对象：类，和 Java 的类很像 类的定义：class className {} 没有访问权限一说 成员变量定义：[qualifier|var] $field; 可以初始化 成员函数定义：[qualifier] function methodName() {}，可带参数 构造函数：__construct() {}，可带参数 创建对象：$obj = new className();，$obj = new className($v1,$v2); 函数调用：$obj-&gt;methodName(); 成员函数内访问成员变量：$this-&gt;fieldName 不是 $this-&gt;$fieldName 成员函数内访问成员函数：$this-&gt;methodName() PHP 不会自动调用父类的构造函数(不支持构造函数重载，可以使用默认参数实现重载)，必须使用 parent 关键字显式地调用 PHP 只支持单继承，使用关键字 extends PHP 也有接口，使用关键字 interface 定义接口，实现接口使用关键字 implements 接口的方法没有实现会报错 访问权限 qualifier：public, protected, private, abstract, final, static。默认是 public 的访问权限 可以把类的定义放在单独的文件里，然后使用 require_once 加载 类定义和继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt;&lt;body&gt;&lt;?phpclass Employee &#123; var $name; var $salary; protected $id; function __construct($name, $salary) &#123; &#x2F;&#x2F; 构造函数 $this-&gt;name &#x3D; $name; $this-&gt;salary &#x3D; $salary; &#125; function getName() &#123; return $this-&gt;name; &#x2F;&#x2F; 不能直接用 return $name; &#125; function setName($name) &#123; $this-&gt;name &#x3D; $name; &#125;&#125;$employee &#x3D; new Employee(&quot;Alice&quot;, 2000);echo $employee-&gt;getName() . &quot;&lt;br&gt;&quot;;$employee-&gt;setName(&quot;Bob&quot;);echo $employee-&gt;getName() . &quot;&lt;br&gt;&quot;;?&gt;&lt;?php&#x2F;&#x2F; 使用继承class Manager extends Employee &#123; var $title; function __construct($name, $salary, $title) &#123; parent::__construct($name, $salary); &#x2F;&#x2F; 调用父类的构造函数 $this-&gt;title &#x3D; $title; &#125; function getTitle() &#123; return $this-&gt;title; &#125;&#125;$manager &#x3D; new Manager(&quot;Alice&quot;, 3000, &quot;Project Manager&quot;);echo $manager-&gt;getName() . &quot;, &quot; . $manager-&gt;getTitle() . &quot;&lt;br&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 实现接口123456789101112131415161718192021222324252627&lt;html&gt;&lt;body&gt;&lt;?phpinterface Flyable &#123; function fly();&#125;interface Runnable &#123; function run();&#125;class Bird implements Flyable, Runnable &#123; function fly() &#123; echo &quot;I can fly.&lt;br&gt;&quot;; &#125; function run() &#123; echo &quot;I can run.&lt;br&gt;&quot;; &#125;&#125;$bird &#x3D; new Bird();$bird-&gt;fly();$bird-&gt;run();?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 静态访问 关键字 self12345678910111213141516171819202122232425&lt;html&gt;&lt;body&gt;&lt;?phpclass Test &#123; public static $count &#x3D; 0; &#x2F;&#x2F; 每创建一个对象 count 就加 1 function __construct() &#123; self::$count++; &#x2F;&#x2F; 函数内部访问静态成员 echo self::$count . &quot; instances are created.&lt;br&gt;&quot;; &#125; static function getCount() &#123; return self::$count; &#125;&#125;echo Test::getCount() . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 类外部访问静态成员函数new Test();new Test();new Test();echo Test::getCount() . &quot;&lt;br&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 实用代码Array to JSON1234&lt;?php$props = array(\"background\"=&gt;\"black\", \"width\"=&gt;300, \"height\"=&gt;600);echo json_encode($props); // &#123;\"background\":\"black\",\"width\":300,\"height\":600&#125;?&gt; 取得正在访问的网页的网址1234567&lt;?php$url = \"http://\".$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'];echo $url . \"&lt;br&gt;\"; // http://localhost:8000/hello.php$name = dirname($url);echo $name . \"&lt;br&gt;\"; // http://localhost:8000?&gt; 使用 PHP 发邮件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;form action&#x3D;&quot;hello.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Mail to:&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail_to&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Subject:&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subject&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Mail From:&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail_from&quot; &#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan&#x3D;&quot;2&quot;&gt;&lt;textarea name&#x3D;&quot;contents&quot; cols&#x3D;&quot;50&quot; rows&#x3D;&quot;10&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send Mail&quot;&#x2F;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;form&gt; &lt;?php $mailTo &#x3D; $_POST[&quot;mail_to&quot;]; $mailFrom &#x3D; $_POST[&quot;mail_from&quot;]; $subject &#x3D; $_POST[&quot;subject&quot;]; $contents &#x3D; $_POST[&quot;contents&quot;]; if ($mailTo &amp;&amp; $mailFrom &amp;&amp; $subject &amp;&amp; $contents) &#123; &#x2F;&#x2F; 前面那些HTML代码都是为了填写信息更容易，实际发送邮件代码只是下面一句 &#x2F;&#x2F; 但首先机器上得启动邮件发送程序，Mac下是默认启动的，Linux好像要自己先配置启动 mail($mailTo, $subject, $contents, &quot;From:&quot;.$mailFrom); echo &quot;Mail is successfully sent!&quot;, &quot;&lt;br&gt;&quot;; &#125; ?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; PHP中的非贪婪匹配，默认用的是贪婪匹配12345678910111213141516171819202122232425262728&lt;pre&gt;&lt;?php// 替换图片的目录为统一路径$string = 'a&lt;img src=\"a/b/x.png\"&gt;,Biao,&lt;img src=\"uploads/y.jpg\"&gt;';$string2 = 'a&lt;img src=\"a/b/x.png\"&gt;,Biao,&lt;img src=\"uploads/y.jpg\"&gt;';// /U为非贪婪，这种非贪婪，是从后面向前找，与+?有些区别$pattern ='/&lt;img src=\"(.*)\\/(.+\\\\..+)\"&gt;/U';$replacement = \"&lt;img src=\\\"__IMG_BASE__/$2\\\"&gt;\";echo preg_replace($pattern, $replacement, $string);echo \"-------------\";$pattern ='/&lt;img src=\"(.*)\\/(.+\\\\..+)\"&gt;+?/'; // +?结果与上面的不一样echo preg_replace($pattern, $replacement, $string2);echo \"-------------\";// 找出所有的图片，图片名$pattern =\"/&lt;img src=\\\"(.*)\\/(.+\\\\..+)\\\"&gt;/U\";preg_match_all($pattern, $string, $images);print_r($images);// 输出图片名foreach ($images[2] as $index =&gt; $imageName) &#123; echo \"$imageName&lt;br/&gt;\";&#125;?&gt; 字符串和timestamp的转换 Date Document12345678&lt;?phpecho (strtotime(\"2010-10-28 10:52:21\")); // MySQL格式的字符串转换成秒数echo \"&lt;br/&gt;\";echo (strtotime(\"2010-10-01 00:00:00\"));echo \"&lt;br/&gt;\";$d = date(\"Y-m-d H:i:s\", time()); // 秒数转换成MySQL格式的timestampecho $d;?&gt; 访问 MySQL12345678910111213141516171819202122&lt;?php// 插入数据到数据库中, 数据库操作语句都是使用mysql_querymysql_connect(\"localhost\", \"root\", \"root\"); // 连接到数据库: url, username, passwordmysql_select_db(\"qt\"); // 选择使用数据库中的表$result = mysql_query(\"SELECT username, password FROM user\");while ($row = mysql_fetch_array($result)) &#123; // 每使用一次后，会自动移向下一个游标 // username 和 password 是数据库中列名 echo $row[\"username\"], \", \", $row[\"password\"], \"&lt;br&gt;\";&#125;?&gt;&lt;?php$username = \"Blabla\";$password = date(\"H:i:s\");// 插入数据mysql_query(\"INSERT INTO USER (username, password) VALUES ('$username', '$password')\");// Close MySQL connectionmysql_close();?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://aotle.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://aotle.github.io/tags/PHP/"}]},{"title":"数据结构--线性表","slug":"数据结构-线性表","date":"2020-06-29T13:13:25.000Z","updated":"2020-08-13T06:37:58.287Z","comments":true,"path":"2020/06/29/数据结构-线性表/","link":"","permalink":"https://aotle.github.io/2020/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"数据结构之线性表","text":"数据结构之线性表 概念线性表是数据结构中最简单的数据存储结构，可以理解为“线性的表”。 线性，是说数据在逻辑结构上具有线性关系。将具有线性关系的数据存储到计算机中所使用的存储结构称为线性表。 首先是一个序列 其次是有限的 存储的数据本身的类型一定保持相同。 线性表的开始元素没有前驱元素只有后继元素，线性表的结束元素没有后继元素只有前驱元素，除了开头元素和结尾元素以外，每个元素都有且只有一个前驱元素和后继元素。 数据一旦用线性表存储，各个数据元素之间的相对位置就固定了。 存储结构线性表的存储结构有顺序存储结构和链式存储结构两种，前者称为顺序表，后者称为链表。 顺序存储结构顺序表就是把线性表中的所有元素按照某种逻辑顺序，依次存储到从指定位置开始的一块连续的存储空间，重点是连续的存储空间。 数组长度和线性表的长度区别：数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的，线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。 在顺序表中，各个表项的逻辑顺序与其存放的物理顺序一致，即第i个表项存储于第i个物理位置（1&lt;i≤n）。 对顺序表中所有表项，既可以进行顺序访问，也可以进行随机访问。也就是说，既可以从表的第一个表项开始逐个访问表项，也可以按照表项的序号（亦称为下标）直接访问表项。 顺序表的静态存储表示：123456#define maxSize 100typedef int T;typedef struct&#123;T data[maxSize];int n;&#125;SeqList; 顺序表的动态存储表示：12345typedef int T;typedef struct&#123;T* data;int maxSize，n;&#125;SeqList; 顺序表搜索算法：123456789template &lt;class T&gt;int Seqlist&lt;T&gt;::search(T&amp; x)&#123;//搜索函数，在表中找到x，找到则返回元素位置，否则返回0//last表示最后一个元素的数组标号，从0开始，表项是从1开始 for(int i=0;i&lt;=last;++i)&#123; if(data[i]==x) return i+1; &#125; return 0;&#125; 顺序表插入算法：123456789101112template &lt;class T&gt;bool Seqlist&lt;T&gt;::insert(int i,T&amp; x)&#123;//将新元素插入到表第i个元素之后，函数返回true，否则返回false if(last==maxsize-1)return false; if(i&lt;0||i&gt;last+1)return false; for(int j=last;j&gt;=i;j--)&#123; data[j+1]=data[j]; &#125; data[i]=x; last++; return true;&#125; 顺序表删除算法：123456789101112template &lt;class T&gt;bool Seqlist&lt;T&gt;::remove(int i,T&amp; x)&#123;//删除第i个表项，通过x返回删除的元素值，成功返回true if(last==-1)return false; if(i&lt;1||i&gt;last+1)return false; x=data[i-1]; for(int j=i;j&lt;=last;j++)&#123; data[j-1]=data[j]; &#125; last--; return true;&#125; 链式存储结构链表，别名链式存储结构或单链表，用于存储逻辑关系为 “一对一” 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的，这就意味着这些数据元素可以存在内存未被占用的任意位置。还有一点就是在顺序存储结构中，每个数据空间只需要存储数据元素的信息即可，但是在链式结构中，除了要存储数据元素信息外，还需要存储他的后继元素的存储位置。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域，指针域中存储的信息称为指针或链，数据域和指针域组成数据元素的存储映像，称为结点。 单链表单链表的定义123456789struct linknode&#123; int data; linknode* link;&#125;;class list&#123; private: linknode* first; public:&#125;; 单链表的查找算法12345678910template &lt;class T&gt;linknode&lt;T&gt;* list&lt;T&gt;::search(T X)&#123; //成功的时候返回地址，否则返回null linknode&lt;T&gt;* current = first-&gt;link;//带附加头结点 while(current!=null)&#123; if(current-&gt;data==x)break; else current=current-&gt;link; &#125; return current;&#125; 单链表的插入算法1234567891011template &lt;class T&gt;bool list&lt;T&gt;::inscrt(int i,T&amp; X)&#123; //将新元素插入i结点之后 linknode&lt;T&gt; *current = locate(i);//return i address if(current==null)return false; linknode&lt;T&gt; *newnode = new linknode&lt;T&gt;(x); if(newnode==null)&#123;cerr&lt;&lt;\"error\"&lt;&lt;endl;exit(1)&#125; newnnode-&gt;link=current-&gt;link; current-&gt;link=newnode; return true;&#125; 单链表的删除算法1234567891011template &lt;class T&gt;bool list&lt;T&gt;::remove(int i,T&amp; X)&#123; //将第i个元素删除，x返回被删除的值 linknode&lt;T&gt; *current = locate(i-1);//return i-1 address if(current==null||current-&gt;link==null)return false; linknode&lt;T&gt; *del = current-&gt;link; x=del-&gt;data; current-&gt;link=del-&gt;link; delete del; return true;&#125; 循环链表循环链表（circular list）是另一种形式的表示线性表的链表，它的结点结构与单链表相同，与单链表不同的是链表中表尾结点的link域中不是NULL，而是存放了一个指向链表开始结点的指针。这样，只要知道表中任何一个结点的地址，就能遍历表中其他任一结点。 双向链表双向链表又称为双链表。使用双向链表（doubly linked list）的目的是为了解决在链表中访问直接前驱和直接后继的问题。因为在双向链表中每个结点都有两个链指针，一个指向结点的直接前驱，一个指向结点的直接后继，这样不论是向前驱方向搜索还是向后继方向搜索，其时间开销都只有O(1)。 静态链表如果为数组中每一个元素附加一个链接指针，就形成静态链表结构。它允许我们不改变各元素的物理位置，只要重新链接就能够改变这些元素的逻辑顺序。由于它是利用数组定义的，在整个运算过程中存储空间的大小不会变化，因此称之为静态链表。静态链表的每个结点由两个数据成员构成：data域存储数据，link域存放链接指针。所有结点形成一个结点数组。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://aotle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://aotle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表","slug":"线性表","permalink":"https://aotle.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"常用汇编指令整理","slug":"常用汇编指令整理","date":"2020-06-25T15:12:52.000Z","updated":"2020-08-13T06:36:14.641Z","comments":true,"path":"2020/06/25/常用汇编指令整理/","link":"","permalink":"https://aotle.github.io/2020/06/25/%E5%B8%B8%E7%94%A8%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/","excerpt":"这是一些常用汇编指令的整理。","text":"这是一些常用汇编指令的整理。 数据传送指令通用数据传送指令MOV 格式：MOV dst,src 功能：将src传送到dst 限制：段寄存器间不可直接相互传送，立即数不能直接送段寄存器，CS 不可作为目的操作数。 PUSH &amp; POP 格式：PUSH src &amp; POP dst 功能：将 src 压栈 &amp; 出栈送入 dst 限制：CS 不可作目的操作数 XCHG 格式：XCHG dst,src 含义：交换两个操作数内容（Exchange） 限制：段寄存器不可为操作数，也不能同时为存储单元，两个操作数也不能同时为内存变量。 XLAT 格式：XLAT 含义：转换表（Table Look-up Translation） 功能：把待查表格（表格位于 DS:BX）的一个字节内容送到AL累加器中。在执行该指令前，应将TABLE首地址送至BX寄存器中，然后将待查字节与其在表格中距表首地址位移量送AL,即AL&lt;–((BX)+(AL)). 地址目标传送指令LEA 格式：LEA dst,src 含义：把地址偏移量传送目的操作数（Load Effective Address） 功能：取src地址偏移量送dst 注：源操作数必须是存储单元，目的操作数必须是除段寄存器之外的 16 位寄存器。 LDS &amp; LES 格式：LDS dst,src &amp; LES dst,src 含义：取双字指针送到目的寄存器和 DS/ES 功能：从源操作数指定的存储单元中取出 4 字节，前两个字节送到目的寄存器，后两个字节送到 DS/ES。 标志传送指令PUSHF &amp; POPF 格式：PUSHF &amp; POPF 含义：将标志寄存器压栈/出栈 功能：PUSHF：执行操作: SP=SP-1,(SP)=PSW的高8位, SP=SP-1, (SP)=PSW的低8位，POPF相反。 LAHF &amp; SAHF 格式：LAHF &amp; SAHF 含义：Load(Store) AH from(into) Flags 功能：将标志寄存器低字节送到 AH &amp; 将 AH 送到标志寄存器低字节 输入输出指令IN &amp; OUT 格式：IN AL/AX, ADDR &amp; OUT ADDR, AL/AX 功能：从端口地址（寄存器）获取数据送到寄存器（端口地址） 地址格式：端口地址有两种格式，小于 FFH 时可以是直接写出，否则必须先送入 DX 再使用。 算术运算指令加减法指令ADD &amp; ADC 格式：ADD dst,src &amp; ADC dst,src 含义：（带进位）加法 功能：dst = src + dst (+ CF) INC 格式：INC dst 功能：自增 1，dst = dst + 1 SUB &amp; SBB: 格式：SUB dst,src &amp; SBB dst,src 含义：（带借位）减法 功能：dst = dst - src (- CF) DEC: 格式：DEC dst 功能：自减 1，dst = dst + 1 NEG: 格式：NEG dst 功能：对目的操作数取负，dst = -dst 乘除法指令MUL &amp; IMUL 格式：IMUL src &amp; MUL src 含义：无符号数/整数乘法 功能：只有一个源操作数，当其为 8 位时，AX = AL * src，为 16 位时，（DX,AX）= AX * src DIV &amp; IDIV 格式：IDIV src &amp; DIV src 含义：无符号数/整数乘法 功能：只有一个源操作数作为除数，当其为 8 位时，AX 为被除数，AL 作为商，AH 作为余数。当 src 为 16 位时，（DX,AX）作为被除数，AX 作为商，DX 作为余数。 逻辑运算与移位指令逻辑运算 指令 功能 NOT dst 取反，逻辑非 AND dst,src 逻辑与 OR dst,src 逻辑或 XOR dst,src 异或 算术逻辑移位 指令 含义 功能 SAL dst,cnt Shift Arithmetic Left 算术左移 cnt 位 SAR dst,cnt Shift Arithmetic Right 算术右移 cnt 位 SHL dst,cnt Shift Logic Left 逻辑左移 cnt 位 SHR dst,cnt Shift Logic Right 逻辑右移 cnt 位 cnt 为 1 或者 CL。算术右移时补最高位，逻辑右移补 0，被移出的移入 CF。 循环移位 指令 含义 功能 ROL dst,cnt Rotate Left 循环左移 cnt 位 ROR dst,cnt Rotate Right 循环右移 cnt 位 RCL dst,cnt Rotate through Carry Left 带进位左移 cnt 位 RCR dst,cnt Rotate through Carry Right 带进位右移 cnt 位 字符串操作指令 指令（字节/字） 功能 MOVSB / MOVSW 字符串传送 CMPSB / CMPSW 字符串比较 SCASB / SCASW 字符串扫描 LODSB / LODSW 字符串装入 STOSB / STOSW 字符串存储 对于后三条指令，操作使用 AL/AX 寄存器（根据操作数类型决定）。 源串起始地址为 DS:SI，目的串位于 ES:DI 每一次操作都会自动修改 SI 和 DI DF 标志位可以控制字符串处理方向，DF = 0 递增，DF = 1 递减，可通过 CLD/STD 设置 处理字符串长度放在 CX 中 这些指令前可以用重复前缀 REP 反复执行，或是 REPE/REPZ 相等/为零则重复，REPNE/REPNZ 不相等/非零则重复。 处理器控制指令标志处理指令 指令 含义 功能 CLC Clear Carry CF = 0 CMC Complement Carry CF = NOT CF STC Set Carry CF = 1 CLD Clear Direction DF = 0 STD Set Direction DF = 1 CLI Clear Interrupt IF = 0 STI Set Interrupt IF = 1 外部同步指令ESC 格式：ESC 外部操作码，src 功能：用来实现对 8087 协处理器控制。 WAIT 格式：WAIT 功能：往往跟在 ESC 后等待，直到 TEST 为低电平。 LOCK 格式：LOCK 功能：封锁总线，禁止其他处理器使用总线。 停机和空操作HLT 格式：HLT 功能：进入暂停状态不进行任何操作，直到复位或 NMI 引脚/INTR 引脚出现中断请求信号。 NOP 格式：NOP 功能：耗费三个时钟周期但不进行任何操作。 控制转移指令比较指令CMP 格式：CMP dst,src 功能：用 dst 减去 src，但结果仅反映到标志位，不送回目的操作数。 常见用法：后跟JZ（相等跳转） &amp; JNZ （不相等跳转）。 TEST 格式：TEST dst,src 功能：对两个操作数作逻辑与，结果仅反映到标志位，不送回目的操作数。 常见用法：测试某一位，为 1JNZ跳转，为 0 JZ跳转。 无条件转移JMP 格式：JMP dst 功能：无条件跳转到目的地址。 跳转分为两种，一种是段内转移或近（NEAR）转移，跳转时仅改变 IP 的值，另一种是段间转移或远（FAR）转移，此时跳转长度超过 IP 最大值，CS 和 IP 都要改变。这两种情况都提供直接转移和间接转移两种方法，前者直接给出目的地址，后者将目的地址放在寄存器或者存储单元中。 类型 方式 寻址目标 举例 段内 直接 立即短转移（8位） JMP SHORT 标号 段内 直接 立即近转移（16位） JMP NEAR PTR 标号或JMP 标号 段内 间接 寄存器（16位） JMP BX 段内 间接 存储器（16位） JMP WORD PTR 5[BX] 段间 直接 立即转移（32位） JMP FAR PTR 标号 段间 间接 存储器（32位） JMP DWORD PTR[REG] CALL 格式：CALL 过程名 功能：调用过程。 同样有段内与段间，直接与间接的区分，指令格式与 JMP 类似。 类型 方式 寻址目标 举例 段内 直接 立即调用 CALL 标号 段内 间接 寄存器（16位） CALL BX 段内 间接 存储器（16位） CALL WORD PTR 5[BX] 段间 直接 立即调用（32位） CALL FAR PTR 标号 段间 间接 存储器（32位） CALL DWORD PTR[REG] RET 格式：RET (n) 功能：过程返回。如果有 n 则在弹出返回地址后再弹出 n 个字节，这一目的是让调用过程可以传递参数。 条件转移 格式：操作符 标号 功能：根据操作符，满足即跳转到标号。 直接标志转移 指令 测试条件 判断条件 JC/JNC CF = 1 / 0 有 / 无进位 JZ/JNZ ZF = 1 / 0 相等 / 不相等 JE/JNE ZF = 1 / 0 相等 / 不相等 JS/JNS SF = 1 / 0 符号为负 / 正 JO/JNO OF = 1 / 0 溢出 / 无溢出 JP/JNP PF = 1 / 0 为偶数 / 奇数 JPE/JPO PF = 1 / 0 为偶数 / 奇数 无符号数比较测试 指令 测试条件 判断条件 JA/JNBE CF ∨∨ ZF = 0 高于 / 不低于等于 JAE/JNB CF = 0 高于等于 / 不低于 JNAE/JB CF = 1 不高于等于 / 低于 JNA/JBE CF ∨∨ ZF = 1 不高于 / 低于等于 有符号数比较测试 指令 测试条件 判断条件 JG/JNLE (SF XORXOR OF) ∨∨ ZF = 0 大于 / 不小于等于 JGE/JNL SF XORXOR OF = 0 大于等于 / 不小于 JNGE/JL SF XORXOR OF = 1 不大于等于 / 小于 JNG/JLE (SF XORXOR OF) ∨∨ ZF = 1 不大于 / 小于等于 循环控制指令LOOP 格式：LOOP 标号 功能：跳至标号继续循环，每执行一次 CX 减一，若减一后为零则不跳转。 LOOPE &amp; LOOPNE 格式：LOOPE 标号 &amp; LOOPNE 标号 功能：（不）相等时循环，其他与 LOOP 相同。 LOOPZ &amp; LOOPNZ 格式：LOOPZ 标号 &amp; LOOPNZ 标号 功能：结果（不）为零时循环，其他与 LOOP 相同。 JCXZ 格式：JCXZ 标号 功能：CX 为零则跳转，否则就往下执行， CS 不会减一。 中断指令INT 格式：INT n 功能：调用 n 对应的功能。 INTO 格式：INTO 功能：如果溢出标识 OF 为 1 则产生类型为 4 的中断，否则就继续向下执行。 IRET 格式：IRET 功能：中断返回。 BIOS &amp; DOS 调用调用这两者用的是 INT 中断指令。 格式：INT n 功能：调用 n 对应的功能。 其中 n = 21H 是最为强大的 DOS 中断。一般调用中断须先将参数放入指定寄存器，功能号放入 AH，子功能号放入 AL，例如 12MOV AX,4C00H INT 21H 常用的功能号有 功能号 功能 参数 01H 输入一个字符 AL = 输入字符 0AH 输入字符串 DX:DX = 缓冲区首地址 02H 显示一个字符 DL = 显示字符 09H 显示 $ 结尾的字符串 DX:DX = 字符串首地址 常用伪指令数值回送操作符TYPE 格式：TYPE expression_r(or label) 功能：返回变量以字节数表示的类型 &amp; 返回标号类型的数值 LENGTH 格式：TYPE variable 功能：对于变量使用DUP的情况,将回送分配给该变量的单元数; 对其它情况则回送1 SIZE 格式：TYPE variable 功能：回送分配给该变量的字节数 = TYPE * LENGTH OFFSET 格式：TYPE variable (or lable) 功能：回送变量或标号的偏移地址 SEG 格式：TYPE variable (or lable) 功能：回送变量或标号的段地址 数据定义语句 DB 定义字节,表示其后每个操作数占有一个字节(1Byte)单元 DW 定义字,表示表示其后每个操作数占有一个字(2Byte)单元 123data_byte DB 10 , 4 , 10H , ? ;共定义了4个字节,其中 &#39;?&#39; 是保留单元data_word DW 100 DUP(?) ;定义100个字的存储空间","categories":[{"name":"汇编","slug":"汇编","permalink":"https://aotle.github.io/categories/%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://aotle.github.io/tags/8086%E6%B1%87%E7%BC%96/"},{"name":"考试","slug":"考试","permalink":"https://aotle.github.io/tags/%E8%80%83%E8%AF%95/"}]},{"title":"短句分享","slug":"短句分享","date":"2020-06-23T06:26:06.000Z","updated":"2020-08-13T06:37:11.673Z","comments":true,"path":"2020/06/23/短句分享/","link":"","permalink":"https://aotle.github.io/2020/06/23/%E7%9F%AD%E5%8F%A5%E5%88%86%E4%BA%AB/","excerpt":"摘抄了一些很美的短句","text":"摘抄了一些很美的短句 1/ 四月，应该坦坦荡荡，鸽子从屋檐拥向晴空，青藤从粉墙探向枝头，新茶从瓷碗吻向老桌，传说从故纸堆里挣脱，你带着苍绿的情书，生锈的戒指，以及喑哑的晚钟，风尘仆仆 ，从远方，奔向我 ，趁风月无边，浮了这盅千里烟波，从此隐入山中，陪你赏朝昏夕落。 2/ 你是一台磨人的机器 盛产爱和诗意 3/ 我喜欢的少年打天上来 他无意掀翻烛火 点燃我双眸盛满的暮色 4/ ᴹᵉᵉᵗ ʸᵒᵘ ᶠᵘˡˡ ᵒᶠ ˡᵒᵛᵉ / ˢᵉᵉ ᵉᵛᵉʳʸᵗʰⁱⁿᵍ ⁱⁿ ᵗʰᵉ ʷᵒʳˡᵈ / ᶠᵃˡˡ ⁱⁿ ˡᵒᵛᵉ ʷⁱᵗʰ ʸᵒᵘ. 遇见你爱意汹涌，看世间万物，都浪漫心动。 5/ 山野千里，你是我藏在星星里的浪漫，无尽的温柔与风情都隐匿在皎月清辉中，今晚月色极美，我双手为你奉上 6/ 纯洁无暇的善良不够善良。 遭遇过一切挫折与人性考验后的善良温柔有力量。 7/ 很喜欢「日暮里」和「次日清晨」这两个词。一天的喜怒哀乐都溜进日暮里，在次日清晨给人以重新开始的无限可能。 疲倦落入温柔暮色里，我会在次日清晨醒着眼睛。 8/ あなたの优しさに私は心を引かれた 你的温柔打动了我的心 9/ 我是如此单独而完整 在无数个夜晚我独自顶着冷风 伫立在老橘树下的桥头 只为听一曲夜莺的哀歌 我倚暖了石栏上的青苔 青苔凉透了我的心坎 但夜莺不来夜莺不来 ——徐志摩 《我是如此单独而完整》 10/ 千般荒凉，以此为梦。万里蹀躞，以此为归。 ——余秋雨 11/ 太阳未出时，全世界都做一个梦，唯有月亮是真实的； 太阳出来后，全世界都真实了，唯有月亮像一个梦。 ——《冬牧场》 12/ ᵂᵃⁿᵗ ᵗᵒ ᵇᵉ ʸᵒᵘʳ / ᵖⁱˡˡᵒʷ ᵇᵒᵒᵏ / ᶜᵃᵗ ⁱⁿ ʸᵒᵘʳ ᵃʳᵐˢ / ˡᵒᵛᵉᵈ ᵒⁿᵉ. 想做你的枕边书，怀中猫，意中人。 13/ 你踩着漫长星辰的光而来，而我在你到来的刹那便失了心智，从此山河过往，凛冬天明，你都有我。 14/ 树在 山在 大地在 岁月在 我在 你还要怎样更好的世界? ——张晓风《我在》 15/ ᴱˣᵖᵉʳⁱᵉⁿᶜⁱⁿᵍ ᵃ ᵖᵉʳˢᵒⁿ’ˢ ˡᵒⁿᵉˡⁱⁿᵉˢˢ, ᵇᵘᵗ ᵃˡˢᵒ ᵉˣᵖᵉʳⁱᵉⁿᶜⁱⁿᵍ ᵗʰᵉ ᵍⁱᶠᵗ ᵒᶠ ˡᵒⁿᵉˡⁱⁿᵉˢˢ. 经历着一个人的孤独，也经历着孤独的馈赠。 16/ 我是个俗气至顶的人， 见山是山，见海是海，见花便是花。 唯独见了你， 云海开始翻涌，江潮开始澎湃， 昆虫的小触须挠着全世界的痒。 你无需开口，我和天地万物便通通奔向你。 17/ 余光中先生说，月色与雪色之间，你是第三种绝色，于我而言,日月星辉之中,你是第四种难得。 18/ 昼も夜も春も渡らず，夜も眠れない星 白日春不渡，黑夜万梦星。 19/ 我是半坏街灯 是将冷煤炭 闪闪烁烁 明明暗暗 只想把有限的光和热 全都给你。 20/ 我怀念那个秋天，但我不会因此止步不前我会把有关你的记忆隐于心弦，当然不包括那偶尔泄出的一些思念。 21/ ᵀʰᵉ ᵍʳᵉᵃᵗᵉˢᵗ ʳᵒᵐᵃⁿᶜᵉ ⁱˢ ᵗʰᵉ ᶠᵒᶜᵘˢ ᵒᶠ ᵒⁿᵉ’ˢ ˡⁱᶠᵉ. 最盛大的浪漫是终其一生的专注。 22/ 我希望有个如你一般的人 如山间清爽的风如古城温暖的光，从清晨到夜晚，由山野到书房，不怕路途遥远，只要最后是你就好。 23/ 我想和你一起生活 在某个小镇 共享无尽的黄昏 和绵绵不绝的钟声 ——茨 维塔耶娃 24/ ᴵ ʰᵃᵛᵉ ˢᵃᵛᵉᵈ ᵗᵉⁿᵈᵉʳⁿᵉˢˢ ᵃⁿᵈ ʳᵒᵐᵃⁿᶜᵉ ᶠᵒʳ ᵃ ˡᵒⁿᵍ ᵗⁱᵐᵉ. ᴵ ʷᵃⁿᵗ ᵗᵒ ᵍⁱᵛᵉ ⁱᵗ ᵗᵒ ʸᵒᵘ ᵃˡˡ ᵃᵗ ᵒⁿᶜᵉ. 攒了好久的温柔与浪漫，想要一次性都给你。 25/ 岁月极美，在于它必然的流逝。 春花、秋月、夏日、冬雪。 26/ 今夜（こんや）は月（つき）が綺麗（きれい）ですね。 今晚月色真美。 27/ 世人慌慌张张，不过是图碎银几两。偏偏这碎银几两，能解世间惆怅，可让父母安康，可护幼子成长，但这碎银几两，也断了儿时的念想，让少年染上沧桑，压弯了脊梁。 28/ 我是春天里出生的绿皮野兽 在秋夜里吞下十瓣月亮 ——《桔子》高鹤鸣 29/ 夏天属于散文和柠檬，属于裸露和慵懒，属于关于回归的想像的永恒闲置，属于稀见的长笛和赤裸的双足，还有八月的卧室卧室中绞结的床单和周日的盐 ——德里克·沃尔科特《夏天的布里克街》 30/ 读书到某个相似段落的恍神，在外喝冷饮唤起味觉的苏醒，抑或是整理旧衣物时不落痕迹的叹息。这些由你衍生出来的琐碎，在数年如一日的白夜里，融汇成轻柔而遥远的光河。不再触及我。却依然照耀我。 31/ 最短暂的幸福感和最漫长的余韵，在到达最顶峰的时候迫近死亡，每个人的生命中都有一段summer time。 32/ 你已穿上书页般的衣冠 步行在恭敬的瓶形尸首间 ——张枣《十月之水》 33/ 谁端着夜的筛子将一粒粒光豆豆不停地筛了出来——《星空》 34/ 我是馊掉的柳丁汁和浓汤，我是爬满虫卵的玫瑰和百合，我是灯火流离的都市里明明存在却没人看得到也没人需要的北极星。 ——林奕含《房思琪的初恋乐园》 35/ 夕阳染病像潦倒的诗人醉落西湖——《夕阳西下》周末有约 36/ 阳光退出院子，退得那么慢，其间还有多次停顿，如同一种哽咽。 ——余秀华《月光落在左手上》 37/ 掉头一去是风吹黑发，回首再来已雪满白头。 下次你路过，人间已无我。 ——余光中《欢呼哈雷》 38/ 他来时风尘仆仆，停时依旧是光。 ——高台树色《白日事故》","categories":[{"name":"摘抄","slug":"摘抄","permalink":"https://aotle.github.io/categories/%E6%91%98%E6%8A%84/"}],"tags":[{"name":"短句","slug":"短句","permalink":"https://aotle.github.io/tags/%E7%9F%AD%E5%8F%A5/"}]},{"title":"夏天的风","slug":"blog-迁移","date":"2020-06-21T04:33:42.000Z","updated":"2020-08-13T06:34:59.686Z","comments":true,"path":"2020/06/21/blog-迁移/","link":"","permalink":"https://aotle.github.io/2020/06/21/blog-%E8%BF%81%E7%A7%BB/","excerpt":"“在夏天，我们吃绿豆、桃、樱桃和甜瓜。在各种意义上都漫长且愉快，日子发出声响。” ​ ——罗伯特·瓦尔泽《夏天》","text":"“在夏天，我们吃绿豆、桃、樱桃和甜瓜。在各种意义上都漫长且愉快，日子发出声响。” ​ ——罗伯特·瓦尔泽《夏天》 喜欢夏天，大概是因为夏日有一种特别的感觉吧。 夏天和雨天一样，有一种特别的韵味。夏天也很有故事感，记忆中好多事都是发生在夏天。夏天也有童年，青春的味道。 尤其是夏日的午后，蝉声鸣叫，很多人在午睡，全世界就好像安静了下来，只剩自然的声音。 时光流逝得很慢，蓝蓝的天空，强烈的阳光，喜欢的人。是我爱得无法自拔的夏日～ 印象最深的仍然是那个起风了的夏天，当时的冰淇淋很冰也很甜。 暗晚风吹起你鬓间的发，抚平回忆留下的疤，你的眼中明交杂，一笑生花。当时是18年的夏天，也是高中毕业的那个夏天。有很复杂的感情，怀念那时的同学，怀念高三的教室，怀念当初那个懵懂无知的自己，怀念着我的青春。 我们回忆18年的夏天，不是回忆某一年的夏天，每个夏天都不一样，每个人青春的基调却是一样的，有着遗憾，仓促，惋惜 在这之中，我们变成为现在的自己 不一定说是我们一定变好了，只是，我们终究长大了 我们怀念的夏天，只属于我们这一代人 每一代人的青春都只属于自己 就像我曾经深爱的你 后悔吗？ 不知道 太多太多理由让我喜欢这个季节了 湛蓝湛蓝的天空，饱满饱满的云朵，树林阴影里穿过凉风，白杨树浓密的叶子簌簌作响，一望无际的田野带着幽香，浓烈的太阳晒得人直发昏，汽车飞驰而过会卷起街道上的尘土，深井里有清冽的凉水，地窖里有甘甜的西瓜，阴凉土房里有的舒服过堂风，漫长的午觉伴着声嘶力竭的蝉鸣。 学校里还有开了的合欢树，有月季花田，有玉簪，有大湖，外面的小南门里有炸鸡，有热干面，有寿司，有炸串，有麻辣烫，有西瓜。 在学校，每次下晚课回去的路上很热闹，有情侣争吵，也有热情调笑，他们走在一起，就像青春飘荡在夏风中 去年夏天我一个人走了很多没走过的路，也遇见和失去了喜欢的人 我看见了烟波画船，云霞翠轩感受到了朝飞暮卷，雨丝风片 晚上有时会在小区里溜达，好天气的夜空中能看见浓烈的流云，云片被夜风吹的翻飞。有时也能看见星星。有时也经常和朋友一起去烧烤，坐在露天烧烤摊，吃很多牛板筋，烤土豆，豆角，金针菇，喝下大杯的啤酒，满桌子的小龙虾残骸还有蛤蜊壳。 夕阳在楼区间若隐若现，晚霞也都被分割成一条一条。 绿槐高柳咽新蝉，薰风初入弦。碧纱窗下水沉烟，棋声惊昼眠。微雨过，小荷翻，榴花开欲然。玉盆纤手弄清泉，琼珠碎却圆。·我喜欢夏日的永昼，我喜欢在多风的黄昏独坐在傍山的阳台上。小山谷里稻浪推涌，美好的稻香翻腾着。慢慢地，绚丽的云霞被浣净了，柔和的晚星一一就位。——张晓风《我喜欢》 微风拂过海面，蝉鸣漾入云间。叽叽喳喳的笑声在沙滩上留下深浅不一的足迹，盛暑阳光夺神炫目，模糊了远近的归船。 我希望今年的夏天还能走很多很多的路，吃很多烧烤，西瓜和冰棍。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://aotle.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://aotle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"PHP","slug":"PHP","permalink":"https://aotle.github.io/categories/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://aotle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"汇编","slug":"汇编","permalink":"https://aotle.github.io/categories/%E6%B1%87%E7%BC%96/"},{"name":"摘抄","slug":"摘抄","permalink":"https://aotle.github.io/categories/%E6%91%98%E6%8A%84/"},{"name":"随笔","slug":"随笔","permalink":"https://aotle.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://aotle.github.io/tags/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://aotle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表","slug":"线性表","permalink":"https://aotle.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"8086汇编","slug":"8086汇编","permalink":"https://aotle.github.io/tags/8086%E6%B1%87%E7%BC%96/"},{"name":"考试","slug":"考试","permalink":"https://aotle.github.io/tags/%E8%80%83%E8%AF%95/"},{"name":"短句","slug":"短句","permalink":"https://aotle.github.io/tags/%E7%9F%AD%E5%8F%A5/"},{"name":"笔记","slug":"笔记","permalink":"https://aotle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}