<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>Perl快速入门 - Aotle</title>
  
    <meta name="keywords" content="perl">
  
  
    <meta name="description" content="
转载自：https://qntm.org/perl
">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<!-- 样式二（飘动的彩带） -->
<script src="https://g.joyinshare.com/hc/piao.js" type="text/javascript"></script>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<body>
	<!--浏览器搞笑标题-->
  <script type="text/javascript" src="/js/FunnyTitle.js"></script>
  
  <div class="cover-wrapper">
    
      <cover class='cover post half'>
        <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">Aotle</p>
    
    
      <p class="subtitle">你所看到的惊鸿，都曾被平庸磨练</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="" />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <ul class='cover-list-h'>
        
          
            <li>
              <a class="nav home"
                href="/"
                
                
                id="home">
                <i class='fas fa-rss fa-fw'></i>博客
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/categories/"
                
                
                id="categories">
                <i class='fas fa-folder-open fa-fw'></i>分类
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/tags/"
                
                
                id="tags">
                <i class='fas fa-tags fa-fw'></i>标签
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/archives/"
                
                
                id="archives">
                <i class='fas fa-archive fa-fw'></i>归档
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/friends/"
                
                
                id="friends">
                <i class='fas fa-link fa-fw'></i>友链
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/about/"
                
                
                id="about">
                <i class='fas fa-info-circle fa-fw'></i>关于
              </a>
            </li>
          
        
      </ul>
    </div>
  </div>
</div>

      </cover>
    
    <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            Aotle
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/12/07/perl_low/">
      Perl快速入门
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://aotle.github.io" target="_blank" rel="nofollow noopener">
    <img src="https://aotle.oss-cn-beijing.aliyuncs.com/QQ图片20201201191142.jpg">
    <p>F.A</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/perl/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>perl</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Dec 7, 2020</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <blockquote>
<p>转载自：<a href="https://qntm.org/perl" target="_blank" rel="noopener">https://qntm.org/perl</a></p>
</blockquote>
<a id="more"></a>

<p><a href="https://qntm.org/" target="_blank" rel="noopener">Things Of Interest </a><a href="https://qntm.org/src" target="_blank" rel="noopener">Code </a><a href="https://qntm.org/perl" target="_blank" rel="noopener">Learn Perl in about 2 hours 30 minutes </a></p>
<p>Perl是一门动态的、动态类型的高阶脚本（解释型）语言，常常与PHP和Python相提并论。Perl的语法借鉴了许多古老的Shell脚本，并且因为过度使用难懂的符号而声名狼藉，这使得人们几乎无法从Google搜索到想要的语法知识。Perl作为一门脚本语言非常适合用作<em>胶水语言</em>，将其他脚本和程序连接到一起。Perl非常擅长处理和生成文本数据，同时也具有高度可移植性和良好的社区支持，使其成为一门应用广泛的脚本语言。Perl的设计哲学是“每个问题都有不止一种解决方法”（TMTOWTDI），而Python的设计哲学“每个问题最好只有唯一一个显而易见的解决方法”与之截然相反。</p>
<p>Perl有时令人厌恶，不过也有一些很棒的语言特性，就这一点上，Perl和其他编程语言是一样的。</p>
<p>这篇文章旨在提供知识，而不是为Perl做宣传，目标人群是（比如我自己）：</p>
<ul>
<li>不喜欢Perl的官方文档（<a href="http://perl.org/），因为太过于学术性，并且花费太多的版面来讲述一些一辈子用不到的边缘问题" target="_blank" rel="noopener">http://perl.org/），因为太过于学术性，并且花费太多的版面来讲述一些一辈子用不到的边缘问题</a></li>
<li>通过一些通用约定和示例程序能够快速学习编程语言</li>
<li>希望拉里·沃尔能够长话短说（译者注：拉里·沃尔是Perl语言的设计者）</li>
<li>已经知道怎么编程</li>
<li>除非对工作有用，否则不关心Perl的任何其他细节。</li>
</ul>
<p>这篇文档会尽可能精简，而包含的每条信息都是必要的。</p>
<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul>
<li>文章中几乎所有的陈述语句几乎都是“严格说来不完全是真的，现实情况要复杂得多”，如果你看到一个严重的错误，请指出来，不过我保留不修正“善意的谎言”的权利。</li>
<li>在这片文章里我用<code>print</code>语句来输出数据，但是并不一定追加了换行或者空格，以免我因为过分注意输出样式而发疯。许多示例程序如果真的运行出来，现实结果可能像是“alotofwordsallsmusheduptogetherononeline”，但是，不要在意这些细节。</li>
</ul>
<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>Perl<em>脚本</em>是带有<code>.pl</code>后缀的文本文件。</p>
<p>下面是<code>helloworld.pl</code>的全部内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print &quot;Hello world&quot;;</span><br></pre></td></tr></table></figure>

<p>Perl脚本由Perl解释器解释执行，<code>perl</code>或者<code>perl.exe</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl helloworld.pl [arg0 [arg1 [arg2 ...]]]</span><br></pre></td></tr></table></figure>

<p>有几点要特别提一下：Perl的语法非常宽容，它允许你写出有歧义的或者有不可预期行为的代码。我不会去解释这些诡异的行为是什么样的，因为你最好避开它们。避免这种情况的方法是在你写的每个Perl脚本或者模块的开头加上<code>use strict; use warnings;</code>。<code>use foo;</code>这种语句叫做<em>编译指示（pragmas）</em>，编译指示是给<code>perl.exe</code>的一个提示，在程序开始执行之前的语法验证阶段会发挥作用，脚本语句实际执行的时候这些编译指示对于运行结果没有影响。</p>
<p>分号<code>;</code>是语句结束的标志，井号<code>#</code>表示注释的开始，注释直到这行的结尾结束。Perl没有块注释的语法。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Perl的变量有三种类型：<em>标量（scalar）</em>、<em>数组（array）</em>和<em>哈希（hashes）</em>（译者注：下文会继续使用英文原文scalar、array和hash），每种类型都有属于自己的<em>符号</em>：分别是<code>$</code>、<code>@</code>和<code>%</code>。变量定义使用<code>my</code>关键字，生命期直到其所在的代码块结束或者文件的末尾。</p>
<h4 id="Scalar变量"><a href="#Scalar变量" class="headerlink" title="Scalar变量"></a>Scalar变量</h4><p>一个scalar变量能包含：</p>
<ul>
<li><code>undef</code>（对应Python中的<code>None</code>、PHP中的<code>null</code>）</li>
<li>数值（Perl不区分整形和浮点类型）</li>
<li>字符串</li>
<li>其他变量的引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my $undef &#x3D; undef;</span><br><span class="line">print $undef; # 打印空字符串&quot;&quot;，并且抛出一个警告</span><br><span class="line"></span><br><span class="line"># 隐式的undef（译者注：未初始化的变量初值默认为undef）：</span><br><span class="line">my $undef2;</span><br><span class="line">print $undef2; # 打印&quot;&quot;，并且抛出完全一样的警告</span><br><span class="line">my $num &#x3D; 4040.5;</span><br><span class="line">print $num; # &quot;4040.5&quot;</span><br><span class="line">my $string &#x3D; &quot;world&quot;;</span><br><span class="line">print $string; # &quot;world&quot;</span><br></pre></td></tr></table></figure>

<p>（稍后会详细说明“引用”。）</p>
<p>用<code>.</code>运算符进行字符串连接（与PHP一样）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello &quot;.$string; # &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>

<h4 id="“布尔类型”（“Boolean”）"><a href="#“布尔类型”（“Boolean”）" class="headerlink" title="“布尔类型”（“Boolean”）"></a>“布尔类型”（“Boolean”）</h4><p><strong>Perl没有内置的布尔类型。</strong><code>if</code>语句中的scalar变量仅在以下情况下被认为是“false”：</p>
<ul>
<li><code>undef</code></li>
<li>数值<code>0</code></li>
<li>字符串<code>&quot;&quot;</code></li>
<li>字符串<code>&quot;0&quot;</code>。</li>
</ul>
<p>Perl的文档中<em>反复</em>强调函数在某些情况下返回“true”或者“false”。实际上，当一个函数声称它返回“true”，返回值往往是<code>1</code>，而当一个函数声称它返回“false”，返回值往往是一个空字符串<code>&quot;&quot;</code>。</p>
<h4 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h4><p><strong>无法判定一个scalar包含的是一个数值还是字符串。</strong>更准确的来说，我们没有必要知道这个信息。一个scalar按照数值还是字符串的方式参与运算，是完全取决于运算符的。因此，像字符串一样使用的时候，scalar就按字符串的方式参与运算，而像数值一样使用的时候，scalar就按照数值的方式参与运算（如果无法转换成数值则会抛出一个警告）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my $str1 &#x3D; &quot;4G&quot;;</span><br><span class="line">my $str2 &#x3D; &quot;4H&quot;;</span><br><span class="line"></span><br><span class="line">print $str1 .  $str2; # &quot;4G4H&quot;</span><br><span class="line">print $str1 +  $str2; # &quot;8&quot; 并且抛出两个警告</span><br><span class="line">print $str1 eq $str2; # &quot;&quot; （空字符串，也就是false）</span><br><span class="line">print $str1 &#x3D;&#x3D; $str2; # &quot;1&quot; 并且抛出两个警告</span><br><span class="line"></span><br><span class="line"># 经典错误</span><br><span class="line">print &quot;yes&quot; &#x3D;&#x3D; &quot;no&quot;; # &quot;1&quot; 并且抛出两个警告，按数值方式参与运算，两边求值结果都是0</span><br></pre></td></tr></table></figure>

<p>教训是应该总是在恰当的情况下使用正确的运算符，对于比较数值和字符串有两套不同的运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数值运算符：  &lt;,  &gt;, &lt;&#x3D;, &gt;&#x3D;, &#x3D;&#x3D;, !&#x3D;, &lt;&#x3D;&gt;, +, *</span><br><span class="line"># 字符串运算符：    lt, gt, le, ge, eq, ne, cmp, ., x</span><br></pre></td></tr></table></figure>

<h4 id="Array变量"><a href="#Array变量" class="headerlink" title="Array变量"></a>Array变量</h4><p>Array变量是包含一个scalar列表的、由从0开始的整形数为下标存取的变量。在Python里被称为<em>list</em>，而在PHP里被称为<em>array</em>。数组可以用一个圆括号包围的scalar列表来声明（译者注：原文declaration，而这里实际表达的含义应为“初始化”，而不是对于变量标识符的声明，下同）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (</span><br><span class="line">	&quot;print&quot;,</span><br><span class="line">	&quot;these&quot;,</span><br><span class="line">	&quot;strings&quot;,</span><br><span class="line">	&quot;out&quot;,</span><br><span class="line">	&quot;for&quot;,</span><br><span class="line">	&quot;me&quot;, # 末尾多余的逗号语法上是允许的</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>你必须要使用美元符号来存取array中的值，因为<em>取到</em>的值是一个scalar而非array：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print $array[0]; # &quot;print&quot;</span><br><span class="line">print $array[1]; # &quot;these&quot;</span><br><span class="line">print $array[2]; # &quot;strings&quot;</span><br><span class="line">print $array[3]; # &quot;out&quot;</span><br><span class="line">print $array[4]; # &quot;for&quot;</span><br><span class="line">print $array[5]; # &quot;me&quot;</span><br><span class="line">print $array[6]; # 返回undef，打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure>

<p>你也可以使用负数作为下标，这样就可以从末尾开始往前取某个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print $array[-1]; # &quot;me&quot;</span><br><span class="line">print $array[-2]; # &quot;for&quot;</span><br><span class="line">print $array[-3]; # &quot;out&quot;</span><br><span class="line">print $array[-4]; # &quot;strings&quot;</span><br><span class="line">print $array[-5]; # &quot;these&quot;</span><br><span class="line">print $array[-6]; # &quot;print&quot;</span><br><span class="line">print $array[-7]; # 返回undef，打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure>

<p>同时存在scalar变量<code>$var</code>和包含scalar元素<code>$var[0]</code>的array变量<code>@var</code>是没有冲突的，不过会对代码的读者造成一些误导，所以请避免这种情况。</p>
<p>取得array的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &quot;This array has &quot;.(scalar @array).&quot;elements&quot;; # &quot;This array has 6 elements&quot;</span><br><span class="line">print &quot;The last populated index is &quot;.$#array;       # &quot;The last populated index is 5&quot;</span><br></pre></td></tr></table></figure>

<p>调用Perl脚本时使用的参数列表被保存在<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置的array变量</a><code>@ARGV</code>中。</p>
<p>变量可以被插入到字符串中被求值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello $string&quot;; # &quot;Hello world&quot;</span><br><span class="line">print &quot;@array&quot;;        # &quot;print these strings out for me&quot;</span><br></pre></td></tr></table></figure>

<p><strong>小心。</strong>也许有一点你会把某个人的email地址放在一个字符串里，比如<code>&quot;jeff@gmail.com&quot;</code>。Perl会去尝试找一个名叫<code>@gmail</code>的array变量，求值并插入到字符串中，如果没有找到这个变量，将会导致一个运行时错误。有两种方法可以避免对字符串中的变量名求值：用反斜杠对<code>@</code>进行转义，或者将双引号改为单引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello \$string&quot;; # &quot;Hello $string&quot;</span><br><span class="line">print &#39;Hello $string&#39;;  # &quot;Hello $string&quot;</span><br><span class="line">print &quot;\@array&quot;;        # &quot;@array&quot;</span><br><span class="line">print &#39;@array&#39;;         # &quot;@array&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Hash变量"><a href="#Hash变量" class="headerlink" title="Hash变量"></a>Hash变量</h4><p>Hash变量是包含一个scalar列表的、由字符串为下标存取的变量。在Python中被称为<em>dictionary</em>，而在PHP中被称为<em>array</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my %scientists &#x3D; (</span><br><span class="line">	&quot;Newton&quot;   &#x3D;&gt; &quot;Isaac&quot;,</span><br><span class="line">	&quot;Einstein&quot; &#x3D;&gt; &quot;Albert&quot;,</span><br><span class="line">	&quot;Darwin&quot;   &#x3D;&gt; &quot;Charles&quot;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>请注意这个声明与array何其相似。事实上，这个双箭头符号<code>=&gt;</code>被称为“fat comma”（胖逗号），因为它与逗号完全等价。Hash变量由偶数个元素组成的列表来声明，其中偶数下标（0、2、……）的元素都被当做字符串使用。</p>
<p>与array一样，你也需要用美元符号来存取hash中的值，因为<em>取到</em>的值是scalar而非hash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print $scientists&#123;&quot;Newton&quot;&#125;;   # &quot;Isaac&quot;</span><br><span class="line">print $scientists&#123;&quot;Einstein&quot;&#125;; # &quot;Albert&quot;</span><br><span class="line">print $scientists&#123;&quot;Darwin&quot;&#125;;   # &quot;Charles&quot;</span><br><span class="line">print $scientists&#123;&quot;Dyson&quot;&#125;;    # 返回undef，打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure>

<p>注意在这里使用的花括号。同样的，同时存在scalar变量<code>$var</code>和包含scalar元素<code>$var{&quot;foo&quot;}</code>的hash变量<code>%var</code>是没有冲突的。</p>
<p>你可以将一个hash转换为两倍数量元素的array，原先hash中的键和值在转换后的array中交替出现（反向的转换也同样简单）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my @scientists &#x3D; %scientists;</span><br></pre></td></tr></table></figure>

<p>然而有一点与array不同，hash中的键<em>没有特定的保存顺序</em>，而是以一种比较高效的方式进行存储。因此，需要注意转换后的array会将hash中的<em>键值对</em>重新排列<em>次序</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;@scientists&quot;; # 输出可能是&quot;Einstein Albert Darwin Charles Newton Isaac&quot;</span><br></pre></td></tr></table></figure>

<p>回顾一下，我们使用<strong>方括号</strong>来取array中的值，而使用<strong>花括号</strong>来取hash中的值。方括号是一个有效的数值运算符，而花括号是一个有效的字符串运算符，因此事实上，作为<em>下标</em>的值是数值还是字符串类型其实并不重要（译者注：正如前文所提到的，scalar以什么方式参与运算取决于运算符）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my $data &#x3D; &quot;orange&quot;;</span><br><span class="line">my @data &#x3D; (&quot;purple&quot;);</span><br><span class="line">my %data &#x3D; ( &quot;0&quot; &#x3D;&gt; &quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">print $data;      # &quot;orange&quot;</span><br><span class="line">print $data[0];   # &quot;purple&quot;</span><br><span class="line">print $data[&quot;0&quot;]; # &quot;purple&quot;</span><br><span class="line">print $data&#123;0&#125;;   # &quot;blue&quot;</span><br><span class="line">print $data&#123;&quot;0&quot;&#125;; # &quot;blue&quot;</span><br></pre></td></tr></table></figure>

<h4 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h4><p>Perl中的<em>列表</em>与array和hash都不一样。你已经见过一些列表了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">	&quot;print&quot;,</span><br><span class="line">	&quot;these&quot;,</span><br><span class="line">	&quot;strings&quot;,</span><br><span class="line">	&quot;out&quot;,</span><br><span class="line">	&quot;for&quot;,</span><br><span class="line">	&quot;me&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">	&quot;Newton&quot;   &#x3D;&gt; &quot;Isaac&quot;,</span><br><span class="line">	&quot;Einstein&quot; &#x3D;&gt; &quot;Albert&quot;,</span><br><span class="line">	&quot;Darwin&quot;   &#x3D;&gt; &quot;Charles&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>列表不是一个变量</strong>列表是一个暂存的<em>值</em>，可以被<em>赋值</em>到一个array或者hash变量，这就是为什么声明array和hash的语法竟完全一样。在许多情况下“列表”和“array”这两个词可以混用，而在同样多的情况下，列表和array表现出微妙的区别，并且具有极其容易混淆的行为。</p>
<p>好的，回想一下<code>=&gt;</code>只是<code>,</code>的一种伪装，然后看一下下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&quot;one&quot;, 1, &quot;three&quot;, 3, &quot;five&quot;, 5)</span><br><span class="line">(&quot;one&quot; &#x3D;&gt; 1, &quot;three&quot; &#x3D;&gt; 3, &quot;five&quot; &#x3D;&gt; 5)</span><br></pre></td></tr></table></figure>

<p>使用<code>=&gt;</code>暗示了其中一个是hash的声明（译者注：第二个），而另一个是array的声明，但就这两个列表自身并没有声明任何东西，它们只是列表，而且是<em>完全相同的</em>列表。同样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure>

<p>这里甚至没有任何变量类型的提示，这个列表可以用来声明一个空array或者空hash，而作为<code>perl</code>解释器则完全无法知道将会是哪一种。一旦你理解了这一点，你也就能理解Perl的这个事实：<strong>列表不能嵌套。</strong>我们可以试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (</span><br><span class="line">	&quot;apples&quot;,</span><br><span class="line">	&quot;bananas&quot;,</span><br><span class="line">	(</span><br><span class="line">		&quot;inner&quot;,</span><br><span class="line">		&quot;list&quot;,</span><br><span class="line">		&quot;several&quot;,</span><br><span class="line">		&quot;entries&quot;,</span><br><span class="line">	),</span><br><span class="line">	&quot;cherries&quot;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Perl无法知道<code>(&quot;inner&quot;, &quot;list&quot;, &quot;several&quot;, &quot;entries&quot;)</code>应该是array还是hash，因此Perl假设两者都不是，而<strong>将其扁平化为一个一维长列表</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print $array[0]; # &quot;apples&quot;</span><br><span class="line">print $array[1]; # &quot;bananas&quot;</span><br><span class="line">print $array[2]; # &quot;inner&quot;</span><br><span class="line">print $array[3]; # &quot;list&quot;</span><br><span class="line">print $array[4]; # &quot;several&quot;</span><br><span class="line">print $array[5]; # &quot;entries&quot;</span><br><span class="line">print $array[6]; # &quot;cherries&quot;</span><br></pre></td></tr></table></figure>

<p>即使使用fat comma也会是同样的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my %hash &#x3D; (</span><br><span class="line">	&quot;beer&quot; &#x3D;&gt; &quot;good&quot;,</span><br><span class="line">	&quot;bananas&quot; &#x3D;&gt; (</span><br><span class="line">		&quot;green&quot;  &#x3D;&gt; &quot;wait&quot;,</span><br><span class="line">		&quot;yellow&quot; &#x3D;&gt; &quot;eat&quot;,</span><br><span class="line">	),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 上面的代码会抛出一个警告，因为我们尝试用7个元素的列表来初始化这个hash</span><br><span class="line"></span><br><span class="line">print $hash&#123;&quot;beer&quot;&#125;;    # &quot;good&quot;</span><br><span class="line">print $hash&#123;&quot;bananas&quot;&#125;; # &quot;green&quot;</span><br><span class="line">print $hash&#123;&quot;wait&quot;&#125;;    # &quot;yellow&quot;;</span><br><span class="line">print $hash&#123;&quot;eat&quot;&#125;;     # undef，因此打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure>

<p>当然，这倒让连接数组变得简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @bones   &#x3D; (&quot;humerus&quot;, (&quot;jaw&quot;, &quot;skull&quot;), &quot;tibia&quot;);</span><br><span class="line">my @fingers &#x3D; (&quot;thumb&quot;, &quot;index&quot;, &quot;middle&quot;, &quot;ring&quot;, &quot;little&quot;);</span><br><span class="line">my @parts   &#x3D; (@bones, @fingers, (&quot;foot&quot;, &quot;toes&quot;), &quot;eyeball&quot;, &quot;knuckle&quot;);</span><br><span class="line">print @parts;</span><br></pre></td></tr></table></figure>

<p>稍后会有更多关于这个问题的说明。</p>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>Perl最独特的特性在于它的代码<em>对于上下文是敏感的</em>。<strong>每个Perl的表达式要么在scalar上下文中求值，要么在列表上下文中求值</strong>，取决于此处期望产生一个scalar还是列表。许多Perl表达式和<a href="http://perldoc.perl.org/perlfunc.html" target="_blank" rel="noopener">内置函数</a>在不同的求值上下文中的行为大相径庭。</p>
<p>Scalar的赋值例如<code>$scalar =</code>会在scalar上下文求值，在这种例子中，表达式为<code>&quot;Mendeleev&quot;</code>，而返回的是同样的scalar值<code>&quot;Mendeleev&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $scalar &#x3D; &quot;Mendeleev&quot;;</span><br></pre></td></tr></table></figure>

<p>Array或者hash的赋值例如<code>@array =</code>或者<code>%hash =</code>会在列表上下文求值，在列表上下文中求值的列表就会返回这个列表本身，然后被用于初始化这个array或者hash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Pie&quot;);</span><br><span class="line">my %hash &#x3D; (&quot;Alpha&quot; &#x3D;&gt; &quot;Beta&quot;, &quot;Gamma&quot; &#x3D;&gt; &quot;Pie&quot;);</span><br></pre></td></tr></table></figure>

<p>到目前为止还没什么特别的。</p>
<p>在列表上下文中求值的scalar表达式会被转换成含有一个元素的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; &quot;Mendeleev&quot;; # 与&#39;my @array &#x3D; (&quot;Mendeleev&quot;);&#39;等价</span><br></pre></td></tr></table></figure>

<p>在scalar上下文中求值的列表表达式会返回<em>列表中的最后一个scalar</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $scalar &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Pie&quot;); # $scalar的值现在是&quot;Pie&quot;</span><br></pre></td></tr></table></figure>

<p>在scalar上下文中求值的array（还记得array和列表不同吗？）表达式返回<em>该数组的长度</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Pie&quot;);</span><br><span class="line">my $scalar &#x3D; @array; # $scalar的值现在是4</span><br></pre></td></tr></table></figure>

<p><code>print</code>内置函数在列表上下文中求对所有的参数求值。事实上，<code>print</code>能够接受无限个参数的列表，并且一个接一个地打印它们，这就意味着我们可以直接用它来打印array：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Goo&quot;);</span><br><span class="line">my $scalar &#x3D; &quot;-X-&quot;;</span><br><span class="line">print @array;              # &quot;AlphaBetaGoo&quot;;</span><br><span class="line">print $scalar, @array, 98; # &quot;-X-AlphaBetaGoo98&quot;;</span><br></pre></td></tr></table></figure>

<p>你可以用内置函数<code>scalar</code>强制让任何表达式在scalar上下文进行求值，这就是我们为什么用<code>scalar</code>来得到array的长度。</p>
<p>即使子过程要在scalar上下文进行求值，语法上也没有规定必须要返回一个scalar，就像我们看到的，Perl完全可以为你捏造一个需要的结果。</p>
<h3 id="引用和嵌套数据结构"><a href="#引用和嵌套数据结构" class="headerlink" title="引用和嵌套数据结构"></a>引用和嵌套数据结构</h3><p>列表无法包含列表作为其元素，<strong>array也同样无法包含其他array和hash作为其元素</strong>，它们只能包含scalar。看看我们尝试下面的做法会发生什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my @outer &#x3D; (&quot;Sun&quot;, &quot;Mercury&quot;, &quot;Venus&quot;, undef, &quot;Mars&quot;);</span><br><span class="line">my @inner &#x3D; (&quot;Earth&quot;, &quot;Moon&quot;);</span><br><span class="line"></span><br><span class="line">$outer[3] &#x3D; @inner;</span><br><span class="line"></span><br><span class="line">print $outer[3]; # &quot;2&quot;</span><br></pre></td></tr></table></figure>

<p><code>$outer[3]</code>是个scalar，因此它需要一个scalar值。当你尝试将<code>@inner</code>这样的array值赋给它，<code>@inner</code>就会在scalar上下文中被求值，这就与将<code>scalar @inner</code>是同样的效果。这相当于求出了array <code>@inner</code>的长度，也就是2。</p>
<p>然而，scalar变量可以包含任何变量的<em>引用</em>，包括array和hash。在Perl中，复杂的数据结构就是这样被构造出来的。</p>
<p>我们用反斜杠来创建一个引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $colour    &#x3D; &quot;Indigo&quot;;</span><br><span class="line">my $scalarRef &#x3D; \$colour;</span><br></pre></td></tr></table></figure>

<p>如果你能够使用某个变量名，你可以加一些花括号，把一个变量的<em>引用</em>放进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print $colour;         # &quot;Indigo&quot;</span><br><span class="line">print $scalarRef;      # 输出可能是 &quot;SCALAR(0x182c180)&quot;</span><br><span class="line">print $&#123; $scalarRef &#125;; # &quot;Indigo&quot;</span><br></pre></td></tr></table></figure>

<p>如果结果没有歧义的话，你甚至可以直接省略掉花括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print $$scalarRef; # &quot;Indigo&quot;</span><br></pre></td></tr></table></figure>

<p>如果是一个对array或者hash的引用，你可以用花括号或者更加风靡的箭头运算符<code>-&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my @colours &#x3D; (&quot;Red&quot;, &quot;Orange&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Blue&quot;);</span><br><span class="line">my $arrayRef &#x3D; \@colours;</span><br><span class="line"></span><br><span class="line">print $colours[0];       # 直接访问array元素</span><br><span class="line">print $&#123; $arrayRef &#125;[0]; # 通过引用访问array元素</span><br><span class="line">print $arrayRef-&gt;[0];    # 与上一句等价</span><br><span class="line"></span><br><span class="line">my %atomicWeights &#x3D; (&quot;Hydrogen&quot; &#x3D;&gt; 1.008, &quot;Helium&quot; &#x3D;&gt; 4.003, &quot;Manganese&quot; &#x3D;&gt; 54.94);</span><br><span class="line">my $hashRef &#x3D; \%atomicWeights;</span><br><span class="line"></span><br><span class="line">print $atomicWeights&#123;&quot;Helium&quot;&#125;; # 直接访问hash元素</span><br><span class="line">print $&#123; $hashRef &#125;&#123;&quot;Helium&quot;&#125;;  # 通过引用访问hash元素</span><br><span class="line">print $hashRef-&gt;&#123;&quot;Helium&quot;&#125;;     # 与上一句等价 - 这种写法相当常见</span><br></pre></td></tr></table></figure>

<h4 id="声明数据结构"><a href="#声明数据结构" class="headerlink" title="声明数据结构"></a>声明数据结构</h4><p>这里有4个例子，不过现实中最后一个最有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my %owner1 &#x3D; (</span><br><span class="line">	&quot;name&quot; &#x3D;&gt; &quot;Santa Claus&quot;,</span><br><span class="line">	&quot;DOB&quot;  &#x3D;&gt; &quot;1882-12-25&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my $owner1Ref &#x3D; \%owner1;</span><br><span class="line"></span><br><span class="line">my %owner2 &#x3D; (</span><br><span class="line">	&quot;name&quot; &#x3D;&gt; &quot;Mickey Mouse&quot;,</span><br><span class="line">	&quot;DOB&quot;  &#x3D;&gt; &quot;1928-11-18&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my $owner2Ref &#x3D; \%owner2;</span><br><span class="line"></span><br><span class="line">my @owners &#x3D; ( $owner1Ref, $owner2Ref );</span><br><span class="line"></span><br><span class="line">my $ownersRef &#x3D; \@owners;</span><br><span class="line"></span><br><span class="line">my %account &#x3D; (</span><br><span class="line">	&quot;number&quot; &#x3D;&gt; &quot;12345678&quot;,</span><br><span class="line">	&quot;opened&quot; &#x3D;&gt; &quot;2000-01-01&quot;,</span><br><span class="line">	&quot;owners&quot; &#x3D;&gt; $ownersRef,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>显然可以不用这么费劲，这段代码可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my %owner1 &#x3D; (</span><br><span class="line">	&quot;name&quot; &#x3D;&gt; &quot;Santa Claus&quot;,</span><br><span class="line">	&quot;DOB&quot;  &#x3D;&gt; &quot;1882-12-25&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my %owner2 &#x3D; (</span><br><span class="line">	&quot;name&quot; &#x3D;&gt; &quot;Mickey Mouse&quot;,</span><br><span class="line">	&quot;DOB&quot;  &#x3D;&gt; &quot;1928-11-18&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my @owners &#x3D; ( \%owner1, \%owner2 );</span><br><span class="line"></span><br><span class="line">my %account &#x3D; (</span><br><span class="line">	&quot;number&quot; &#x3D;&gt; &quot;12345678&quot;,</span><br><span class="line">	&quot;opened&quot; &#x3D;&gt; &quot;2000-01-01&quot;,</span><br><span class="line">	&quot;owners&quot; &#x3D;&gt; \@owners,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>用不同的符号声明<em>匿名</em>的array和hash也是可行的。用方括号声明匿名array，而用花括号声明匿名hash，这两种方法返回的是声明的匿名数据结构的<em>引用</em>。看仔细了，下面的代码声明的<code>%account</code>和上面的完全等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 花括号表示匿名hash</span><br><span class="line">my $owner1Ref &#x3D; &#123;</span><br><span class="line">	&quot;name&quot; &#x3D;&gt; &quot;Santa Claus&quot;,</span><br><span class="line">	&quot;DOB&quot;  &#x3D;&gt; &quot;1882-12-25&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">my $owner2Ref &#x3D; &#123;</span><br><span class="line">	&quot;name&quot; &#x3D;&gt; &quot;Mickey Mouse&quot;,</span><br><span class="line">	&quot;DOB&quot;  &#x3D;&gt; &quot;1928-11-18&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 方括号表示匿名array</span><br><span class="line">my $ownersRef &#x3D; [ $owner1Ref, $owner2Ref ];</span><br><span class="line"></span><br><span class="line">my %account &#x3D; (</span><br><span class="line">	&quot;number&quot; &#x3D;&gt; &quot;12345678&quot;,</span><br><span class="line">	&quot;opened&quot; &#x3D;&gt; &quot;2000-01-01&quot;,</span><br><span class="line">	&quot;owners&quot; &#x3D;&gt; $ownersRef,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者写得更加简短（这也是你<em>真正</em>应该用来声明复杂数据结构的方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my %account &#x3D; (</span><br><span class="line">	&quot;number&quot; &#x3D;&gt; &quot;31415926&quot;,</span><br><span class="line">	&quot;opened&quot; &#x3D;&gt; &quot;3000-01-01&quot;,</span><br><span class="line">	&quot;owners&quot; &#x3D;&gt; [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;name&quot; &#x3D;&gt; &quot;Philip Fry&quot;,</span><br><span class="line">			&quot;DOB&quot;  &#x3D;&gt; &quot;1974-08-06&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;name&quot; &#x3D;&gt; &quot;Hubert Farnsworth&quot;,</span><br><span class="line">			&quot;DOB&quot;  &#x3D;&gt; &quot;2841-04-09&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="从数据结构中获取信息"><a href="#从数据结构中获取信息" class="headerlink" title="从数据结构中获取信息"></a>从数据结构中获取信息</h4><p>现在我们假设你还在折腾那个<code>%account</code>，而且其他东西都不在作用域内（如果还有其他东西的话）。你可以逆向操作解引用，以取得每一项需要打印的信息。同样，这里有4个例子，其中最后一个最有用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my $ownersRef &#x3D; $account&#123;&quot;owners&quot;&#125;;</span><br><span class="line">my @owners    &#x3D; @&#123; $ownersRef &#125;;</span><br><span class="line">my $owner1Ref &#x3D; $owners[0];</span><br><span class="line">my %owner1    &#x3D; %&#123; $owner1Ref &#125;;</span><br><span class="line">my $owner2Ref &#x3D; $owners[1];</span><br><span class="line">my %owner2    &#x3D; %&#123; $owner2Ref &#125;;</span><br><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner1&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner1&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner2&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner2&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure>

<p>或者写得更简短些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my @owners &#x3D; @&#123; $account&#123;&quot;owners&quot;&#125; &#125;;</span><br><span class="line">my %owner1 &#x3D; %&#123; $owners[0] &#125;;</span><br><span class="line">my %owner2 &#x3D; %&#123; $owners[1] &#125;;</span><br><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner1&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner1&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner2&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner2&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure>

<p>或者使用引用和<code>-&gt;</code>运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my $ownersRef &#x3D; $account&#123;&quot;owners&quot;&#125;;</span><br><span class="line">my $owner1Ref &#x3D; $ownersRef-&gt;[0];</span><br><span class="line">my $owner2Ref &#x3D; $ownersRef-&gt;[1];</span><br><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner1Ref-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner1Ref-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner2Ref-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner2Ref-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure>

<p>如果我们完全跳过那些中间值，代码看起来就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[0]-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[0]-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[1]-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[1]-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="如何用array的引用作茧自缚"><a href="#如何用array的引用作茧自缚" class="headerlink" title="如何用array的引用作茧自缚"></a>如何用array的引用作茧自缚</h4><p>这个数组有5个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array1 &#x3D; (1, 2, 3, 4, 5);</span><br><span class="line">print @array1; # &quot;12345&quot;</span><br></pre></td></tr></table></figure>

<p>然而这个array只有<em>1</em>个元素（一个含有5个元素的匿名array的引用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array2 &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">print @array2; # e.g. &quot;ARRAY(0x182c180)&quot;</span><br></pre></td></tr></table></figure>

<p>这个<em>scalar</em>是一个含有5个元素的匿名array的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $array3Ref &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">print $array3Ref;      # e.g. &quot;ARRAY(0x22710c0)&quot;</span><br><span class="line">print @&#123; $array3Ref &#125;; # &quot;12345&quot;</span><br><span class="line">print @$array3Ref;     # &quot;12345&quot;</span><br></pre></td></tr></table></figure>

<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><h4 id="if-…-elsif-…-else-…"><a href="#if-…-elsif-…-else-…" class="headerlink" title="if … elsif … else …"></a><code>if</code> … <code>elsif</code> … <code>else</code> …</h4><p>这里没有什么特别之处，除了<code>elsif</code>的拼写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my $word &#x3D; &quot;antidisestablishmentarianism&quot;;</span><br><span class="line">my $strlen &#x3D; length $word;</span><br><span class="line"></span><br><span class="line">if($strlen &gt;&#x3D; 15) &#123;</span><br><span class="line">	print &quot;&#39;&quot;, $word, &quot;&#39; is a very long word&quot;;</span><br><span class="line">&#125; elsif(10 &lt;&#x3D; $strlen &amp;&amp; $strlen &lt; 15) &#123;</span><br><span class="line">	print &quot;&#39;&quot;, $word, &quot;&#39; is a medium-length word&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	print &quot;&#39;&quot;, $word, &quot;&#39; is a short word&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Perl提供了一种更简短的“<em>statement</em> <code>if</code> <em>condition</em>”语法，对于<strong>短</strong>的语句强烈推荐这种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;&#39;&quot;, $word, &quot;&#39; is actually enormous&quot; if $strlen &gt;&#x3D; 20;</span><br></pre></td></tr></table></figure>

<h4 id="unless-…-else-…"><a href="#unless-…-else-…" class="headerlink" title="unless … else …"></a><code>unless</code> … <code>else</code> …</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my $temperature &#x3D; 20;</span><br><span class="line"></span><br><span class="line">unless($temperature &gt; 30) &#123;</span><br><span class="line">	print $temperature, &quot; degrees Celsius is not very hot&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	print $temperature, &quot; degrees Celsius is actually pretty hot&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好像避开瘟疫一样避开<code>unless</code>语句，因为这实在太容易把读者搞得晕头转向。“<code>unless</code> [… <code>else</code>]”语句块可以显而易见地通过对条件取反（或者保持条件不变调换语句块的位置）来重构成“<code>if</code> [… <code>else</code>]”。万幸的是，没有<code>elsunless</code>关键字。</p>
<p>而相比之下，这种写法就被强烈推荐，因为实在是太易于阅读了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Oh no it&#39;s too cold&quot; unless $temperature &gt; 15;</span><br></pre></td></tr></table></figure>

<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>三目运算符<code>?:</code>使得简单的<code>if</code>语句可以嵌入到其他语句内。一种常规的用法就是用来处理单复数形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $gain &#x3D; 48;</span><br><span class="line">print &quot;You gained &quot;, $gain, &quot; &quot;, ($gain &#x3D;&#x3D; 1 ? &quot;experience point&quot; : &quot;experience points&quot;), &quot;!&quot;;</span><br></pre></td></tr></table></figure>

<p>题外话：单复数形式最好都写出完整的拼写，不要自作聪明地写成下面这种样子，要不然别人永远也无法在代码中查找、替换到“tooth”或者“teeth”了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $lost &#x3D; 1;</span><br><span class="line">print &quot;You lost &quot;, $lost, &quot; t&quot;, ($lost &#x3D;&#x3D; 1 ? &quot;oo&quot; : &quot;ee&quot;), &quot;th!&quot;;</span><br></pre></td></tr></table></figure>

<p>三目运算符可以嵌套：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $eggs &#x3D; 5;</span><br><span class="line">print &quot;You have &quot;, $eggs &#x3D;&#x3D; 0 ? &quot;no eggs&quot; :</span><br><span class="line">                   $eggs &#x3D;&#x3D; 1 ? &quot;an egg&quot;  :</span><br><span class="line">                   &quot;some eggs&quot;;</span><br></pre></td></tr></table></figure>

<p><code>if</code>语句在scalar上下文中进行求值。举例说明，<code>if(@array)</code>当且仅当<code>@array</code>包含大于等于1个元素的时候返回true，而元素的内容则无关紧要（也许包括<code>undef</code>或者其他我们真正关心的代表false的值）。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>“每个问题都有不止一种解决方法”</p>
<p>Perl支持传统的<code>while</code>循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">while($i &lt; scalar @array) &#123;</span><br><span class="line">	print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">	$i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Perl也提供了<code>until</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">until($i &gt;&#x3D; scalar @array) &#123;</span><br><span class="line">	print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">	$i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些<code>do</code>循环<em>几乎</em>和上面的循环等价（如果<code>@array</code>为空会抛出一个警告）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">do &#123;</span><br><span class="line">	print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">	$i++;</span><br><span class="line">&#125; while ($i &lt; scalar @array);</span><br></pre></td></tr></table></figure>

<p>and</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">do &#123;</span><br><span class="line">	print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">	$i++;</span><br><span class="line">&#125; until ($i &gt;&#x3D; scalar @array);</span><br></pre></td></tr></table></figure>

<p>基本的C风格<code>for</code>循环也可以使用。注意我们怎么将<code>my</code>放到<code>for</code>语句内部，这样声明的<code>$i</code>的作用于就仅限于循环内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(my $i &#x3D; 0; $i &lt; scalar @array; $i++) &#123;</span><br><span class="line">	print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">&#125;</span><br><span class="line"># $i在这里就不存在了，代码显得更加整洁。</span><br></pre></td></tr></table></figure>

<p>这种<code>for</code>循环被视为过时的东西，应该尽量避免使用，使用原生的array迭代语法看起来更漂亮。注意：与PHP不同，<code>for</code>和<code>foreach</code>关键字是等价的，选可读性比较好的那个来用就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $string ( @array ) &#123;</span><br><span class="line">	print $string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要使用下标，<a href="http://perldoc.perl.org/perlop.html#Range-Operators" target="_blank" rel="noopener">range运算符</a><code>..</code>会创建一个匿名的整形数列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $i ( 0 .. $#array ) &#123;</span><br><span class="line">	print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你无法迭代一个hash，而你可以迭代它所有的键。使用内置函数<code>keys</code>来取得包含这个hash所有键的array，然后使用<code>foreach</code>来遍历它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $key (keys %scientists) &#123;</span><br><span class="line">	print $key, &quot;: &quot;, $scientists&#123;$key&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为hash没有既定的次序，键可能以任何次序返回，使用内置函数<code>sort</code>事先对包含键的array进行字母序排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $key (sort keys %scientists) &#123;</span><br><span class="line">	print $key, &quot;: &quot;, $scientists&#123;$key&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你没有显示指定迭代器，Perl将使用默认迭代器<code>$_</code>。<code>$_</code>是第一个也是最友好的一个<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置变量</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach ( @array ) &#123;</span><br><span class="line">	print $_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用默认迭代器，并且你希望在循环里只放一句语句，你可以使用下面这种超级简洁的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print $_ foreach @array;</span><br></pre></td></tr></table></figure>

<h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p><code>next</code>和<code>last</code>可以用来控制循环过程，在其他大部分编程语言中分别相当于<code>continue</code>和<code>break</code>。一般约定，行标写成<strong>全部大写</strong>。在循环里加上行标以后，<code>next</code>和<code>last</code>可以选择指定跳转到某个行标。下面的示例程序能够找出100以内的素数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CANDIDATE: for my $candidate ( 2 .. 100 ) &#123;</span><br><span class="line">	for my $divisor ( 2 .. sqrt $candidate ) &#123;</span><br><span class="line">		next CANDIDATE if $candidate % $divisor &#x3D;&#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	print $candidate.&quot; is prime\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Array函数"><a href="#Array函数" class="headerlink" title="Array函数"></a>Array函数</h3><h4 id="原地（In-place）array修改函数"><a href="#原地（In-place）array修改函数" class="headerlink" title="原地（In-place）array修改函数"></a>原地（In-place）array修改函数</h4><p>我们用<code>@stack</code>来演示这些函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @stack &#x3D; (&quot;Fred&quot;, &quot;Eileen&quot;, &quot;Denise&quot;, &quot;Charlie&quot;);</span><br><span class="line">print @stack; # &quot;FredEileenDeniseCharlie&quot;</span><br></pre></td></tr></table></figure>

<p><code>pop</code>抽取并返回array的最后一个元素，可以认为是栈顶的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print pop @stack; # &quot;Charlie&quot;</span><br><span class="line">print @stack;     # &quot;FredEileenDenise&quot;</span><br></pre></td></tr></table></figure>

<p><code>push</code>向array末尾添加一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push @stack, &quot;Bob&quot;, &quot;Alice&quot;;</span><br><span class="line">print @stack; # &quot;FredEileenDeniseBobAlice&quot;</span><br></pre></td></tr></table></figure>

<p><code>shift</code>抽取并返回array的第一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print shift @stack; # &quot;Fred&quot;</span><br><span class="line">print @stack;       # &quot;EileenDeniseBobAlice&quot;</span><br></pre></td></tr></table></figure>

<p><code>unshift</code>向array的头部插入一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unshift @stack, &quot;Hank&quot;, &quot;Grace&quot;;</span><br><span class="line">print @stack; # &quot;HankGraceEileenDeniseBobAlice&quot;</span><br></pre></td></tr></table></figure>

<p><code>pop</code>、<code>push</code>、<code>shift</code>和<code>unshift</code>都是<code>splice</code>的特例。<code>splice</code>返回删除的一个array的切片，并且用另一个array的切片在原array中替换之：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print splice(@stack, 1, 4, &quot;&lt;&lt;&lt;&quot;, &quot;&gt;&gt;&gt;&quot;); # &quot;GraceEileenDeniseBob&quot;</span><br><span class="line">print @stack;                             # &quot;Hank&lt;&lt;&lt;&gt;&gt;&gt;Alice&quot;</span><br></pre></td></tr></table></figure>

<h4 id="从现有的array创建新的array"><a href="#从现有的array创建新的array" class="headerlink" title="从现有的array创建新的array"></a>从现有的array创建新的array</h4><p>Perl提供下面这些函数，可以操作现有的array产生新的array。</p>
<p><code>join</code>函数把多个字符串连接成一个字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @elements &#x3D; (&quot;Antimony&quot;, &quot;Arsenic&quot;, &quot;Aluminum&quot;, &quot;Selenium&quot;);</span><br><span class="line">print @elements;             # &quot;AntimonyArsenicAluminumSelenium&quot;</span><br><span class="line">print &quot;@elements&quot;;           # &quot;Antimony Arsenic Aluminum Selenium&quot;</span><br><span class="line">print join(&quot;, &quot;, @elements); # &quot;Antimony, Arsenic, Aluminum, Selenium&quot;</span><br></pre></td></tr></table></figure>

<p>在列表上下文，<code>reverse</code>函数把传入的列表逆序返回，在scalar上下文，<code>reverse</code>先把字符串列表连接起来，再将这个字符串反转。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print reverse(&quot;Hello&quot;, &quot;World&quot;);        # &quot;WorldHello&quot;</span><br><span class="line">print reverse(&quot;HelloWorld&quot;);            # &quot;HelloWorld&quot;</span><br><span class="line">print scalar reverse(&quot;HelloWorld&quot;);     # &quot;dlroWolleH&quot;</span><br><span class="line">print scalar reverse(&quot;Hello&quot;, &quot;World&quot;); # &quot;dlroWolleH&quot;</span><br></pre></td></tr></table></figure>

<p><code>map</code>函数接受一个array，并将一个操作应用于这个array中的每一个scalar <code>$_</code>，然后返回用这些scalar创建的array。这个操作用在花括号中的一个表达式来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @capitals &#x3D; (&quot;Baton Rouge&quot;, &quot;Indianapolis&quot;, &quot;Columbus&quot;, &quot;Montgomery&quot;, &quot;Helena&quot;, &quot;Denver&quot;, &quot;Boise&quot;);</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, map &#123; uc $_ &#125; @capitals;</span><br><span class="line"># &quot;BATON ROUGE, INDIANAPOLIS, COLUMBUS, MONTGOMERY, HELENA, DENVER, BOISE&quot;</span><br></pre></td></tr></table></figure>

<p><code>grep</code>函数接受一个array，并返回一个经过筛选的array。语法与<code>map</code>类似，而第二个参数会对array中的每个scalar <code>$_</code>求值，如果返回true，这个scalar就会被放到输出array中，否则就不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print join &quot;, &quot;, grep &#123; length $_ &#x3D;&#x3D; 6 &#125; @capitals;</span><br><span class="line"># &quot;Helena, Denver&quot;</span><br></pre></td></tr></table></figure>

<p>显然，返回的array长度是<em>满足条件的元素个数</em>，这就意味着你可以用<code>grep</code>检查array中是否包含某个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print scalar grep &#123; $_ eq &quot;Columbus&quot; &#125; @capitals; # &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p><code>grep</code>和<code>map</code>的组合形成了*<a href="https://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">list comprehensions</a>*这种许多其他语言中欠缺的非常强大特性。（译者注：list comprehensions大致的意思是利用map和filter从现有的列表构造新的列表，表达的含义是对一个列表中满足某个条件的所有元素上应用某个操作，而形成一个新的列表。）</p>
<p>默认情况下，<code>sort</code>函数对输入的array按字母序进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @elevations &#x3D; (19, 1, 2, 100, 3, 98, 100, 1056);</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, sort @elevations;</span><br><span class="line"># &quot;1, 100, 100, 1056, 19, 2, 3, 98&quot;</span><br></pre></td></tr></table></figure>

<p>然而，与<code>grep</code>和<code>map</code>类似，排序总是通过一系列元素的两两比较来进行的。你的代码块接受<code>$a</code>和<code>$b</code>作为输入，如果<code>$a</code>“小于”<code>$b</code>则返回-1，如果“相等”则返回0，而如果<code>$a</code>“大于”<code>$b</code>则返回1。</p>
<p><code>cmp</code>运算符适用于字符串（译者注：按字母序比较）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print join &quot;, &quot;, sort &#123; $a cmp $b &#125; @elevations;</span><br><span class="line"># &quot;1, 100, 100, 1056, 19, 2, 3, 98&quot;</span><br></pre></td></tr></table></figure>

<p>这个“宇宙飞船运算符”<code>&lt;=&gt;</code>适用于数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print join &quot;, &quot;, sort &#123; $a &lt;&#x3D;&gt; $b &#125; @elevations;</span><br><span class="line"># &quot;1, 2, 3, 19, 98, 100, 100, 1056&quot;</span><br></pre></td></tr></table></figure>

<p><code>$a</code>和<code>$b</code>总是scalar，但是它们也许是某个复杂对象的引用，那样就很难直接进行比较。如果你需要更多篇幅来描述这种比较，你可以单独创建一个子程序来描述它，并在用到它的地方提供这个子程序的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sub comparator &#123;</span><br><span class="line">	# lots of code...</span><br><span class="line">	# return -1, 0 or 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, sort comparator @elevations;</span><br></pre></td></tr></table></figure>

<p>不过你不能对<code>grep</code>或<code>map</code>这样做。</p>
<p>请注意，我们从来没有显式提供<code>$a</code>和<code>$b</code>给子程序和语句块。就像<code>$_</code>一样，<code>$a</code>和<code>$b</code>实际上是当一对值需要比较时被<em>填入</em>的全局变量。</p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>截止目前你已经看到过不少内置函数了：<code>print</code>、<code>sort</code>、<code>map</code>、<code>grep</code>、<code>keys</code>、<code>scalar</code>等等。内置函数是Perl的一大优势，它们：</p>
<ul>
<li>数不胜数</li>
<li>非常实用</li>
<li>有<a href="http://perldoc.perl.org/perlfunc.html" target="_blank" rel="noopener">全面的文档支持</a></li>
<li>语法上差异很大，因此使用前请先查文档</li>
<li>有时接受正则表达式作为参数</li>
<li>有时接受一整块代码作为参数</li>
<li>有时参数之间不需要逗号分隔</li>
<li>有时消耗任意数量由逗号分隔的参数，有时则不时</li>
<li>有时在提供的参数不足的情况下会填入默认值</li>
<li>通常不要求参数列表用括号包围，除非会产生歧义</li>
</ul>
<p>关于内置函数最好的建议是<strong>知道它们的存在</strong>，浏览一下文档以供将来参考。如果你在完成某个任务并且发现那工作太底层也太常用了，以至于你觉得别人肯定已经做过多次了，那么事实往往的确如此。</p>
<h3 id="用户自定义的子程序"><a href="#用户自定义的子程序" class="headerlink" title="用户自定义的子程序"></a>用户自定义的子程序</h3><p>子程序用<code>sub</code>关键字来声明。相比内置函数，自定义子程序总是接受一种输入：一个scalar的列表。当然这个列表可以只包含一个元素，甚至为空。一个scalar会被转换成包含一个scalar的列表来处理，而一个有N个元素的hash会被转换成包含2N个元素的列表来处理。</p>
<p>尽管括号可以省略，我们还是应该总是在调用子程序的时候加上括号，即使不提供任何参数，读者就能更容易发现子程序的调用。</p>
<p>在子程序中，参数被保存在<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置array变量</a><code>@_</code>中。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sub hyphenate &#123;</span><br><span class="line"></span><br><span class="line">  # 从array中取出第一个参数，忽略其他</span><br><span class="line">  my $word &#x3D; shift @_;</span><br><span class="line"></span><br><span class="line">  # 聪明过头的list comprehension</span><br><span class="line">  $word &#x3D; join &quot;-&quot;, map &#123; substr $word, $_, 1 &#125; (0 .. (length $word) - 1);</span><br><span class="line">  return $word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print hyphenate(&quot;exterminate&quot;); # &quot;e-x-t-e-r-m-i-n-a-t-e&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Perl以引用方式调用"><a href="#Perl以引用方式调用" class="headerlink" title="Perl以引用方式调用"></a>Perl以引用方式调用</h4><p>不像其他主流编程语言，Perl以引用方式调用子程序（译者注：以引用方式传递参数）。这意味着子程序中用到的变量或值不是实参的副本，它们<em>本身就是</em>实参。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my $x &#x3D; 7;</span><br><span class="line"></span><br><span class="line">sub reassign &#123;</span><br><span class="line">  $_[0] &#x3D; 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reassign($x);</span><br><span class="line">print $x; # &quot;42&quot;</span><br></pre></td></tr></table></figure>

<p>如果你尝试这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reassign(8);</span><br></pre></td></tr></table></figure>

<p>程序就会因为错误而终止运行，因为<code>reassign()</code>的第一行就相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 &#x3D; 42;</span><br></pre></td></tr></table></figure>

<p>这显然是非常荒谬的。</p>
<p>这边可以学到的经验教训是，在子程序中你总是应该在使用参数之前将它们提取出来。</p>
<h4 id="提取参数"><a href="#提取参数" class="headerlink" title="提取参数"></a>提取参数</h4><p>我们有不止一种方法来提取<code>@_</code>中的参数，但总有一些方法比其他方法更好。</p>
<p>下面的示例子程序<code>left_pad</code>在字符串左边填充某个字符直到达到需要的长度。（<code>x</code>函数将同一个字符串的多个副本连接起来。）（注意：为了简化问题，这些子程序都缺乏必要的错误检查，比如确保填充字符串长度为1，检查要求的宽度是否大于等于字符串的长度，需要的参数是否都提供了。）</p>
<p><code>left_pad</code>通常就像下面这样调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print left_pad(&quot;hello&quot;, 10, &quot;+&quot;); # &quot;+++++hello&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>逐个抽取<code>@_</code>中的参数很有效，但也并不是那么地美观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">	my $oldString &#x3D; $_[0];</span><br><span class="line">	my $width     &#x3D; $_[1];</span><br><span class="line">	my $padChar   &#x3D; $_[2];</span><br><span class="line">	my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">	return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于不超过4个参数的情况推荐用<code>shift</code>通过移出元素的方法来提取<code>@_</code>中的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">	my $oldString &#x3D; shift @_;</span><br><span class="line">	my $width     &#x3D; shift @_;</span><br><span class="line">	my $padChar   &#x3D; shift @_;</span><br><span class="line">	my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">	return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有给<code>shift</code>函数提供array参数，它就会默认对<code>@_</code>进行操作。这种用法很常见：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">	my $oldString &#x3D; shift;</span><br><span class="line">	my $width     &#x3D; shift;</span><br><span class="line">	my $padChar   &#x3D; shift;</span><br><span class="line">	my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">	return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超过4个参数以后就很难搞清楚参数的哪部分被赋值给谁了。</p>
</li>
<li><p>你也可以一次性把所有<code>@_</code>中的参数提取出来。仍然是适用于少于4个参数的情形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">	my ($oldString, $width, $padChar) &#x3D; @_;</span><br><span class="line">	my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">	return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于有大量参数的子程序，或者有些参数可选或无法和其他参数组合使用的子程序，最佳实践是要求用户构造参数的hash来调用这个子程序，然后将整个<code>@_</code>放回到一个hash中。用这种方法，我们子程序的调用会看起来会有点不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print left_pad(&quot;oldString&quot; &#x3D;&gt; &quot;pod&quot;, &quot;width&quot; &#x3D;&gt; 10, &quot;padChar&quot; &#x3D;&gt; &quot;+&quot;);</span><br></pre></td></tr></table></figure>

<p>而子程序自身就变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">	my %args &#x3D; @_;</span><br><span class="line">	my $newString &#x3D; ($args&#123;&quot;padChar&quot;&#125; x ($args&#123;&quot;width&quot;&#125; - length $args&#123;&quot;oldString&quot;&#125;)) . $args&#123;&quot;oldString&quot;&#125;;</span><br><span class="line">	return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>就像其他Perl表达式一样，子程序调用也会根据上下文表现出不同的行为。你可以用<code>wantarray</code>函数（也许我们应该叫它<code>wantlist</code>（译者注：上下文可以是scalar或者列表，不是一个array或者hash），不过不要在意这些细节）来检测子程序是在什么上下文中被调用的，这样就可以返回恰当类型的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub contextualSubroutine &#123;</span><br><span class="line">	# 调用这里需要一个列表，那么就返回一个列表</span><br><span class="line">	return (&quot;Everest&quot;, &quot;K2&quot;, &quot;Etna&quot;) if wantarray;</span><br><span class="line"></span><br><span class="line">	# 调用者需要一个scalar，那么就返回一个scalar</span><br><span class="line">	return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my @array &#x3D; contextualSubroutine();</span><br><span class="line">print @array; # &quot;EverestK2Etna&quot;</span><br><span class="line"></span><br><span class="line">my $scalar &#x3D; contextualSubroutine();</span><br><span class="line">print $scalar; # &quot;3&quot;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>如果你已经知道下面说的这些和Perl无关的事实，那抱歉我还是要多说几句。每当一个进程在Windows或Linux系统（以及其他大部分的系统）中结束，它将产生一个16位的<em>状态字</em>，高8位表示<em>返回码</em>，值落在0到255之间，其中0约定俗成地表示无条件的成功，而其他值则表示不同程度的失败，另外8位则少有人关心，它们“表示了错误的原因，比如因为收到了信号或者产生core dump信息”。</p>
<p>你可以调用<code>exit</code>，用你选择的返回码（0到255之间）退出Perl脚本。</p>
<p>Perl提供了不止一种方法通过一句调用语句来启动一个子进程、等待子进程执行结束、然后继续解释执行当前的脚本。无论用那种方法，你会发现紧接着，子进程结束时返回的状态字已经被填入了<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置scalar变量</a><code>$?</code>中。你可以通过取出16位中的高8位来得到返回码：<code>$? &gt;&gt; 8</code>。</p>
<p>我们可以用<code>system</code>函数调用另一个程序，并且提供一个参数列表，<code>system</code>的返回值与填入<code>$?</code>的值一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $rc &#x3D; system &quot;perl&quot;, &quot;anotherscript.pl&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;;</span><br><span class="line">$rc &gt;&gt;&#x3D; 8;</span><br><span class="line">print $rc; # &quot;37&quot;</span><br></pre></td></tr></table></figure>

<p>另一种选择，我们也可以用反引号````在命令行中运行一条真正的命令，并且捕获它的标准输出。在scalar上下文中，整个输出被当做一整个字符串返回返回，而在列表上下文中，整个输出按一个字符串的array返回，其中每个字符串是输出中的一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $text &#x3D; &#96;perl anotherscript.pl foo bar baz&#96;;</span><br><span class="line">print $text; # &quot;foobarbaz&quot;</span><br></pre></td></tr></table></figure>

<p>如果<code>anotherscript.pl</code>包含形如下面这样的代码，你就能看到上面这种结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print @ARGV;</span><br><span class="line">exit 37;</span><br></pre></td></tr></table></figure>

<h3 id="文件和文件句柄"><a href="#文件和文件句柄" class="headerlink" title="文件和文件句柄"></a>文件和文件句柄</h3><p>Scalar变量除了能够包含数值、字符串、引用或者<code>undef</code>，还能包含一个<em>文件句柄</em>。文件句柄本质上就是对于某个文件中某个位置的引用。</p>
<p>用<code>open</code>可以把一个scalar变量编程文件句柄。我们必须给<code>open</code>提供一个<em>打开模式</em>。模式<code>&lt;</code>表示我们想要读取这个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my $f &#x3D; &quot;text.txt&quot;;</span><br><span class="line">my $result &#x3D; open my $fh, &quot;&lt;&quot;, $f;</span><br><span class="line"></span><br><span class="line">if(!$result) &#123;</span><br><span class="line">	die &quot;Couldn&#39;t open &#39;&quot;.$f.&quot;&#39; for reading because: &quot;.$!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果成功，<code>open</code>返回true，否则返回false，并且错误消息会被填入内置变量<code>$!</code>。就像你在上面的代码里看到的，你总是应该检查<code>open</code>操作是否成功完成了，不过像那样检查真是冗长乏味，更常见的写法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(my $fh, &quot;&lt;&quot;, $f) || die &quot;Couldn&#39;t open &#39;&quot;.$f.&quot;&#39; for reading because: &quot;.$!;</span><br></pre></td></tr></table></figure>

<p>注意，你需要在<code>open</code>的参数列表两边加上括号。</p>
<p>要从文件句柄中读取一行，可以用内置函数<code>readline</code>，<code>readline</code>返回一整行文本，并且结尾有一个换行符（除了文件末尾的那行可能例外），如果已经读到文件末尾则返回<code>undef</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">	my $line &#x3D; readline $fh;</span><br><span class="line">	last unless defined $line;</span><br><span class="line">	# 处理$line...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用<code>chomp</code>移除末尾可能存在的换行符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chomp $line;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>chomp</code>直接作用于<code>$line</code>上，因此<code>$line = chomp $line</code>可能不会得到你想要的东西。</p>
<p>你也可以用<code>eof</code>来检测是否已经读到文件末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(!eof $fh) &#123;</span><br><span class="line">	my $line &#x3D; readline $fh;</span><br><span class="line">	# 处理$line...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过使用<code>while(my $line = readline $fh)</code>的时候要小心了，因为如果<code>$line</code>的内容恰好是<code>&quot;0&quot;</code>，循环可能过早结束。如果你想要这样写，Perl提供了<code>&lt;&gt;</code>功能上更安全的运算符，你可以用它包围<code>readline</code>。这种写法很常见而且也非常安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(my $line &#x3D; &lt;$fh&gt;) &#123;</span><br><span class="line">	# 处理$line...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(&lt;$fh&gt;) &#123;</span><br><span class="line">	# 处理$_...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要写一个文件，首先你需要另一种打开模式。模式<code>&gt;</code>表示我们想要写入这个文件。（如果目标文件存在的话，<code>&gt;</code>会清空它，如果你只是想附加在文件的原有内容后面，你应该用模式<code>&gt;&gt;</code>。）然后，将文件句柄作为<code>print</code>方法的第0个参数提供就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(my $fh2, &quot;&gt;&quot;, $f) || die &quot;Couldn&#39;t open &#39;&quot;.$f.&quot;&#39; for writing because: &quot;.$!;</span><br><span class="line">print $fh2 &quot;The eagles have left the nest&quot;;</span><br></pre></td></tr></table></figure>

<p>请注意在<code>$fh2</code>和后面的参数之间没有逗号。</p>
<p>文件句柄在超出它们的作用域以后会自动关闭，如果你想主动关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close $fh2;</span><br><span class="line">close $fh;</span><br></pre></td></tr></table></figure>

<p>有三个文件句柄以全局常量形式存在：<code>STDIN</code>、<code>STDOUT</code>和<code>STDERR</code>，它们在脚本开始时就被自动打开。要读取一行用户的输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $line &#x3D; &lt;STDIN&gt;;</span><br></pre></td></tr></table></figure>

<p>如果只是等待用户按回车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;STDIN&gt;;</span><br></pre></td></tr></table></figure>

<p>调用<code>&lt;&gt;</code>而不提供文件句柄参数，表示从<code>STDIN</code>或者在Perl脚本启动时指定的参数指向的文件中读取。</p>
<p>你可能已经知道了，如果不提供文件句柄，<code>print</code>默认会打印到<code>STDOUT</code>。</p>
<h4 id="文件检测"><a href="#文件检测" class="headerlink" title="文件检测"></a>文件检测</h4><p>内置函数<code>-e</code>用于测试文件是否存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;what&quot; unless -e &quot;&#x2F;usr&#x2F;bin&#x2F;perl&quot;;</span><br></pre></td></tr></table></figure>

<p>内置函数<code>-d</code>用于测试文件是否是目录。</p>
<p>内置函数<code>-f</code>用于测试文件是否是普通文件。</p>
<p>这只是<a href="http://perldoc.perl.org/functions/-X.html" target="_blank" rel="noopener">一大波形如<code>-X</code>的函数</a>中的三个，其中<code>X</code>是某些小写或大写字母。这类函数被称作<em>文件检测函数</em>。请注意字母前面的减号，用Google搜索的时候，减号表示从搜索结果中排除包含这个词的结果，这样就导致很难用Google搜索文件检测函数了！用“Perl file test”来搜索就好。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>除了Perl以外，正则表达式也被应用在许多其他的语言和工具中。Perl的核心正则表达式语法基本上和其他地方别无二致，不过Perl完整的正则表达式功能复杂到令人发指，并且难以理解。我能给的最好的建议就是尽可能避免引入不必要的复杂性。</p>
<p>用<code>=~ m//</code>运算符进行正则表达式匹配。在scalar上下文中，<code>=~ m//</code>在成功时返回true，而失败是返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;Hello world&quot;;</span><br><span class="line">if($string &#x3D;~ m&#x2F;(\w+)\s+(\w+)&#x2F;) &#123;</span><br><span class="line">	print &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圆括号表示匹配组，匹配成功以后，匹配组被填入内置变量<code>$1</code>、<code>$2</code>、<code>$3</code>……：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print $1; # &quot;Hello&quot;</span><br><span class="line">print $2; # &quot;world&quot;</span><br></pre></td></tr></table></figure>

<p>在列表上下文中，<code>=~ m//</code>返回<code>$1</code>、<code>$2</code>……组成的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;colourless green ideas sleep furiously&quot;;</span><br><span class="line">my @matches &#x3D; $string &#x3D;~ m&#x2F;(\w+)\s+((\w+)\s+(\w+))\s+(\w+)\s+(\w+)&#x2F;;</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, map &#123; &quot;&#39;&quot;.$_.&quot;&#39;&quot; &#125; @matches;</span><br><span class="line"># prints &quot;&#39;colourless&#39;, &#39;green ideas&#39;, &#39;green&#39;, &#39;ideas&#39;, &#39;sleep&#39;, &#39;furiously&#39;&quot;</span><br></pre></td></tr></table></figure>

<p>用<code>=~ s///</code>运算符进行正则表达式替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;Good morning world&quot;;</span><br><span class="line">$string &#x3D;~ s&#x2F;world&#x2F;Vietnam&#x2F;;</span><br><span class="line">print $string; # &quot;Good morning Vietnam&quot;</span><br></pre></td></tr></table></figure>

<p>请注意<code>$string</code>的内容发生了怎样的改变。你必须在<code>=~ s///</code>运算符左边提供一个scalar变量，如果你提供了字面字符串，会返回一个错误。</p>
<p><code>/g</code>标志表示“全局匹配”（译者注：原文“group match”，应为“global match”更为确切）。</p>
<p>在scalar上下文中，每次<code>=~ m//g</code>调用都会返回下一个匹配项，成功是返回true，而失败时返回false。然后你还是可以通过<code>$1</code>等等来得到匹配的组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;a tonne of feathers or a tonne of bricks&quot;;</span><br><span class="line">while($string &#x3D;~ m&#x2F;(\w+)&#x2F;g) &#123;</span><br><span class="line">  print &quot;&#39;&quot;.$1.&quot;&#39;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在列表上下文中，<code>=~ m//g</code>一次性返回所有匹配的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @matches &#x3D; $string &#x3D;~ m&#x2F;(\w+)&#x2F;g;</span><br><span class="line">print join &quot;, &quot;, map &#123; &quot;&#39;&quot;.$_.&quot;&#39;&quot; &#125; @matches;</span><br></pre></td></tr></table></figure>

<p>每次<code>=~ s///g</code>调用会进行一次全局的查找/替换，并且返回匹配的次数。在这里，我们把所有元音字母用字母“r”替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先不用&#x2F;g进行一次替换</span><br><span class="line">$string &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;;</span><br><span class="line">print $string; # &quot;r tonne of feathers or a tonne of bricks&quot;</span><br><span class="line"></span><br><span class="line"># 再替换一次</span><br><span class="line">$string &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;;</span><br><span class="line">print $string; # &quot;r trnne of feathers or a tonne of bricks&quot;</span><br><span class="line"></span><br><span class="line"># 用&#x2F;g全部替换</span><br><span class="line">$string &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;g;</span><br><span class="line">print $string, &quot;\n&quot;; # &quot;r trnnr rf frrthrrs rr r trnnr rf brrcks&quot;</span><br></pre></td></tr></table></figure>

<p><code>/i</code>标志表示查找替换对于大小写不敏感。</p>
<p><code>/x</code>标志允许正则表达式中包含空白符（例如换行符）和注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello world&quot; &#x3D;~ m&#x2F;</span><br><span class="line">  (\w+) # one or more word characters</span><br><span class="line">  [ ]   # single literal space, stored inside a character class</span><br><span class="line">  world # literal &quot;world&quot;</span><br><span class="line">&#x2F;x;</span><br><span class="line"></span><br><span class="line"># returns true</span><br></pre></td></tr></table></figure>

<h3 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h3><p>在Perl中，模块（module）和包（package）是不同的东西。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p><em>模块</em>是你可以<em>包含</em>在另一个Perl文件（脚本或模块）中的一个<code>.pm</code>文件，是与<code>.pl</code>Perl脚本语法完全相同的文本文件。一个示例模块文件可能位于<code>C:\foo\bar\baz\Demo\StringUtils.pm</code>或者<code>/foo/bar/baz/Demo/StringUtils.pm</code>，并且有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">sub zombify &#123;</span><br><span class="line">	my $word &#x3D; shift @_;</span><br><span class="line">	$word &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;g;</span><br><span class="line">	return $word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure>

<p>因为模块在被加载时会自顶向下执行，你需要在结尾处返回一个true表示加载成功。</p>
<p>为了让Perl解释器能够找到这些Perl模块文件，调用<code>perl</code>程序前，包含它们的目录名需要被添加到环境变量<code>PERL5LIB</code>中。列出包含这些模块的根目录，而不是其中的某些子目录或者模块本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PERL5LIB&#x3D;C:\foo\bar\baz;%PERL5LIB%</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PERL5LIB&#x3D;&#x2F;foo&#x2F;bar&#x2F;baz:$PERL5LIB</span><br></pre></td></tr></table></figure>

<p>一旦Perl模块被创建并且<code>perl</code>知道如何找到它以后，你就可以使用内置函数<code>require</code>在Perl脚本中查找并执行它。比如，调用<code>require Demo::StringUtils</code>使Perl解释器去逐个查找所有列在<code>PERL5LIB</code>中的目录，看是否有叫做<code>Demo/StringUtils.pm</code>的文件。我们的示例脚本可以叫做<code>main.pl</code>，并且包含以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">require Demo::StringUtils;</span><br><span class="line"></span><br><span class="line">print zombify(&quot;i want brains&quot;); # &quot;r wrnt brrrns&quot;</span><br></pre></td></tr></table></figure>

<p><em>注意，在这里我们用双冒号<code>::</code>作为目录的分隔符。</em></p>
<p>现在问题来了：如果<code>main.pl</code>包含很多<code>require</code>调用，而且每个被加载的模块又包含更多<code>require</code>调用，那我们要找到<code>zombify()</code>子程序最初的定义就太困难了。解决方案是使用包。</p>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p><em>包</em>是用来声明子程序的命名空间。所有的子程序默认都被声明在当前包中，而程序开始执行的时候，你位于<code>main</code>包中，不过你可以用内置函数<code>package</code>来切换包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">sub subroutine &#123;</span><br><span class="line">	print &quot;universe&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package Food::Potatoes;</span><br><span class="line"></span><br><span class="line"># 没有冲突：</span><br><span class="line">sub subroutine &#123;</span><br><span class="line">	print &quot;kingedward&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意，我们这里使用双冒号<code>::</code>作为命名空间的分隔符。</em></p>
<p>当你调用一个子程序的时候，你默认会调用当前包中的子程序。你也可以显示指定包的名字，我们继续上面的脚本，看看会发生什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subroutine();                 # &quot;kingedward&quot;</span><br><span class="line">main::subroutine();           # &quot;universe&quot;</span><br><span class="line">Food::Potatoes::subroutine(); # &quot;kingedward&quot;</span><br></pre></td></tr></table></figure>

<p>所以对上面描述的问题的一个符合逻辑的解决方案就是把<code>C:\foo\bar\baz\Demo\StringUtils.pm</code>或者<code>/foo/bar/baz/Demo/StringUtils.pm</code>改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Demo::StringUtils;</span><br><span class="line"></span><br><span class="line">sub zombify &#123;</span><br><span class="line">	my $word &#x3D; shift @_;</span><br><span class="line">	$word &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;g;</span><br><span class="line">	return $word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure>

<p>然后把<code>main.pl</code>改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">require Demo::StringUtils;</span><br><span class="line"></span><br><span class="line">print Demo::StringUtils::zombify(&quot;i want brains&quot;); # &quot;r wrnt brrrns&quot;</span><br></pre></td></tr></table></figure>

<p>下面这些内容可要仔细阅读了。</p>
<p>在Perl语言中包和模块是彼此独立完全不同的两个功能，它们恰好都是用双冒号作为分隔符根本就是个掩人耳目的把戏。在一个脚本或者模块中多次切换包是可行的，在不用位置的多个文件中使用同一个包名也是可行的。调用<code>require Foo::Bar</code><em>并不会</em>去查找并且加载一个有<code>package Foo::Bar</code>的文件，也不一定会加载定义在<code>Foo::Bar</code>命名空间里的子程序。调用<code>require Foo::Bar</code>仅仅表示加载一个名为<code>Foo/Bar.pm</code>的问题，与其中有什么包的声明没有<em>任何</em>关系，也许那个文件中声明了<code>package Baz::Qux</code>和其他乱七八糟的内容。</p>
<p>同样的，调用<code>Baz::Qux::processThis()</code>子程序并不一定要声明在名叫<code>Baz/Qux.pm</code>的文件里，它可能被定义在<em>任何地方</em>。</p>
<p>分离这两种功能可能是Perl中最糟糕的一个设计，而如果把它们视作分开的功能，将带来混乱，以及让人抓狂的代码。值得庆幸的是，主流的Perl程序员总是遵循下面两个规则：</p>
<ol>
<li><strong>Perl脚本（<code>.pl</code>文件）不应该包含<code>package</code>声明。</strong></li>
<li><strong>Perl模块（<code>.pm</code>文件）必须包含且仅包含一个<code>package</code>声明，且包名与它的文件名、所在的位置一致。</strong>例如，模块<code>Demo/StringUtils.pm</code>必须由<code>package Demo::StringUtils</code>开头。</li>
</ol>
<p>因此，你会发现实际工作中，绝大部分由可靠的第三方提供的“包”和“模块”的概念是<em>可以</em>交换混用的。然而，很重要的是，你千万不能把这个当做承诺，因为将来有一天你<em>一定会</em>碰上一个疯子写的代码。</p>
<h3 id="Perl的面向对象"><a href="#Perl的面向对象" class="headerlink" title="Perl的面向对象"></a>Perl的面向对象</h3><p>Perl不是面向对象编程的最佳选择，Perl的面向对象机制是后来嫁接进去的，下面我们就看看是怎么回事。</p>
<ul>
<li><em>对象</em>只是一个引用（也就是一个scalar变量），它恰好知道自己属于哪个类。要告诉一个引用它所指向的内容属于哪个类，使用<code>bless</code>。要知道引用所指向的内容属于哪个类（如果有的话），使用<code>ref</code>。</li>
<li><em>方法</em>只是一个子程序，接受对象（或者对于类的方法，就是包名）作为第一个参数。使用<code>$obj-&gt;method()</code>可以调用对象的方法，用<code>Package::Name-&gt;method()</code>可以调用类的方法。（译者注：所谓类的方法，在其他语言里就相当于类的静态方法。）</li>
<li><em>类</em>就是包含一组方法的包。</li>
</ul>
<p>下面有个简短的例子来帮助我们弄清楚这些概念。示例模块<code>Animal.pm</code>包含<code>Animal</code>类，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Animal;</span><br><span class="line"></span><br><span class="line">sub eat &#123;</span><br><span class="line">	# 第一个参数总是操作所基于的对象</span><br><span class="line">	my $self &#x3D; shift @_;</span><br><span class="line"></span><br><span class="line">	foreach my $food ( @_ ) &#123;</span><br><span class="line">		if($self-&gt;can_eat($food)) &#123;</span><br><span class="line">			print &quot;Eating &quot;, $food;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			print &quot;Can&#39;t eat &quot;, $food;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 就这个参数来说，假设动物可以吃任何东西</span><br><span class="line">sub can_eat &#123;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure>

<p>然后我们可以这样使用这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require Animal;</span><br><span class="line"></span><br><span class="line">my $animal &#x3D; &#123;</span><br><span class="line">	&quot;legs&quot;   &#x3D;&gt; 4,</span><br><span class="line">	&quot;colour&quot; &#x3D;&gt; &quot;brown&quot;,</span><br><span class="line">&#125;;                       # $animal是一个普通的hash的引用</span><br><span class="line">print ref $animal;       # &quot;HASH&quot;</span><br><span class="line">bless $animal, &quot;Animal&quot;; # 现在它是&quot;Animal&quot;类的对象</span><br><span class="line">print ref $animal;       # &quot;Animal&quot;</span><br></pre></td></tr></table></figure>

<p>注意：任何引用都可以被转换（bless）成任何类的对象。需要由你来保证（1）这个引用指向的内容可以被当做这个类的对象来使用，并且（2）被转换成的这个类存在，并且已经被加载了。</p>
<p>你仍然可以按以前的方式操作这个hash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Animal has &quot;, $animal-&gt;&#123;&quot;legs&quot;&#125;, &quot; leg(s)&quot;;</span><br></pre></td></tr></table></figure>

<p>但你也可以同样用<code>-&gt;</code>运算符调用这个对象的方法，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$animal-&gt;eat(&quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;);</span><br></pre></td></tr></table></figure>

<p>最后那句调用等价于<code>Animal::eat($animal, &quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;)</code>。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数是这个类返回新对象的方法。如果你需要，声明一个就是了，用你喜欢的任何名字都可以。对于类的方法，第一个参数是类名而不是一个对象，在这个例子里就是<code>&quot;Animal&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Animal;</span><br><span class="line"></span><br><span class="line">sub new &#123;</span><br><span class="line">	my $class &#x3D; shift @_;</span><br><span class="line">	return bless &#123; &quot;legs&quot; &#x3D;&gt; 4, &quot;colour&quot; &#x3D;&gt; &quot;brown&quot; &#125;, $class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ...etc.</span><br></pre></td></tr></table></figure>

<p>然后像下面这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $animal &#x3D; Animal-&gt;new();</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>要创建一个类继承自基类，用<code>use parent</code>，假设我们给<code>Animal</code>创建一个子类叫<code>Koala</code>，位于<code>Koala.pm</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Koala;</span><br><span class="line"></span><br><span class="line"># 继承自Animal</span><br><span class="line">use parent (&quot;Animal&quot;);</span><br><span class="line"></span><br><span class="line"># 重载一个方法</span><br><span class="line">sub can_eat &#123;</span><br><span class="line">	my $self &#x3D; shift @_; # 没有使用，你也可以直接在这里写&quot;shift @_;&quot;</span><br><span class="line">	my $food &#x3D; shift @_;</span><br><span class="line">	return $food eq &quot;eucalyptus&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure>

<p>下面是一些示例程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">require Koala;</span><br><span class="line"></span><br><span class="line">my $koala &#x3D; Koala-&gt;new();</span><br><span class="line"></span><br><span class="line">$koala-&gt;eat(&quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;); # 只吃eucalyptus</span><br></pre></td></tr></table></figure>

<p>最后那个方法调用尝试执行<code>Koala::eat($koala, &quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;)</code>，但子程序<code>eat()</code>并没有在<code>Koala</code>包里定义。然而，因为<code>Koala</code>有父类<code>Animal</code>，Perl解释器会再尝试调用<code>Animal::eat($koala, &quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;)</code>，这回没问题。请注意<code>Animal</code>类是如何自动被<code>Koala.pm</code>加载的。</p>
<p>因为<code>use parent</code>接受一组父类的名字，所以Perl支持多重继承，当然也就包含了它所带来的所有好处和噩梦。</p>
<h3 id="BEGIN块"><a href="#BEGIN块" class="headerlink" title="BEGIN块"></a><code>BEGIN</code>块</h3><p><code>BEGIN</code>块在<code>perl</code>解释完这个代码块以后就立即被执行，甚至在文件剩下的部分被解释之前，而这个代码块在运行时则被忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print &quot;This gets printed second&quot;;</span><br><span class="line"></span><br><span class="line">BEGIN &#123;</span><br><span class="line">	print &quot;This gets printed first&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print &quot;This gets printed third&quot;;</span><br></pre></td></tr></table></figure>

<p><code>BEGIN</code>块总是首先执行。如果你创建了多个<code>BEGIN</code>块（别这么做），它们将按照解释器解释它们的顺序自上而下执行。<code>BEGIN</code>即使出现在脚本中间（别这么做）或者脚本最后（也别这么做），它也会首先被执行。<strong>不要搞乱自然的代码执行顺序，总是把<code>BEGIN</code>块放在开头！</strong></p>
<p><code>BEGIN</code>块在解释完后立即被执行，执行完毕以后将从这个<code>BEGIN</code>块结束处继续<em>解释</em>剩下的代码。如果<code>BEGIN</code>块以外的任何代码被执行了，那么整个脚本或者模块就已经被解释了一遍，且仅有一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print &quot;This &#39;print&#39; statement gets parsed successfully but never executed&quot;;</span><br><span class="line"></span><br><span class="line">BEGIN &#123;</span><br><span class="line">	print &quot;This gets printed first&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print &quot;This, also, is parsed successfully but never executed&quot;;</span><br><span class="line"></span><br><span class="line">...because e4h8v3oitv8h4o8gch3o84c3 there is a huge parsing error down here.</span><br></pre></td></tr></table></figure>

<p>（译者注：上面程序的最后一行不是注释，作者写最后一行是构造一个语法错误，因而造成BEGIN块在解释到这里之前就已经被执行，而BEGIN块执行完毕以后继续恢复解释，一旦遇上语法错误，脚本其他部分将不会再被执行。）</p>
<p>因为它们在脚本编译时就执行，<code>BEGIN</code>块即使在条件分支中也<em>仍然</em>会在编译时就运行，哪怕条件将被判定为false，因为在那时条件<em>还根本没有被求值</em>，甚至<em>可能永远不会被求值</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(0) &#123;</span><br><span class="line">	BEGIN &#123;</span><br><span class="line">		print &quot;This will definitely get printed&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	print &quot;Even though this won&#39;t&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不要把<code>BEGIN</code>块放在条件分支里！</strong>如果你要在编译时做一些条件判断，把这个条件判断放在<code>BEGIN</code>块<em>里面</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">	if($condition) &#123;</span><br><span class="line">		# etc.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="use"><a href="#use" class="headerlink" title="use"></a><code>use</code></h3><p>好，现在让我们来理解一下包、模块、类的方法和<code>BEGIN</code>块那模棱两可的行为以及语义，我会来解释一下超级常见的<code>use</code>函数。</p>
<p>下面三条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use Caterpillar (&quot;crawl&quot;, &quot;pupate&quot;);</span><br><span class="line">use Caterpillar ();</span><br><span class="line">use Caterpillar;</span><br></pre></td></tr></table></figure>

<p>分别和下面的三段等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">	require Caterpillar;</span><br><span class="line">	Caterpillar-&gt;import(&quot;crawl&quot;, &quot;pupate&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">	require Caterpillar;</span><br><span class="line">&#125;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">	require Caterpillar;</span><br><span class="line">	Caterpillar-&gt;import();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不，这三个例子并没有放错顺序，只是Perl比较笨罢了。</li>
<li><code>use</code>只是<code>BEGIN</code>块的伪装，同样的警告对此也适用。<code>use</code> 语句必须总是放在文件开头，并且<strong>永远不要放在条件分支里</strong>。</li>
<li><code>import()</code>并不是Perl的内置函数，它只是一个<strong>用户自定义的类方法</strong>。定义或者继承<code>import()</code>函数的重任就落在写<code>Caterpillar</code>这个包的程序员身上了。这个方法理论上可以接受任何东西作为参数，也可以对参数做任何操作。<code>use Caterpillar;</code>可以做任何事情，你需要查询<code>Caterpillar.pm</code>的文档来判断到底会发生什么。</li>
<li>请注意<code>require Caterpillar</code>是如何加载一个名为<code>Caterpillar.pm</code>的<strong>模块</strong>的，而<code>Caterpillar-&gt;import()</code>则调用定义在<code>Caterpillar</code><strong>包</strong>里的子程序<code>import()</code>。我们只能一起期待这里的模块和包是一致的！</li>
</ul>
<h3 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h3><p>定义一个<code>import()</code>方法最常见的办法是从<a href="http://perldoc.perl.org/Exporter.html" target="_blank" rel="noopener">Exporter</a>模块继承下来。Exporter是一个核心模块，也是Perl语言中成为<em>事实标准</em>的核心功能。在Exporter的<code>import()</code>实现中，你传入的参数列表将被认为是子程序名字的列表，当一个子程序被<code>import()</code>，它在当前包和原来所在的包里就都可以被使用了。</p>
<p>用一个例子最能帮助理解这个概念。<code>Caterpillar.pm</code>的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Caterpillar;</span><br><span class="line"></span><br><span class="line"># 继承自Exporter</span><br><span class="line">use parent (&quot;Exporter&quot;);</span><br><span class="line"></span><br><span class="line">sub crawl  &#123; print &quot;inch inch&quot;;   &#125;</span><br><span class="line">sub eat    &#123; print &quot;chomp chomp&quot;; &#125;</span><br><span class="line">sub pupate &#123; print &quot;bloop bloop&quot;; &#125;</span><br><span class="line"></span><br><span class="line">our @EXPORT_OK &#x3D; (&quot;crawl&quot;, &quot;eat&quot;);</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure>

<p>包变量<code>@EXPORT_OK</code>应该包含子程序名字的列表。</p>
<p>另一块代码就可以通过名字来<code>import()</code>这些子程序，一般使用<code>use</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use Caterpillar (&quot;crawl&quot;);</span><br><span class="line"></span><br><span class="line">crawl(); # &quot;inch inch&quot;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，当前包是<code>main</code>所以<code>crawl()</code>实际上是调用了<code>main::crawl()</code>，（因为被导入了）映射到<code>Caterpillar::crawl()</code>。</p>
<p>注意：不管<code>@EXPORT_OK</code>的内容是什么，通过“常规写法”使用这些函数总是可以的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use Caterpillar (); # 没有提供任何子程序名，import()不会被调用</span><br><span class="line"></span><br><span class="line"># 然而……</span><br><span class="line">Caterpillar::crawl();  # &quot;inch inch&quot;</span><br><span class="line">Caterpillar::eat();    # &quot;chomp chomp&quot;</span><br><span class="line">Caterpillar::pupate(); # &quot;bloop bloop&quot;</span><br></pre></td></tr></table></figure>

<p>Perl没有私有方法，习惯上在希望私有的方法名前面有一个或者两个下划线。</p>
<h4 id="EXPORT"><a href="#EXPORT" class="headerlink" title="@EXPORT"></a><code>@EXPORT</code></h4><p>Exporter模块还定义了一个包变量叫<code>@EXPORT</code>，也包含一组子程序名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Caterpillar;</span><br><span class="line"></span><br><span class="line"># 继承自Exporter</span><br><span class="line">use parent (&quot;Exporter&quot;);</span><br><span class="line"></span><br><span class="line">sub crawl  &#123; print &quot;inch inch&quot;;   &#125;</span><br><span class="line">sub eat    &#123; print &quot;chomp chomp&quot;; &#125;</span><br><span class="line">sub pupate &#123; print &quot;bloop bloop&quot;; &#125;</span><br><span class="line"></span><br><span class="line">our @EXPORT &#x3D; (&quot;crawl&quot;, &quot;eat&quot;, &quot;pupate&quot;);</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure>

<p>如果没有给<code>import()</code>传入任何参数，<code>@EXPORT</code>中写出的子程序将全部被导出，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use Caterpillar; # 调用import()但不提供参数</span><br><span class="line"></span><br><span class="line">crawl();  # &quot;inch inch&quot;</span><br><span class="line">eat();    # &quot;chomp chomp&quot;</span><br><span class="line">pupate(); # &quot;bloop bloop&quot;</span><br></pre></td></tr></table></figure>

<p>不过我们又回到了那种情况，没有其他提示的话，我们很难知道<code>crawl()</code>原先是在哪儿定义的。这件事情有两个寓意：</p>
<ol>
<li>当我们用Exporter创建模块的时候，不要用<code>@EXPORT</code>来导出子程序，总是让调用者以“常规方法”调用子程序，或者显式地<code>import()</code>它们（使用比如：<code>use Caterpillar (&quot;crawl&quot;)</code>提供了一条很强的线索，告诉我们可以从<code>Caterpillar.pm</code>中找到<code>crawl()</code>的定义）。</li>
<li>当<code>use</code>一个使用Exporter的模块时，总是显式写明你希望<code>import()</code>的子程序，如果你不想<code>import()</code>任何子程序，而是用常规方法引用它们，你必须显式提供一个空的列表：<code>use Caterpillar ()</code>。</li>
</ol>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li><p>核心模块<a href="http://perldoc.perl.org/Data/Dumper.html" target="_blank" rel="noopener">Data::Dumper</a>可以被用于输出任意scalar到屏幕上，这是非常有用的调试工具。</p>
</li>
<li><p>还有另一种语法<code>qw{ }</code>可以用来声明array，常常在<code>use</code>语句用到它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Account qw&#123;create open close suspend delete&#125;;</span><br></pre></td></tr></table></figure>

<p>有<a href="http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators" target="_blank" rel="noopener">许多引号一样的运算符</a>。</p>
</li>
<li><p>在<code>=~ m//</code>和<code>=~ s///</code>运算符中，你可以用花括号代替斜杠作为正则表达式的分隔符，当你的正则表达式中包含很多斜杠时候就很有用了，要不然你就得使用很多反斜杠来进行跳脱。例如，<code>=~ m{///}</code>将匹配三个斜杠而<code>=~ s{^https?://}{}</code>会移除URL的协议部分。</p>
</li>
<li><p>Perl没有<code>CONSTANTS</code>。现在不鼓励使用它们，不过以前不一定。常量实际上就是省略括号的子程序调用。</p>
</li>
<li><p>有时候人们省略hash键两旁的引号，写成<code>$hash{key}</code>而非<code>$hash{&quot;key&quot;}</code>。 当这个孤零零的<code>key</code>恰好表示字符串<code>&quot;key&quot;</code>而不是子程序调用<code>key()</code>的时候，它们才能侥幸成功。</p>
</li>
<li><p>如果你看到一块由两个左尖括号作为分隔符包围起来的没有格式化的代码，就像<code>&lt;&lt;EOF</code>，可以通过在Google中搜索“here-doc”找到它的解释。（译者注：这是再一次吐槽因为Perl滥用符号导致难以搜索。）</p>
</li>
<li><p>警告！许多内置函数调用时都可以不给参数，<strong>那样它们就会使用<code>$_</code>代替</strong>，希望这可以帮助你理解下面这种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print foreach @array;</span><br></pre></td></tr></table></figure>

<p>还有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach ( @array ) &#123;</span><br><span class="line">	next unless defined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我不喜欢这种写法，因为在代码重构时将会遇到麻烦。</p>
</li>
</ul>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://aotle.top/2020/12/07/perl_low/>http://aotle.top/2020/12/07/perl_low/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-12-07T17:45:33+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Dec 7, 2020</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/perl/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>perl</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://aotle.top/2020/12/07/perl_low/&title=Perl快速入门 - Aotle&summary=
转载自：https://qntm.org/perl
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://aotle.top/2020/12/07/perl_low/&title=Perl快速入门 - Aotle&summary=
转载自：https://qntm.org/perl
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://aotle.top/2020/12/07/perl_low/&title=Perl快速入门 - Aotle&summary=
转载自：https://qntm.org/perl
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/12/16/java_method/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>java方法小抄</p>
                <p class='content'>
Java方法记录



Array和List相互转化Arrays.asList把数组转化成List123456789101112131415import java.util.Arrays;/*...</p>
              </a>
            
            
              <a class='next' href='/2020/12/04/javajihe_shixian/'>
                <p class='title'>JAVA集合复习-实现类<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>
java集合实现类



实现类

arraylist
主要继承的接口如下：
1.Collection 接口： Collection接口是所有集合类的根节点，Collection表示一种规则，...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Perl快速入门',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#序言"><span class="toc-text">序言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-world"><span class="toc-text">Hello world</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scalar变量"><span class="toc-text">Scalar变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#“布尔类型”（“Boolean”）"><span class="toc-text">“布尔类型”（“Boolean”）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#弱类型"><span class="toc-text">弱类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array变量"><span class="toc-text">Array变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash变量"><span class="toc-text">Hash变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#列表（Lists）"><span class="toc-text">列表（Lists）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文"><span class="toc-text">上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用和嵌套数据结构"><span class="toc-text">引用和嵌套数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#声明数据结构"><span class="toc-text">声明数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从数据结构中获取信息"><span class="toc-text">从数据结构中获取信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何用array的引用作茧自缚"><span class="toc-text">如何用array的引用作茧自缚</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件分支"><span class="toc-text">条件分支</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if-…-elsif-…-else-…"><span class="toc-text">if … elsif … else …</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unless-…-else-…"><span class="toc-text">unless … else …</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三目运算符"><span class="toc-text">三目运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#循环控制"><span class="toc-text">循环控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array函数"><span class="toc-text">Array函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原地（In-place）array修改函数"><span class="toc-text">原地（In-place）array修改函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从现有的array创建新的array"><span class="toc-text">从现有的array创建新的array</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置函数"><span class="toc-text">内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户自定义的子程序"><span class="toc-text">用户自定义的子程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Perl以引用方式调用"><span class="toc-text">Perl以引用方式调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提取参数"><span class="toc-text">提取参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回值"><span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用"><span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件和文件句柄"><span class="toc-text">文件和文件句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件检测"><span class="toc-text">文件检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块和包"><span class="toc-text">模块和包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模块"><span class="toc-text">模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#包"><span class="toc-text">包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Perl的面向对象"><span class="toc-text">Perl的面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BEGIN块"><span class="toc-text">BEGIN块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use"><span class="toc-text">use</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exporter"><span class="toc-text">Exporter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXPORT"><span class="toc-text">@EXPORT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#杂项"><span class="toc-text">杂项</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='822934507'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="/1781322024@qq.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/Aotle"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=549195595"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        
      
    
      
        
      
    
      
        <div class='copyright'>
        <p><a href="https://Aotle.github.io" target="_blank" rel="noopener">Copyright © 2017-2020 F.A</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["http://i1.fuimg.com/721743/90478b03f49d8057.png"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "B2JRC0gFBmeF5lDPxqa3TuTr-gzGzoHsz",
    appKey: "x3BFjG0bdCFyRFGeg1QJUP8D",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>





  <script>setLoadingBarProgress(100);</script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

